{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "colorpicker/ColorpickerHSLRepresentationSquare",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/colorpicker/ColorpickerHSLRepresentationSquare.vue",
      "content": "<template>\n    <div class=\"b-colorpicker-square\" :style=\"{ width: `${size}px` }\">\n        <div\n            class=\"colorpicker-square-slider-hue\"\n            @click=\"clickHue\"\n            @mousedown.prevent=\"startMouseCapture\"\n            @touchstart.prevent=\"startMouseCapture\"\n        >\n            <div\n                ref=\"hueCursor\"\n                role=\"slider\"\n                class=\"hue-range-thumb\"\n                tabindex=\"0\"\n                aria-label=\"Hue\"\n                aria-valuemin=\"0\"\n                aria-valuemax=\"359\"\n                :style=\"hueThumbStyle\"\n            />\n        </div>\n        <div\n            class=\"colorpicker-square-slider-sl\"\n            :style=\"{\n                background: SLBackground,\n                margin: `${thickness}px`\n            }\"\n            aria-datascales=\"lightness, saturation\"\n            @click=\"clickSL\"\n            @mousedown.prevent=\"startMouseCapture\"\n            @touchstart.prevent=\"startMouseCapture\"\n        >\n            <div\n                ref=\"slCursor\"\n                role=\"slider\"\n                class=\"sl-range-thumb\"\n                tabindex=\"0\"\n                :aria-datavalues=\"`${saturation * 100}%, ${lightness * 100}%`\"\n                :style=\"slThumbStyle\"\n                @click=\"clickSL\"\n                @keydown=\"slKeyPress\"\n                @mousedown.prevent=\"startMouseCapture\"\n                @touchstart.prevent=\"startMouseCapture\"\n            />\n        </div>\n    </div>\n</template>\n\n<script>\nimport Color from '@/utils/color'\nconst precision = (strs, ...values) => {\n    const tmp = []\n    strs.forEach((str, i) => {\n        tmp.push(str)\n\n        if (values[i]) {\n            tmp.push(\n                Number.isNaN(values[i] / 1)\n                    ? values[i]\n                    : Math.round(values * 10) / 10\n            )\n        }\n    })\n\n    return tmp.join('')\n}\n\nexport default {\n    name: 'BColorpickerHSLRepresentationSquare',\n    props: {\n        value: {\n            type: Object,\n            required: true,\n            validator(value) {\n                return typeof value.hue === 'number' &&\n                    typeof value.saturation === 'number' &&\n                    typeof value.lightness === 'number'\n            }\n        },\n        size: {\n            type: Number,\n            default: 200\n        },\n        thickness: {\n            type: Number,\n            default: 20\n        }\n    },\n    data() {\n        return {\n            hue: this.value.hue,\n            saturation: this.value.saturation,\n            lightness: this.value.lightness,\n            captureMouse: false,\n            captureType: 'hue',\n            clientOffset: {\n                cx: -1,\n                cy: -1,\n                width: 0,\n                height: 0\n            },\n            debounce: 0\n        }\n    },\n    computed: {\n        hueThumbStyle() {\n            const { hue, size, thickness } = this\n            const side = size - thickness\n            const offset = size / 2\n            const angle = ((hue + 720 + 90) % 360) / 180 * Math.PI\n            const ciq = 1 / Math.cos(Math.PI / 4)\n            const { x, y } = {\n                x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,\n                y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset\n            }\n            return {\n                background: `hsl(${hue}deg, 100%, 50%)`,\n                left: precision`${x}px`,\n                top: precision`${y}px`,\n                width: precision`${thickness - 2}px`\n            }\n        },\n        slThumbStyle() {\n            let { hue, saturation, lightness } = this\n            saturation = Math.max(0, Math.min(1, saturation))\n            lightness = Math.max(0, Math.min(1, lightness))\n            return {\n                background: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`,\n                left: `${saturation * 100}%`,\n                top: `${(1 - lightness) * 100}%`\n            }\n        },\n        SLBackground() {\n            const { hue } = this\n            return `linear-gradient(90deg, hsl(${hue}deg, 0%, 50%), hsl(${hue}deg, 100%, 50%))`\n        }\n    },\n    watch: {\n        captureMouse(newValue, oldValue) {\n            if (oldValue === false && newValue !== false) {\n                const rect = this.$el.getBoundingClientRect()\n                // Caching offset\n                this.clientOffset.cx = rect.x + rect.width / 2\n                this.clientOffset.cy = rect.y + rect.height / 2\n                this.clientOffset.width = rect.width\n                this.clientOffset.height = rect.height\n            }\n        },\n        value: {\n            deep: true,\n            handler(newColor) {\n                const { hue, saturation, lightness } = newColor\n\n                window.clearTimeout(this.debounce)\n                this.debounce = window.setTimeout(() => {\n                    this.hue = hue\n                    this.saturation = saturation\n                    this.lightness = lightness\n                }, 200)\n            }\n        }\n    },\n    methods: {\n        increaseHue(value = 1) {\n            this.hue = (this.hue + value) % 360\n        },\n        decreaseHue(value = 1) {\n            this.hue = (360 + this.hue - value) % 360\n        },\n        increaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation + value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        decreaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation - value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        increaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness + value\n                )\n            )\n        },\n        decreaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness - value\n                )\n            )\n        },\n        hueKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                case 'ArrowUp':\n                    this.increaseHue()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                case 'ArrowDown':\n                    this.decreaseHue()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseHue(360 - this.hue)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseHue(this.hue)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseHue(60 - this.hue % 60)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseHue(60 + this.hue % 60)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        slKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                    this.increaseSaturation()\n                    handled = true\n                    break\n                case 'ArrowUp':\n                    this.increaseLightness()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                    this.decreaseSaturation()\n                    handled = true\n                    break\n                case 'ArrowDown':\n                    this.decreaseLightness()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseLightness(1 - this.lightness)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseLightness(this.lightness)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseSaturation(1 - this.saturation)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseSaturation(this.saturation)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        startMouseCapture(event) {\n            event.stopPropagation()\n\n            this.captureMouse = true\n            if (event.target.closest('.colorpicker-square-slider-sl') !== null) {\n                this.captureType = 'sl'\n            } else {\n                this.captureType = 'hue'\n            }\n        },\n        stopMouseCapture(event) {\n            if (this.captureMouse !== false) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus()\n            }\n            this.captureMouse = false\n        },\n        clickHue(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.hueCursor.focus()\n        },\n        clickSL(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.slCursor.focus()\n        },\n        trackMouse(event) {\n            if (this.captureMouse === false) {\n                return\n            }\n            event.preventDefault()\n            event.stopPropagation()\n\n            let [mouseX, mouseY] = [0, 0]\n            if (typeof event.touches !== 'undefined' && event.touches.length) {\n                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY]\n            } else {\n                [mouseX, mouseY] = [event.clientX, event.clientY]\n            }\n            const angle = Math.atan2(\n                mouseY - this.clientOffset.cy,\n                mouseX - this.clientOffset.cx\n            )\n\n            if (this.captureType === 'sl') {\n                const saturation = (mouseX - this.clientOffset.cx) /\n                    (this.clientOffset.width - this.thickness * 2) +\n                    0.5\n                const lightness = (mouseY - this.clientOffset.cy) /\n                    (this.clientOffset.height - this.thickness * 2) +\n                    0.5\n\n                this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000\n                this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000\n            } else {\n                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360\n            }\n            this.emitColor()\n        },\n        emitColor() {\n            const { hue, saturation, lightness } = this\n            this.$emit('input', Color.fromHSL(hue, saturation, lightness))\n            window.clearTimeout(this.debounce)\n        }\n    },\n    mounted() {\n        window.addEventListener('mousemove', this.trackMouse)\n        window.addEventListener('touchmove', this.trackMouse, { passive: false })\n        window.addEventListener('mouseup', this.stopMouseCapture)\n        window.addEventListener('touchend', this.stopMouseCapture)\n    },\n    beforeDestroy() {\n        window.removeEventListener('mousemove', this.trackMouse)\n        window.removeEventListener('touchmove', this.trackMouse)\n        window.removeEventListener('mouseup', this.stopMouseCapture)\n        window.removeEventListener('touchend', this.stopMouseCapture)\n\n        clearTimeout(this.debounce)\n    }\n}\n</script>\n",
      "path": "src/components/colorpicker/ColorpickerHSLRepresentationSquare.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/color.js",
      "content": "export const colorChannels = ['red', 'green', 'blue', 'alpha']\n\nexport const colorsNammed = {\n    transparent: '#00000000',\n    black: '#000000',\n    silver: '#c0c0c0',\n    gray: '#808080',\n    white: '#ffffff',\n    maroon: '#800000',\n    red: '#ff0000',\n    purple: '#800080',\n    fuchsia: '#ff00ff',\n    green: '#008000',\n    lime: '#00ff00',\n    olive: '#808000',\n    yellow: '#ffff00',\n    navy: '#000080',\n    blue: '#0000ff',\n    teal: '#008080',\n    aqua: '#00ffff',\n    orange: '#ffa500',\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    blanchedalmond: '#ffebcd',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    oldlace: '#fdf5e6',\n    olivedrab: '#6b8e23',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    whitesmoke: '#f5f5f5',\n    yellowgreen: '#9acd32',\n    rebeccapurple: '#663399'\n}\n\nexport class ColorTypeError extends Error {\n    constructor() {\n        super('ColorTypeError: type must be hex(a), rgb(a) or hsl(a)')\n    }\n}\n\nclass Color {\n    constructor(...args) {\n        if (args.length > 0) {\n            return Color.parse(...args)\n        }\n\n        this.$channels = new Uint8Array(colorChannels.length)\n        colorChannels.forEach((channel, index) => {\n            Object.defineProperty(\n                this,\n                channel,\n                {\n                    get: () => this.$channels[index],\n                    set: (byte) => {\n                        if (!Number.isNaN(byte / 1)) {\n                            this.$channels[index] = Math.min(255, Math.max(0, byte))\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                }\n            )\n        })\n        // Required for observability\n        ;['hue', 'saturation', 'lightness'].forEach((name) => {\n            const capitalizedName = name.replace(/^./, (m) => m.toUpperCase())\n            Object.defineProperty(\n                this,\n                name,\n                {\n                    get: () => this[`get${capitalizedName}`](),\n                    set: (value) => {\n                        if (!Number.isNaN(value / 1)) {\n                            this[`set${capitalizedName}`](value)\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                }\n            )\n        })\n    }\n\n    getHue() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n        const delta = max - min\n        let hue = 0\n\n        if (delta === 0) {\n            return hue\n        }\n\n        if (red === max) {\n            hue = ((green - blue) / delta) % 6\n        } else if (green === max) {\n            hue = (blue - red) / delta + 2\n        } else {\n            hue = (red - green) / delta + 4\n        }\n\n        hue *= 60\n        while (hue !== -Infinity && hue < 0) hue += 360\n\n        return Math.round(hue % 360)\n    }\n\n    setHue(value) {\n        const color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255)\n        for (let i = 0; i < this.$channels.length; i++) {\n            this.$channels[i] = Number(color.$channels[i])\n        }\n    }\n\n    getSaturation() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n        const delta = max - min\n\n        return delta !== 0\n            ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100\n            : 0\n    }\n\n    setSaturation(value) {\n        const color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255)\n        colorChannels.forEach((_, i) => (this.$channels[i] = color.$channels[i]))\n    }\n\n    getLightness() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n\n        return Math.round((max + min) / 2 * 100) / 100\n    }\n\n    setLightness(value) {\n        const color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255)\n        colorChannels.forEach((_, i) => (this.$channels[i] = color.$channels[i]))\n    }\n\n    clone() {\n        const color = new Color()\n        colorChannels.forEach((_, i) => (color.$channels[i] = this.$channels[i]))\n\n        return color\n    }\n\n    toString(type = 'hex') {\n        switch (String(type).toLowerCase()) {\n            case 'hex':\n                return '#' + colorChannels.slice(0, 3)\n                    .map((channel) => this[channel].toString(16).padStart(2, '0'))\n                    .join('')\n            case 'hexa':\n                return '#' + colorChannels\n                    .map((channel) => this[channel].toString(16).padStart(2, '0'))\n                    .join('')\n            case 'rgb':\n                return `rgb(${this.red}, ${this.green}, ${this.blue})`\n            case 'rgba':\n                return `rgba(${this.red}, ${this.green}, ${this.blue}, ${Math.round(this.alpha / 2.55) / 100})`\n            case 'hsl':\n                return `hsl(${Math.round(this.hue)}deg, ${Math.round(this.saturation * 100)}%, ${Math.round(this.lightness * 100)}%)`\n            case 'hsla':\n                return `hsla(${Math.round(this.hue)}deg, ${Math.round(this.saturation * 100)}%, ${Math.round(this.lightness * 100)}%, ${Math.round(this.alpha / 2.55) / 100})`\n            default:\n                throw new ColorTypeError()\n        }\n    }\n\n    get [Symbol.toString]() {\n        return this.toString('hex')\n    }\n\n    static parse(...args) {\n        if (typeof args[0] === 'object') {\n            return Color.parseObject(args[0])\n        } else if (args.every((arg) => !Number.isNaN(arg / 1))) {\n            const color = new Color()\n            if (args.length > 3) {\n                color.red = args[0]\n                color.green = args[1]\n                color.blue = args[2]\n\n                if (args[3]) {\n                    color.alpha = args[3]\n                }\n            } else if (args.length === 1) {\n                const index = Number(args[0])\n\n                return Color.parseIndex(index, index > 2 ** 24 ? 3 : 4)\n            }\n        } else if (typeof args[0] === 'string') {\n            let match = null\n\n            if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {\n                return Color.parseHex(colorsNammed[args[0].toLowerCase()])\n            } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {\n                return Color.parseHex(match[2])\n            } else if ((match = args[0].match(/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(\\s*,\\s*(\\d*\\.?\\d+))?\\s*\\)$/i)) !== null) {\n                const channels = [\n                    match[1],\n                    match[2],\n                    match[3],\n                    typeof match[5] !== 'undefined'\n                        ? match[5]\n                        : 1\n                ]\n\n                return Color.fromRGB(...channels.map((value) => Number(value)))\n            } else if ((args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\\(/i))) {\n                throw new Error('Color expression not implemented yet')\n            }\n        }\n\n        throw new Error('Invalid color expression')\n    }\n\n    static parseObject(object) {\n        const color = new Color()\n\n        if (object === null || typeof object !== 'object') {\n            return color\n        }\n        if (Color.isColor(object)) {\n            return object.clone()\n        }\n\n        colorChannels.forEach((channel) => {\n            if (!Number.isNaN(object[channel])) {\n                color[channel] = object[channel]\n            }\n        })\n\n        return color\n    }\n\n    static parseHex(hex) {\n        if (typeof hex !== 'string') {\n            throw new Error('Hex expression must be a string')\n        }\n\n        hex = hex.trim().replace(/^(0x|&h|#)/i, '')\n        if (hex.length === 3 || hex.length === 4) {\n            hex = hex.split('')\n                .map((c) => c.repeat(2))\n                .join('')\n        }\n\n        if (!(hex.length === 6 || hex.length === 8)) {\n            throw new Error('Incorrect Hex expression length')\n        }\n\n        const chans = hex.split(/(..)/)\n            .filter((value) => value)\n            .map((value) => Number.parseInt(value, 16))\n        if (typeof chans[3] === 'number') {\n            chans[3] /= 255\n        }\n        return Color.fromRGB(...chans)\n    }\n\n    static parseIndex(value, channels = 3) {\n        const color = new Color()\n\n        for (let i = 0; i < 4; i++) {\n            color[colorChannels[i]] = (value >> ((channels - i) * 8)) && 0xff\n        }\n\n        return color\n    }\n\n    static fromRGB(red, green, blue, alpha = 1) {\n        if ([red, green, blue, alpha].some((arg) => Number.isNaN(arg / 1))) {\n            throw new Error('Invalid arguments')\n        }\n        alpha *= 255\n\n        const color = new Color()\n        ;[red, green, blue, alpha].forEach((value, index) => {\n            color[colorChannels[index]] = value\n        })\n\n        return color\n    }\n\n    static fromHSL(hue, saturation, lightness, alpha = 1) {\n        if ([hue, saturation, lightness, alpha].some((arg) => Number.isNaN(arg))) {\n            throw new Error('Invalid arguments')\n        }\n        while (hue < 0 && hue !== -Infinity) hue += 360\n        hue = hue % 360\n        saturation = Math.max(0, Math.min(1, saturation))\n        lightness = Math.max(0, Math.min(1, lightness))\n        alpha = Math.max(0, Math.min(1, alpha))\n\n        const c = (1 - Math.abs(2 * lightness - 1)) * saturation\n        const x = c * (1 - Math.abs(hue / 60 % 2 - 1))\n        const m = lightness - c / 2\n\n        const [r, g, b] = hue < 60\n            ? [c, x, 0]\n            : hue < 120\n                ? [x, c, 0]\n                : hue < 180\n                    ? [0, c, x]\n                    : hue < 240\n                        ? [0, x, c]\n                        : hue < 300\n                            ? [x, 0, c]\n                            : [c, 0, x]\n\n        return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha)\n    }\n\n    static isColor(arg) {\n        return arg instanceof Color\n    }\n}\n\nexport default Color\n",
      "path": "src/utils/color.js"
    }
  ]
}
