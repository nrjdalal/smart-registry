{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "colorpicker/index",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:file",
      "target": "directives/trapFocus.js",
      "content": "const findFocusable = (element, programmatic = false) => {\n    if (!element) {\n        return null\n    }\n    if (programmatic) {\n        return element.querySelectorAll(`*[tabindex=\"-1\"]`)\n    }\n    return element.querySelectorAll(`a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]`)\n}\n\nlet onKeyDown\n\nconst bind = (el, { value = true }) => {\n    if (value) {\n        let focusable = findFocusable(el)\n        let focusableProg = findFocusable(el, true)\n\n        if (focusable && focusable.length > 0) {\n            onKeyDown = (event) => {\n                // Need to get focusable each time since it can change between key events\n                // ex. changing month in a datepicker\n                focusable = findFocusable(el)\n                focusableProg = findFocusable(el, true)\n                const firstFocusable = focusable[0]\n                const lastFocusable = focusable[focusable.length - 1]\n\n                if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    lastFocusable.focus()\n                } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    firstFocusable.focus()\n                }\n            }\n            el.addEventListener('keydown', onKeyDown)\n        }\n    }\n}\n\nconst unbind = (el) => {\n    el.removeEventListener('keydown', onKeyDown)\n}\n\nconst directive = {\n    bind,\n    unbind\n}\n\nexport default directive\n",
      "path": "src/directives/trapFocus.js"
    },
    {
      "type": "registry:component",
      "target": "components/colorpicker/Colorpicker.vue",
      "content": "<template>\n    <div\n        class=\"colorpicker control\"\n        :class=\"[size, {'is-expanded': expanded}]\"\n    >\n        <b-dropdown\n            v-if=\"!isMobile || inline\"\n            ref=\"dropdown\"\n            :position=\"position\"\n            :expanded=\"expanded\"\n            :disabled=\"disabled\"\n            :inline=\"inline\"\n            :mobile-modal=\"mobileModal\"\n            :trap-focus=\"trapFocus\"\n            :aria-role=\"ariaRole\"\n            :append-to-body=\"appendToBody\"\n            append-to-body-copy-parent\n            @active-change=\"onActiveChange\"\n        >\n            <template #trigger v-if=\"!inline\">\n                <slot name=\"trigger\">\n                    <b-button\n                        :style=\"triggerStyle\"\n                        :expanded=\"expanded\"\n                        :disabled=\"disabled\"\n                    >\n                        <span class=\"color-name\">{{ colorFormatter(computedValue) }}</span>\n                    </b-button>\n                </slot>\n            </template>\n\n            <b-dropdown-item\n                :disabled=\"disabled\"\n                :focusable=\"focusable\"\n                custom\n                :class=\"{'dropdown-horizontal-colorpicker': horizontalColorPicker}\"\n            >\n                <div>\n                    <header class=\"colorpicker-header\">\n                        <template v-if=\"$slots.header !== undefined && $slots.header.length\">\n                            <slot name=\"header\" />\n                        </template>\n                    </header>\n                    <div class=\"colorpicker-content\">\n                        <b-colorpicker-h-s-l-representation-square\n                            v-if=\"representation === 'square'\"\n                            :value=\"computedValue\"\n                            @input=\"updateColor\"\n                        />\n                        <b-colorpicker-h-s-l-representation-triangle\n                            v-else\n                            :value=\"computedValue\"\n                            @input=\"updateColor\"\n                        />\n                    </div>\n                </div>\n                <footer class=\"colorpicker-footer\">\n                    <b-colorpicker-alpha-slider\n                        v-if=\"alpha\"\n                        :value=\"computedValue.alpha\"\n                        @input=\"updateAlpha\"\n                        :color=\"computedValue\"\n                    />\n                    <slot name=\"footer\" :color=\"computedValue\">\n                        <b-field class=\"colorpicker-fields\" grouped>\n                            <b-field horizontal label=\"R\">\n                                <b-input\n                                    type=\"number\"\n                                    v-model.number=\"computedValue.red\"\n                                    @input=\"updateRGB\"\n                                    size=\"is-small\"\n                                    aria-label=\"Red\"\n                                />\n                            </b-field>\n                            <b-field horizontal label=\"G\">\n                                <b-input\n                                    type=\"number\"\n                                    v-model.number=\"computedValue.green\"\n                                    @input=\"updateRGB\"\n                                    size=\"is-small\"\n                                    aria-label=\"Green\"\n                                />\n                            </b-field>\n                            <b-field horizontal label=\"B\">\n                                <b-input\n                                    type=\"number\"\n                                    v-model.number=\"computedValue.blue\"\n                                    @input=\"updateRGB\"\n                                    size=\"is-small\"\n                                    aria-label=\"Blue\"\n                                />\n                            </b-field>\n                        </b-field>\n                    </slot>\n                </footer>\n            </b-dropdown-item>\n        </b-dropdown>\n    </div>\n</template>\n\n<script>\nimport FormElementMixin from '@/utils/FormElementMixin'\nimport { isMobile } from '@/utils/helpers'\nimport config from '@/utils/config'\nimport Color from '@/utils/color'\n\nimport Dropdown from '@/components/dropdown/Dropdown'\nimport DropdownItem from '@/components/dropdown/DropdownItem'\nimport Input from '@/components/input/Input'\nimport Field from '@/components/field/Field'\nimport Select from '@/components/select/Select'\nimport Icon from '@/components/icon/Icon'\n\nimport ColorpickerHSLRepresentationTriangle from '@/components/colorpicker/ColorpickerHSLRepresentationTriangle'\nimport ColorpickerHSLRepresentationSquare from '@/components/colorpicker/ColorpickerHSLRepresentationSquare'\nimport ColorpickerAlphaSlider from '@/components/colorpicker/ColorpickerAlphaSlider'\n\nconst defaultColorFormatter = (color, vm) => {\n    if (color.alpha < 1) {\n        return color.toString('hexa')\n    } else {\n        return color.toString('hex')\n    }\n}\n\nconst defaultColorParser = (color, vm) => {\n    return Color.parse(color)\n}\n\nexport default {\n    name: 'BColorpicker',\n    components: {\n        [ColorpickerHSLRepresentationTriangle.name]: ColorpickerHSLRepresentationTriangle,\n        [ColorpickerHSLRepresentationSquare.name]: ColorpickerHSLRepresentationSquare,\n        [ColorpickerAlphaSlider.name]: ColorpickerAlphaSlider,\n        [Input.name]: Input,\n        [Field.name]: Field,\n        [Select.name]: Select,\n        [Icon.name]: Icon,\n        [Dropdown.name]: Dropdown,\n        [DropdownItem.name]: DropdownItem\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    provide() {\n        return {\n            $colorpicker: this\n        }\n    },\n    props: {\n        value: {\n            type: [String, Object],\n            validator(value) {\n                return typeof value === 'string' ||\n                    (\n                        typeof value === 'object' &&\n                        typeof value.red === 'number' &&\n                        typeof value.green === 'number' &&\n                        typeof value.blue === 'number'\n                    )\n            }\n        },\n        representation: {\n            type: String,\n            default: 'triangle',\n            value(value) {\n                return ['triangle', 'square'].some((r) => r === value)\n            }\n        },\n        inline: Boolean,\n        disabled: Boolean,\n        horizontalColorPicker: {\n            type: Boolean,\n            default: false\n        },\n        colorFormatter: {\n            type: Function,\n            default: (color, vm) => {\n                if (typeof config.defaultColorFormatter === 'function') {\n                    return config.defaultColorFormatter(color)\n                } else {\n                    return defaultColorFormatter(color, vm)\n                }\n            }\n        },\n        colorParser: {\n            type: Function,\n            default: (color, vm) => {\n                if (typeof config.defaultColorParser === 'function') {\n                    return config.defaultColorParser(color)\n                } else {\n                    return defaultColorParser(color, vm)\n                }\n            }\n        },\n        alpha: {\n            type: Boolean,\n            default: false\n        },\n        expanded: Boolean,\n        position: String,\n        mobileModal: {\n            type: Boolean,\n            default: () => config.defaultDatepickerMobileModal\n        },\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        trapFocus: {\n            type: Boolean,\n            default: () => config.defaultTrapFocus\n        },\n        appendToBody: Boolean\n    },\n    data() {\n        return {\n            color: this.parseColor(this.value)\n        }\n    },\n    computed: {\n        computedValue: {\n            set(value) {\n                this.color = this.parseColor(value)\n            },\n            get() {\n                return this.color\n            }\n        },\n        background() {\n            if (this.alpha) {\n                return `linear-gradient(\n                    45deg,\n                    ${this.computedValue.toString('hex')} 50%,\n                    ${this.computedValue.toString('hexa')} 50%\n                )`\n            } else {\n                const hex = this.computedValue.toString('hex')\n                return `linear-gradient(\n                    45deg,\n                    ${hex} 50%,\n                    ${hex} 50%\n                )`\n            }\n        },\n        triggerStyle() {\n            const { red, green, blue } = this.computedValue\n            const light = (red * 0.299 + green * 0.587 + blue * 0.114) > 186\n\n            return {\n                backgroundColor: '#ffffff',\n                backgroundImage: `\n                    ${this.background},\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)\n                `,\n                backgroundSize: '100% 100%, 16px 16px, 16px 16px',\n                backgroundPosition: '0 0, 8px 8px, 0 0',\n                color: light ? '#000000' : '#FFFFFF',\n                textShadow: `0 0 2px ${light ? '#FFFFFFAA' : '#000000AA'}`\n            }\n        },\n\n        isMobile() {\n            return this.mobileNative && isMobile.any()\n        },\n\n        ariaRole() {\n            if (!this.inline) {\n                return 'dialog'\n            }\n        }\n    },\n    watch: {\n        value(value) {\n            this.computedValue = new Color(value)\n        }\n    },\n    methods: {\n        parseColor(color) {\n            try {\n                return this.colorParser(color)\n            } catch (e) {\n                return new Color()\n            }\n        },\n        updateColor(value) {\n            value.alpha = this.computedValue.alpha\n            this.computedValue = value\n            this.$emit('input', value)\n        },\n        updateAlpha(alpha) {\n            this.computedValue.alpha = alpha\n            this.$emit('input', this.computedValue)\n        },\n        updateRGB() {\n            this.$emit('input', this.computedValue)\n        },\n        /*\n         * Format color into string\n         */\n        formatValue(value) {\n            return value ? this.colorFormatter(value, this) : null\n        },\n\n        /*\n         * Toggle datepicker\n         */\n        togglePicker(active) {\n            if (this.$refs.dropdown) {\n                const isActive = typeof active === 'boolean'\n                    ? active\n                    : !this.$refs.dropdown.isActive\n                if (isActive) {\n                    this.$refs.dropdown.isActive = isActive\n                } else if (this.closeOnClick) {\n                    this.$refs.dropdown.isActive = isActive\n                }\n            }\n        },\n\n        /*\n         * Call default onFocus method and show datepicker\n         */\n        handleOnFocus(event) {\n            this.onFocus(event)\n            if (this.openOnFocus) {\n                this.togglePicker(true)\n            }\n        },\n\n        /*\n         * Toggle dropdown\n         */\n        toggle() {\n            if (this.mobileNative && this.isMobile) {\n                const input = this.$refs.input.$refs.input\n                input.focus()\n                input.click()\n                return\n            }\n            this.$refs.dropdown.toggle()\n        },\n\n        /*\n         * Avoid dropdown toggle when is already visible\n         */\n        onInputClick(event) {\n            if (this.$refs.dropdown.isActive) {\n                event.stopPropagation()\n            }\n        },\n\n        /**\n         * Keypress event that is bound to the document.\n         */\n        keyPress({ key }) {\n            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {\n                this.togglePicker(false)\n            }\n        },\n\n        /**\n         * Emit 'blur' event on dropdown is not active (closed)\n         */\n        onActiveChange(value) {\n            if (!value) {\n                this.onBlur()\n            }\n            /*\n             * Emit 'active-change' when on dropdown active state change\n             */\n            this.$emit('active-change', value)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/colorpicker/Colorpicker.vue"
    },
    {
      "type": "registry:component",
      "target": "components/colorpicker/ColorpickerAlphaSlider.vue",
      "content": "<template>\n    <div\n        class=\"b-colorpicker-alpha-slider\"\n        :style=\"style\"\n        @click=\"clickAlpha\"\n        @keydown=\"alphaKeyPress\"\n        @mousedown=\"startMouseCapture\"\n        @touchstart.prevent=\"startMouseCapture\"\n    >\n        <div\n            ref=\"alphaCursor\"\n            role=\"slider\"\n            class=\"alpha-range-thumb\"\n            tabindex=\"0\"\n            aria-label=\"Tranparency\"\n            aria-valuemin=\"0\"\n            :aria-valuenow=\"percent\"\n            aria-valuemax=\"100\"\n            :style=\"{ left: `${percent}%` }\"\n        >\n            <b-tooltip :label=\"`${percent}%`\" :always=\"captureMouse\">\n                &nbsp;\n            </b-tooltip>\n        </div>\n    </div>\n</template>\n\n<script>\nimport Color from '@/utils/color'\nimport Tooltip from '@/components/tooltip/Tooltip'\n\nexport default {\n    name: 'BColorpickerAlphaSlider',\n    components: {\n        [Tooltip.name]: Tooltip\n    },\n    props: {\n        value: {\n            type: Number,\n            validator: (value) => value >= 0 && value < 256\n        },\n        color: [String, Object]\n    },\n    data() {\n        const color = Color.parse(this.color)\n\n        color.alpha = 0\n        return {\n            startColor: color.toString('hex'),\n            endColor: color.toString('hexa'),\n            percent: Math.round((1 - this.value / 255) * 100),\n            captureMouse: false,\n            clientOffset: {\n                cx: -1,\n                cy: -1,\n                width: 0,\n                height: 0\n            }\n        }\n    },\n    computed: {\n        style() {\n            return {\n                backgroundImage:\n                    `linear-gradient(90deg, ${this.startColor} 0%, ${this.endColor} 100%),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)`,\n                backgroundSize: '100% 100%, 1em 1em, 1em 1em',\n                backgroundPosition: '0 0, .5em .5em, 0 0'\n            }\n        }\n    },\n    watch: {\n        value(newValue, oldValue) {\n            if (newValue !== oldValue) {\n                this.percent = Math.round((1 - newValue / 255) * 100)\n            }\n        },\n        color(newColor) {\n            const color = Color.parse(newColor)\n\n            color.alpha = 0\n            this.startColor = color.toString('hex')\n            this.endColor = color.toString('hexa')\n        },\n        captureMouse(newValue, oldValue) {\n            if (oldValue === false && newValue !== false) {\n                const rect = this.$el.getBoundingClientRect()\n                // Caching offset\n                this.clientOffset.cx = rect.x + rect.width / 2\n                this.clientOffset.cy = rect.y + rect.height / 2\n                this.clientOffset.width = rect.width\n                this.clientOffset.height = rect.height\n            }\n        }\n    },\n    methods: {\n        increaseAlpha(value = 1) {\n            this.percent = Math.max(0, Math.min(100, this.percent + value))\n        },\n        decreaseAlpha(value = 0.01) {\n            this.increaseAlpha(-value)\n        },\n        alphaKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                case 'ArrowUp':\n                    this.increaseAlpha()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                case 'ArrowDown':\n                    this.decreaseAlpha()\n                    handled = true\n                    break\n                case 'Home':\n                    this.decreaseAlpha(this.percent)\n                    handled = true\n                    break\n                case 'End':\n                    this.increaseAlpha(100 - this.percent)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseAlpha(10 - (this.percent % 10))\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseAlpha(this.percent % 10)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitAlpha()\n            }\n        },\n        clickAlpha(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.alphaCursor.focus()\n        },\n        startMouseCapture(event) {\n            event.stopPropagation()\n\n            this.captureMouse = true\n        },\n        trackMouse(event) {\n            if (this.captureMouse === false) {\n                return\n            }\n            event.preventDefault()\n            event.stopPropagation()\n\n            let [mouseX] = [0, 0]\n            if (typeof event.touches !== 'undefined' && event.touches.length) {\n                [mouseX] = [event.touches[0].clientX]\n            } else {\n                [mouseX] = [event.clientX]\n            }\n\n            const ratio = 0.5 + (this.clientOffset.cx - mouseX) / this.clientOffset.width\n            this.percent = Math.round(100 - Math.max(0, Math.min(1, ratio)) * 100)\n            this.emitAlpha()\n        },\n        stopMouseCapture(event) {\n            if (this.captureMouse !== false) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.$refs.alphaCursor.focus()\n            }\n            this.captureMouse = false\n        },\n        emitAlpha() {\n            this.$emit('input', (1 - this.percent / 100) * 255)\n        }\n    },\n    mounted() {\n        window.addEventListener('mousemove', this.trackMouse)\n        window.addEventListener('touchmove', this.trackMouse, { passive: false })\n        window.addEventListener('mouseup', this.stopMouseCapture)\n        window.addEventListener('touchend', this.stopMouseCapture)\n    },\n    beforeDestroy() {\n        window.removeEventListener('mousemove', this.trackMouse)\n        window.removeEventListener('touchmove', this.trackMouse)\n        window.removeEventListener('mouseup', this.stopMouseCapture)\n        window.removeEventListener('touchend', this.stopMouseCapture)\n    }\n}\n</script>\n",
      "path": "src/components/colorpicker/ColorpickerAlphaSlider.vue"
    },
    {
      "type": "registry:component",
      "target": "components/colorpicker/ColorpickerHSLRepresentationSquare.vue",
      "content": "<template>\n    <div class=\"b-colorpicker-square\" :style=\"{ width: `${size}px` }\">\n        <div\n            class=\"colorpicker-square-slider-hue\"\n            @click=\"clickHue\"\n            @mousedown.prevent=\"startMouseCapture\"\n            @touchstart.prevent=\"startMouseCapture\"\n        >\n            <div\n                ref=\"hueCursor\"\n                role=\"slider\"\n                class=\"hue-range-thumb\"\n                tabindex=\"0\"\n                aria-label=\"Hue\"\n                aria-valuemin=\"0\"\n                aria-valuemax=\"359\"\n                :style=\"hueThumbStyle\"\n            />\n        </div>\n        <div\n            class=\"colorpicker-square-slider-sl\"\n            :style=\"{\n                background: SLBackground,\n                margin: `${thickness}px`\n            }\"\n            aria-datascales=\"lightness, saturation\"\n            @click=\"clickSL\"\n            @mousedown.prevent=\"startMouseCapture\"\n            @touchstart.prevent=\"startMouseCapture\"\n        >\n            <div\n                ref=\"slCursor\"\n                role=\"slider\"\n                class=\"sl-range-thumb\"\n                tabindex=\"0\"\n                :aria-datavalues=\"`${saturation * 100}%, ${lightness * 100}%`\"\n                :style=\"slThumbStyle\"\n                @click=\"clickSL\"\n                @keydown=\"slKeyPress\"\n                @mousedown.prevent=\"startMouseCapture\"\n                @touchstart.prevent=\"startMouseCapture\"\n            />\n        </div>\n    </div>\n</template>\n\n<script>\nimport Color from '@/utils/color'\nconst precision = (strs, ...values) => {\n    const tmp = []\n    strs.forEach((str, i) => {\n        tmp.push(str)\n\n        if (values[i]) {\n            tmp.push(\n                Number.isNaN(values[i] / 1)\n                    ? values[i]\n                    : Math.round(values * 10) / 10\n            )\n        }\n    })\n\n    return tmp.join('')\n}\n\nexport default {\n    name: 'BColorpickerHSLRepresentationSquare',\n    props: {\n        value: {\n            type: Object,\n            required: true,\n            validator(value) {\n                return typeof value.hue === 'number' &&\n                    typeof value.saturation === 'number' &&\n                    typeof value.lightness === 'number'\n            }\n        },\n        size: {\n            type: Number,\n            default: 200\n        },\n        thickness: {\n            type: Number,\n            default: 20\n        }\n    },\n    data() {\n        return {\n            hue: this.value.hue,\n            saturation: this.value.saturation,\n            lightness: this.value.lightness,\n            captureMouse: false,\n            captureType: 'hue',\n            clientOffset: {\n                cx: -1,\n                cy: -1,\n                width: 0,\n                height: 0\n            },\n            debounce: 0\n        }\n    },\n    computed: {\n        hueThumbStyle() {\n            const { hue, size, thickness } = this\n            const side = size - thickness\n            const offset = size / 2\n            const angle = ((hue + 720 + 90) % 360) / 180 * Math.PI\n            const ciq = 1 / Math.cos(Math.PI / 4)\n            const { x, y } = {\n                x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,\n                y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset\n            }\n            return {\n                background: `hsl(${hue}deg, 100%, 50%)`,\n                left: precision`${x}px`,\n                top: precision`${y}px`,\n                width: precision`${thickness - 2}px`\n            }\n        },\n        slThumbStyle() {\n            let { hue, saturation, lightness } = this\n            saturation = Math.max(0, Math.min(1, saturation))\n            lightness = Math.max(0, Math.min(1, lightness))\n            return {\n                background: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`,\n                left: `${saturation * 100}%`,\n                top: `${(1 - lightness) * 100}%`\n            }\n        },\n        SLBackground() {\n            const { hue } = this\n            return `linear-gradient(90deg, hsl(${hue}deg, 0%, 50%), hsl(${hue}deg, 100%, 50%))`\n        }\n    },\n    watch: {\n        captureMouse(newValue, oldValue) {\n            if (oldValue === false && newValue !== false) {\n                const rect = this.$el.getBoundingClientRect()\n                // Caching offset\n                this.clientOffset.cx = rect.x + rect.width / 2\n                this.clientOffset.cy = rect.y + rect.height / 2\n                this.clientOffset.width = rect.width\n                this.clientOffset.height = rect.height\n            }\n        },\n        value: {\n            deep: true,\n            handler(newColor) {\n                const { hue, saturation, lightness } = newColor\n\n                window.clearTimeout(this.debounce)\n                this.debounce = window.setTimeout(() => {\n                    this.hue = hue\n                    this.saturation = saturation\n                    this.lightness = lightness\n                }, 200)\n            }\n        }\n    },\n    methods: {\n        increaseHue(value = 1) {\n            this.hue = (this.hue + value) % 360\n        },\n        decreaseHue(value = 1) {\n            this.hue = (360 + this.hue - value) % 360\n        },\n        increaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation + value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        decreaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation - value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        increaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness + value\n                )\n            )\n        },\n        decreaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness - value\n                )\n            )\n        },\n        hueKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                case 'ArrowUp':\n                    this.increaseHue()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                case 'ArrowDown':\n                    this.decreaseHue()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseHue(360 - this.hue)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseHue(this.hue)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseHue(60 - this.hue % 60)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseHue(60 + this.hue % 60)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        slKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                    this.increaseSaturation()\n                    handled = true\n                    break\n                case 'ArrowUp':\n                    this.increaseLightness()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                    this.decreaseSaturation()\n                    handled = true\n                    break\n                case 'ArrowDown':\n                    this.decreaseLightness()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseLightness(1 - this.lightness)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseLightness(this.lightness)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseSaturation(1 - this.saturation)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseSaturation(this.saturation)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        startMouseCapture(event) {\n            event.stopPropagation()\n\n            this.captureMouse = true\n            if (event.target.closest('.colorpicker-square-slider-sl') !== null) {\n                this.captureType = 'sl'\n            } else {\n                this.captureType = 'hue'\n            }\n        },\n        stopMouseCapture(event) {\n            if (this.captureMouse !== false) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus()\n            }\n            this.captureMouse = false\n        },\n        clickHue(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.hueCursor.focus()\n        },\n        clickSL(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.slCursor.focus()\n        },\n        trackMouse(event) {\n            if (this.captureMouse === false) {\n                return\n            }\n            event.preventDefault()\n            event.stopPropagation()\n\n            let [mouseX, mouseY] = [0, 0]\n            if (typeof event.touches !== 'undefined' && event.touches.length) {\n                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY]\n            } else {\n                [mouseX, mouseY] = [event.clientX, event.clientY]\n            }\n            const angle = Math.atan2(\n                mouseY - this.clientOffset.cy,\n                mouseX - this.clientOffset.cx\n            )\n\n            if (this.captureType === 'sl') {\n                const saturation = (mouseX - this.clientOffset.cx) /\n                    (this.clientOffset.width - this.thickness * 2) +\n                    0.5\n                const lightness = (mouseY - this.clientOffset.cy) /\n                    (this.clientOffset.height - this.thickness * 2) +\n                    0.5\n\n                this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000\n                this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000\n            } else {\n                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360\n            }\n            this.emitColor()\n        },\n        emitColor() {\n            const { hue, saturation, lightness } = this\n            this.$emit('input', Color.fromHSL(hue, saturation, lightness))\n            window.clearTimeout(this.debounce)\n        }\n    },\n    mounted() {\n        window.addEventListener('mousemove', this.trackMouse)\n        window.addEventListener('touchmove', this.trackMouse, { passive: false })\n        window.addEventListener('mouseup', this.stopMouseCapture)\n        window.addEventListener('touchend', this.stopMouseCapture)\n    },\n    beforeDestroy() {\n        window.removeEventListener('mousemove', this.trackMouse)\n        window.removeEventListener('touchmove', this.trackMouse)\n        window.removeEventListener('mouseup', this.stopMouseCapture)\n        window.removeEventListener('touchend', this.stopMouseCapture)\n\n        clearTimeout(this.debounce)\n    }\n}\n</script>\n",
      "path": "src/components/colorpicker/ColorpickerHSLRepresentationSquare.vue"
    },
    {
      "type": "registry:component",
      "target": "components/colorpicker/ColorpickerHSLRepresentationTriangle.vue",
      "content": "<template>\n    <svg :viewBox=\"viewBox\" class=\"b-colorpicker-triangle\">\n        <defs>\n            <linearGradient\n                :id=\"`cp-triangle-gradient-ligthness-${id}`\"\n                x1=\"0\"\n                y1=\"0\"\n                x2=\"1\"\n                y2=\"0\"\n            >\n                <stop offset=\"0%\" stop-color=\"#fff\"/>\n                <stop offset=\"100%\" stop-color=\"#000\"/>\n            </linearGradient>\n            <linearGradient\n                :id=\"`cp-triangle-gradient-saturation-${id}`\"\n                x1=\"0\"\n                y1=\"0\"\n                x2=\"0\"\n                y2=\"1\"\n            >\n                <stop\n                    offset=\"0%\"\n                    :stop-color=\"`hsl(${hue}deg, 100%, 50%)`\"\n                    stop-opacity=\"1\"\n                />\n                <stop\n                    offset=\"100%\"\n                    :stop-color=\"`hsl(${hue}deg, 100%, 50%)`\"\n                    stop-opacity=\"0\"\n                />\n            </linearGradient>\n            <clipPath :id=\"`cp-triangle-clip-${id}`\">\n                <path :d=\"haloPath\" />\n            </clipPath>\n        </defs>\n        <g class=\"colorpicker-triangle-slider-hue\">\n            <foreignObject\n                :x=\"0\"\n                :y=\"0\"\n                :width=\"size\"\n                :height=\"size\"\n                :clip-path=\"`url(#cp-triangle-clip-${id})`\"\n            >\n                <div\n                    class=\"colorpicker-triangle-hue\"\n                    @click=\"clickHue\"\n                    @mousedown.prevent=\"startMouseCapture\"\n                    @touchstart.prevent=\"startMouseCapture\"\n                />\n            </foreignObject>\n            <g :style=\"`transform: rotate(${hue}deg)`\">\n                <foreignObject\n                    :x=\"size / 2 - 4\"\n                    :y=\"0\"\n                    width=\"8\"\n                    :height=\"thickness + 4\"\n                >\n                    <div\n                        ref=\"hueCursor\"\n                        class=\"hue-range-thumb\"\n                        :style=\"`background-color: hsl(${hue}deg, 100%, 50%)`\"\n                        role=\"slider\"\n                        tabindex=\"0\"\n                        aria-label=\"Hue\"\n                        aria-valuemin=\"0\"\n                        :aria-valuenow=\"hue\"\n                        aria-valuemax=\"360\"\n                        @click=\"clickHue\"\n                        @keydown=\"hueKeyPress\"\n                        @mousedown.prevent=\"startMouseCapture\"\n                        @touchstart.prevent=\"startMouseCapture\"\n                    />\n                </foreignObject>\n            </g>\n        </g>\n        <g\n            class=\"colorpicker-triangle-slider-sl\"\n            :style=\"`transform: rotate(${hue}deg) translate(50%, 50%)`\"\n            role=\"graphics-datagroup\"\n            aria-datascales=\"lightness, saturation\"\n        >\n            <path\n                :d=\"trianglePath\"\n                :fill=\"`url(#cp-triangle-gradient-ligthness-${id})`\"\n            />\n            <path\n                :d=\"trianglePath\"\n                :fill=\"`url(#cp-triangle-gradient-saturation-${id})`\"\n                style=\"mix-blend-mode: overlay;\"\n                @click=\"clickSL\"\n                @mousedown.prevent=\"startMouseCapture\"\n                @touchstart.prevent=\"startMouseCapture\"\n            />\n            <foreignObject\n                :x=\"((internalRadius - 3) * cos30) * (-lightness + 0.5) * 2 - 6\"\n                :y=\"-internalRadius + (1 - saturation) * (internalRadius - 3) * 1.5 - 3\"\n                width=\"12\"\n                height=\"12\"\n            >\n                <div\n                    ref=\"slCursor\"\n                    class=\"sl-range-thumb\"\n                    :style=\"{\n                        backgroundColor: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`\n                    }\"\n                    tabindex=\"0\"\n                    :aria-datavalues=\"`${saturation * 100}%, ${lightness * 100}%`\"\n                    @click=\"clickSL\"\n                    @keydown=\"slKeyPress\"\n                    @mousedown.prevent=\"startMouseCapture\"\n                    @touchstart.prevent=\"startMouseCapture\"\n                />\n            </foreignObject>\n        </g>\n    </svg>\n</template>\n\n<script>\nimport Color from '@/utils/color'\nconst cos30 = 0.86602540378\nconst sin30 = 0.5\n\nlet id = 0\n\nexport default {\n    name: 'BColorpickerHSLRepresentationTriangle',\n    props: {\n        value: {\n            type: Object,\n            required: true,\n            validator(value) {\n                return typeof value.hue === 'number' &&\n                    typeof value.saturation === 'number' &&\n                    typeof value.lightness === 'number'\n            }\n        },\n        size: {\n            type: Number,\n            default: 200\n        },\n        thickness: {\n            type: Number,\n            default: 20\n        }\n    },\n    data() {\n        return {\n            id: id++,\n            hue: this.value.hue,\n            saturation: this.value.saturation,\n            lightness: this.value.lightness,\n            captureMouse: false,\n            captureType: 'hue',\n            clientOffset: {\n                cx: -1,\n                cy: -1,\n                width: 0,\n                height: 0\n            },\n            cos30,\n            sin30,\n            debounce: 0\n        }\n    },\n    computed: {\n        viewBox() {\n            const { size } = this\n            return `0 0 ${size} ${size}`\n        },\n        internalRadius() {\n            return this.size / 2 - this.thickness\n        },\n        haloPath() {\n            const { size, thickness } = this\n            const radius = size / 2 - 2 // 2px padding\n            const thicknessRadius = radius - thickness\n            const center = size / 2\n\n            return `M${center - radius} ${center}a${radius}  ${radius}  0 1 1 ${2 * radius} 0` +\n                `h${-thickness}` +\n                `a${-thicknessRadius}  ${thicknessRadius}  0 1 0 ${-2 * thicknessRadius} 0` +\n                `a${thicknessRadius}  ${thicknessRadius}  0 1 0 ${2 * thicknessRadius} 0` +\n                `h${thickness}` +\n                `a${radius}  ${radius}  0 1 1 ${-2 * radius} 0z`\n        },\n        trianglePath() {\n            const { size, thickness } = this\n            const radius = size - 4\n            const thicknessRadius = (radius - 2 * thickness) / 2\n\n            return `M0 ${-thicknessRadius}` +\n                `L${cos30 * thicknessRadius} ${sin30 * thicknessRadius}` +\n                `H${-cos30 * thicknessRadius}z`\n        }\n    },\n    watch: {\n        captureMouse(newValue, oldValue) {\n            if (oldValue === false && newValue !== false) {\n                const rect = this.$el.getBoundingClientRect()\n                // Caching offset\n                this.clientOffset.cx = rect.x + rect.width / 2\n                this.clientOffset.cy = rect.y + rect.height / 2\n                this.clientOffset.width = rect.width\n                this.clientOffset.height = rect.height\n            }\n        },\n        value: {\n            deep: true,\n            handler(newColor) {\n                const { hue, saturation, lightness } = newColor\n\n                window.clearTimeout(this.debounce)\n                this.debounce = window.setTimeout(() => {\n                    if (lightness >= 0.03 && lightness <= 0.97 && saturation > 0) {\n                        this.hue = hue\n                    }\n                    this.saturation = saturation\n                    this.lightness = lightness\n                }, 200)\n            }\n        }\n    },\n    methods: {\n        increaseHue(value = 1) {\n            this.hue = (this.hue + value) % 360\n        },\n        decreaseHue(value = 1) {\n            this.hue = (360 + this.hue - value) % 360\n        },\n        increaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation + value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        decreaseSaturation(value = 0.01) {\n            this.saturation = Math.min(1, Math.max(0, this.saturation - value))\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness\n                )\n            )\n        },\n        increaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness + value\n                )\n            )\n        },\n        decreaseLightness(value = 0.01) {\n            this.lightness = Math.min(\n                0.5 + (1 - this.saturation) * 0.5,\n                Math.max(\n                    0.5 - (1 - this.saturation) * 0.5,\n                    this.lightness - value\n                )\n            )\n        },\n        hueKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                case 'ArrowUp':\n                    this.increaseHue()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                case 'ArrowDown':\n                    this.decreaseHue()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseHue(360 - this.hue)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseHue(this.hue)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseHue(60 - this.hue % 60)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseHue(60 + this.hue % 60)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        slKeyPress(event) {\n            let handled = false\n            switch (event.key) {\n                case 'ArrowRight':\n                    this.decreaseLightness()\n                    handled = true\n                    break\n                case 'ArrowUp':\n                    this.increaseSaturation()\n                    handled = true\n                    break\n                case 'ArrowLeft':\n                    this.increaseLightness()\n                    handled = true\n                    break\n                case 'ArrowDown':\n                    this.decreaseSaturation()\n                    handled = true\n                    break\n                case 'Home':\n                    this.increaseLightness(1 - this.lightness)\n                    handled = true\n                    break\n                case 'End':\n                    this.decreaseLightness(this.lightness)\n                    handled = true\n                    break\n                case 'PageUp':\n                    this.increaseSaturation(1 - this.saturation)\n                    handled = true\n                    break\n                case 'PageDown':\n                    this.decreaseSaturation(this.saturation)\n                    handled = true\n                    break\n            }\n            if (handled) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.emitColor()\n            }\n        },\n        clickHue(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.hueCursor.focus()\n        },\n        clickSL(event) {\n            this.startMouseCapture(event)\n            this.trackMouse(event)\n            this.stopMouseCapture(event)\n            this.$refs.slCursor.focus()\n        },\n        trackMouse(event) {\n            if (this.captureMouse === false) {\n                return\n            }\n            event.preventDefault()\n            event.stopPropagation()\n\n            let [mouseX, mouseY] = [0, 0]\n            if (typeof event.touches !== 'undefined' && event.touches.length) {\n                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY]\n            } else {\n                [mouseX, mouseY] = [event.clientX, event.clientY]\n            }\n            const angle = Math.atan2(\n                mouseY - this.clientOffset.cy,\n                mouseX - this.clientOffset.cx\n            )\n\n            if (this.captureType === 'sl') {\n                const d = Math.sqrt(\n                    Math.pow(mouseX - this.clientOffset.cx, 2) +\n                    Math.pow(mouseY - this.clientOffset.cy, 2)\n                )\n                const ratio = this.size / this.clientOffset.width\n                const dx = d * Math.cos(angle - this.hue / 180 * Math.PI) * ratio\n                const dy = d * Math.sin(angle - this.hue / 180 * Math.PI) * ratio\n                const radius = this.internalRadius\n                const saturation = 1 - (Math.min(\n                    radius * sin30,\n                    Math.max(\n                        -radius,\n                        dy\n                    )\n                ) + radius) / (radius + radius * sin30)\n                const lightness = (Math.min(\n                    (radius * cos30) * (1 - saturation),\n                    Math.max(\n                        (-radius * cos30) * (1 - saturation),\n                        dx\n                    )\n                ) + radius * cos30) / (radius * 2 * cos30)\n\n                this.saturation = Math.round(saturation * 1000) / 1000\n                this.lightness = 1 - Math.round(lightness * 1000) / 1000\n            } else {\n                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360\n            }\n            this.emitColor()\n        },\n        startMouseCapture(event) {\n            event.stopPropagation()\n\n            this.captureMouse = true\n            if (event.target.closest('.colorpicker-triangle-slider-sl') !== null) {\n                this.captureType = 'sl'\n            } else {\n                this.captureType = 'hue'\n            }\n        },\n        stopMouseCapture(event) {\n            if (this.captureMouse !== false) {\n                event.preventDefault()\n                event.stopPropagation()\n                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus()\n            }\n            this.captureMouse = false\n        },\n        emitColor() {\n            const { hue, saturation, lightness } = this\n            this.$emit('input', Color.fromHSL(hue, saturation, lightness))\n            window.clearTimeout(this.debounce)\n        }\n    },\n    mounted() {\n        window.addEventListener('mousemove', this.trackMouse)\n        window.addEventListener('touchmove', this.trackMouse, { passive: false })\n        window.addEventListener('mouseup', this.stopMouseCapture)\n        window.addEventListener('touchend', this.stopMouseCapture)\n    },\n    beforeDestroy() {\n        window.removeEventListener('mousemove', this.trackMouse)\n        window.removeEventListener('touchmove', this.trackMouse)\n        window.removeEventListener('mouseup', this.stopMouseCapture)\n        window.removeEventListener('touchend', this.stopMouseCapture)\n\n        clearTimeout(this.debounce)\n    }\n}\n</script>\n",
      "path": "src/components/colorpicker/ColorpickerHSLRepresentationTriangle.vue"
    },
    {
      "type": "registry:component",
      "target": "components/colorpicker/index.js",
      "content": "import Colorpicker from '@/components/colorpicker/Colorpicker'\n\nimport { use, registerComponent } from '@/utils/plugins'\n\nconst Plugin = {\n    install(Vue) {\n        registerComponent(Vue, Colorpicker)\n    }\n}\n\nuse(Plugin)\n\nexport default Plugin\n\nexport {\n    Colorpicker as BColorpicker\n}\n",
      "path": "src/components/colorpicker/index.js"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/Dropdown.vue",
      "content": "<template>\n    <div\n        class=\"dropdown dropdown-menu-animation\"\n        ref=\"dropdown\"\n        :class=\"rootClasses\"\n        @mouseleave=\"isHoverable = false\"\n    >\n        <div\n            v-if=\"!inline\"\n            :tabindex=\"disabled ? false : triggerTabindex\"\n            ref=\"trigger\"\n            class=\"dropdown-trigger\"\n            @click=\"onClick\"\n            @contextmenu.prevent=\"onContextMenu\"\n            @mouseenter=\"onHover\"\n            @focus.capture=\"onFocus\"\n            @touchstart=\"onTouchStart\"\n            @touchmove=\"onTouchMove\"\n            @touchend=\"onTouchEnd\"\n            aria-haspopup=\"true\">\n            <slot name=\"trigger\" :active=\"isActive\"/>\n        </div>\n\n        <transition :name=\"animation\">\n            <div\n                v-if=\"isMobileModal\"\n                v-show=\"isActive\"\n                class=\"background\"\n                :aria-hidden=\"!isActive\"\n            />\n        </transition>\n        <transition :name=\"animation\">\n            <div\n                v-show=\"(!disabled && (isActive || isHoverable)) || inline\"\n                ref=\"dropdownMenu\"\n                class=\"dropdown-menu\"\n                :style=\"style\"\n                :aria-hidden=\"!isActive\"\n                v-trap-focus=\"trapFocus\">\n                <div\n                    class=\"dropdown-content\"\n                    :role=\"ariaRole\"\n                    :aria-modal=\"!inline\"\n                    :style=\"contentStyle\">\n                    <slot/>\n                </div>\n            </div>\n        </transition>\n    </div>\n</template>\n\n<script>\nimport trapFocus from '@/directives/trapFocus'\nimport config from '@/utils/config'\nimport { removeElement, createAbsoluteElement, isCustomElement, toCssWidth } from '@/utils/helpers'\nimport ProviderParentMixin from '@/utils/ProviderParentMixin'\n\nconst DEFAULT_CLOSE_OPTIONS = ['escape', 'outside']\n\nexport default {\n    name: 'BDropdown',\n    directives: {\n        trapFocus\n    },\n    mixins: [ProviderParentMixin('dropdown')],\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function],\n            default: null\n        },\n        disabled: Boolean,\n        inline: Boolean,\n        scrollable: Boolean,\n        maxHeight: {\n            type: [String, Number],\n            default: 200\n        },\n        position: {\n            type: String,\n            validator(value) {\n                return [\n                    'is-top-right',\n                    'is-top-left',\n                    'is-bottom-left',\n                    'is-bottom-right'\n                ].indexOf(value) > -1\n            }\n        },\n        triggers: {\n            type: Array,\n            default: () => ['click']\n        },\n        mobileModal: {\n            type: Boolean,\n            default: () => {\n                return config.defaultDropdownMobileModal\n            }\n        },\n        ariaRole: {\n            type: String,\n            validator(value) {\n                return [\n                    'menu',\n                    'list',\n                    'dialog'\n                ].indexOf(value) > -1\n            },\n            default: null\n        },\n        animation: {\n            type: String,\n            default: 'fade'\n        },\n        multiple: Boolean,\n        trapFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultTrapFocus\n            }\n        },\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        canClose: {\n            type: [Array, Boolean],\n            default: true\n        },\n        expanded: Boolean,\n        appendToBody: Boolean,\n        appendToBodyCopyParent: Boolean,\n        triggerTabindex: {\n            type: Number,\n            default: 0\n        }\n    },\n    data() {\n        return {\n            selected: this.value,\n            style: {},\n            isActive: false,\n            isHoverable: false,\n            maybeTap: false,\n            isTouchEnabled: false,\n            _bodyEl: undefined, // Used to append to body\n            timeOutID: null,\n            timeOutID2: null\n        }\n    },\n    computed: {\n        rootClasses() {\n            return [this.position, {\n                'is-disabled': this.disabled,\n                'is-hoverable': this.hoverable,\n                'is-inline': this.inline,\n                'is-active': this.isActive || this.inline,\n                'is-mobile-modal': this.isMobileModal,\n                'is-expanded': this.expanded,\n                'is-touch-enabled': this.isTouchEnabled\n            }]\n        },\n        isMobileModal() {\n            return this.mobileModal && !this.inline\n        },\n        cancelOptions() {\n            return typeof this.canClose === 'boolean'\n                ? this.canClose\n                    ? DEFAULT_CLOSE_OPTIONS\n                    : []\n                : this.canClose\n        },\n        contentStyle() {\n            return {\n                maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,\n                overflow: this.scrollable ? 'auto' : null\n            }\n        },\n        hoverable() {\n            return this.triggers.indexOf('hover') >= 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed set the new selected item.\n        */\n        value(value) {\n            this.selected = value\n        },\n\n        /**\n        * Emit event when isActive value is changed.\n        *\n        * Also resets `isTouchEnabled` when it turns inactive.\n        */\n        isActive(value) {\n            this.$emit('active-change', value)\n            if (!value) {\n                // delays to reset the touch enabled flag until the dropdown\n                // menu disappears to avoid glitches\n                // also takes care of chattering, e.g., repeated quick taps,\n                // otherwise the flag may become inconsistent with the actual\n                // state of the dropdown menu\n                this.timeOutID = setTimeout(() => {\n                    if (!this.isActive) {\n                        this.isTouchEnabled = false\n                    }\n                }, 250)\n            }\n            this.handleScroll()\n            if (this.appendToBody) {\n                this.$nextTick(() => {\n                    this.updateAppendToBody()\n                })\n            }\n        },\n\n        isHoverable(value) {\n            if (this.hoverable) {\n                this.$emit('active-change', value)\n            }\n        }\n    },\n    methods: {\n        handleScroll() {\n            if (typeof window === 'undefined') return\n\n            if (this.isMobileModal) {\n                if (this.isActive) {\n                    document.documentElement.classList.add('is-clipped-touch')\n                } else {\n                    document.documentElement.classList.remove('is-clipped-touch')\n                }\n            }\n        },\n\n        /**\n         * Click listener from DropdownItem.\n         *   1. Set new selected item.\n         *   2. Emit input event to update the user v-model.\n         *   3. Close the dropdown.\n         */\n        selectItem(value) {\n            if (this.multiple) {\n                if (this.selected) {\n                    if (this.selected.indexOf(value) === -1) {\n                        // Add value\n                        this.selected = [...this.selected, value]\n                    } else {\n                        // Remove value\n                        this.selected = this.selected.filter((val) => val !== value)\n                    }\n                } else {\n                    this.selected = [value]\n                }\n                this.$emit('change', this.selected)\n            } else {\n                if (this.selected !== value) {\n                    this.selected = value\n                    this.$emit('change', this.selected)\n                }\n            }\n            this.$emit('input', this.selected)\n            if (!this.multiple) {\n                this.isActive = !this.closeOnClick\n                if (this.hoverable && this.closeOnClick) {\n                    this.isHoverable = false\n                }\n            }\n        },\n\n        /**\n        * White-listed items to not close when clicked.\n        */\n        isInWhiteList(el) {\n            if (el === this.$refs.dropdownMenu) return true\n            if (el === this.$refs.trigger) return true\n            // All chidren from dropdown\n            if (this.$refs.dropdownMenu !== undefined) {\n                const children = this.$refs.dropdownMenu.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            // All children from trigger\n            if (this.$refs.trigger !== undefined) {\n                const children = this.$refs.trigger.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            return false\n        },\n\n        /**\n        * Close dropdown if clicked outside.\n        */\n        clickedOutside(event) {\n            if (this.cancelOptions.indexOf('outside') < 0) return\n            if (this.inline) return\n\n            const target = isCustomElement(this) ? event.composedPath()[0] : event.target\n            if (!this.isInWhiteList(target)) this.isActive = false\n        },\n\n        /**\n         * Keypress event that is bound to the document\n         */\n        keyPress({ key }) {\n            if (this.isActive && (key === 'Escape' || key === 'Esc')) {\n                if (this.cancelOptions.indexOf('escape') < 0) return\n                this.isActive = false\n            }\n        },\n\n        onClick() {\n            // hover precedes\n            if (this.triggers.indexOf('hover') !== -1) return\n            if (this.triggers.indexOf('click') < 0) return\n            this.toggle()\n        },\n        onContextMenu() {\n            if (this.triggers.indexOf('contextmenu') < 0) return\n            this.toggle()\n        },\n        onHover() {\n            if (this.triggers.indexOf('hover') < 0) return\n            // touch precedes\n            if (this.isTouchEnabled) return\n            this.isHoverable = true\n        },\n        // takes care of touch-enabled devices\n        // - does nothing if hover trigger is disabled\n        // - suppresses hover trigger by setting isTouchEnabled\n        // - handles only a tap; i.e., touchstart on the trigger immediately\n        //   folowed by touchend\n        onTouchStart() {\n            this.maybeTap = true\n        },\n        onTouchMove() {\n            this.maybeTap = false\n        },\n        onTouchEnd(e) {\n            if (this.triggers.indexOf('hover') === -1) return\n            if (!this.maybeTap) return\n            // tap on dropdown contents may happen without preventDefault\n            e.preventDefault()\n            this.maybeTap = false\n            this.isTouchEnabled = true\n            this.toggle()\n        },\n        onFocus() {\n            if (this.triggers.indexOf('focus') < 0) return\n            this.toggle()\n        },\n\n        /**\n        * Toggle dropdown if it's not disabled.\n        */\n        toggle() {\n            if (this.disabled) return\n\n            if (!this.isActive) {\n                // if not active, toggle after clickOutside event\n                // this fixes toggling programmatic\n                this.$nextTick(() => {\n                    const value = !this.isActive\n                    this.isActive = value\n                    // Vue 2.6.x ???\n                    this.timeOutID2 = setTimeout(() => (this.isActive = value))\n                })\n            } else {\n                this.isActive = !this.isActive\n            }\n        },\n\n        updateAppendToBody() {\n            const dropdown = this.$refs.dropdown\n            const dropdownMenu = this.$refs.dropdownMenu\n            const trigger = this.$refs.trigger\n            if (dropdownMenu && trigger) {\n                // update wrapper dropdown\n                const dropdownWrapper = this.$data._bodyEl.children[0]\n                dropdownWrapper.classList.forEach((item) => dropdownWrapper.classList.remove(item))\n                dropdownWrapper.classList.add('dropdown')\n                dropdownWrapper.classList.add('dropdown-menu-animation')\n                if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {\n                    dropdownWrapper.classList.add(this.$vnode.data.staticClass)\n                }\n                this.rootClasses.forEach((item) => {\n                    // skip position prop\n                    if (item && typeof item === 'object') {\n                        for (let key in item) {\n                            if (item[key]) {\n                                dropdownWrapper.classList.add(key)\n                            }\n                        }\n                    }\n                })\n                if (this.appendToBodyCopyParent) {\n                    const parentNode = this.$refs.dropdown.parentNode\n                    const parent = this.$data._bodyEl\n                    parent.classList.forEach((item) => parent.classList.remove(item))\n                    parentNode.classList.forEach((item) => {\n                        parent.classList.add(item)\n                    })\n                }\n                const rect = trigger.getBoundingClientRect()\n                let top = rect.top + window.scrollY\n                let left = rect.left + window.scrollX\n                if (!this.position || this.position.indexOf('bottom') >= 0) {\n                    top += trigger.clientHeight\n                } else {\n                    top -= dropdownMenu.clientHeight\n                }\n                if (this.position && this.position.indexOf('left') >= 0) {\n                    left -= (dropdownMenu.clientWidth - trigger.clientWidth)\n                }\n                this.style = {\n                    position: 'absolute',\n                    top: `${top}px`,\n                    left: `${left}px`,\n                    zIndex: '99',\n                    width: this.expanded ? `${dropdown.offsetWidth}px` : undefined\n                }\n            }\n        }\n    },\n    mounted() {\n        if (this.appendToBody) {\n            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu)\n            this.updateAppendToBody()\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('click', this.clickedOutside)\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('click', this.clickedOutside)\n            document.removeEventListener('keyup', this.keyPress)\n        }\n        if (this.appendToBody) {\n            removeElement(this.$data._bodyEl)\n        }\n        clearTimeout(this.timeOutID)\n        clearTimeout(this.timeOutID2)\n    }\n}\n</script>\n",
      "path": "src/components/dropdown/Dropdown.vue"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/DropdownItem.vue",
      "content": "<template>\n    <hr v-if=\"separator\" class=\"dropdown-divider\">\n    <a\n        v-else-if=\"!custom && !hasLink\"\n        class=\"dropdown-item\"\n        :class=\"anchorClasses\"\n        @click=\"selectItem\"\n        :role=\"ariaRoleItem\"\n        :tabindex=\"isFocusable ? 0 : null\">\n        <slot/>\n    </a>\n    <div\n        v-else\n        :class=\"itemClasses\"\n        @click=\"selectItem\"\n        :role=\"ariaRoleItem\"\n        :tabindex=\"isFocusable ? 0 : null\">\n        <slot/>\n    </div>\n</template>\n\n<script>\nimport InjectedChildMixin from '@/utils/InjectedChildMixin'\n\nexport default {\n    name: 'BDropdownItem',\n    mixins: [InjectedChildMixin('dropdown')],\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function],\n            default: null\n        },\n        separator: Boolean,\n        disabled: Boolean,\n        custom: Boolean,\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        paddingless: Boolean,\n        hasLink: Boolean,\n        ariaRole: {\n            type: String,\n            default: ''\n        }\n    },\n    computed: {\n        anchorClasses() {\n            return {\n                'is-disabled': this.parent.disabled || this.disabled,\n                'is-paddingless': this.paddingless,\n                'is-active': this.isActive\n            }\n        },\n        itemClasses() {\n            return {\n                'dropdown-item': !this.hasLink,\n                'is-disabled': this.disabled,\n                'is-paddingless': this.paddingless,\n                'is-active': this.isActive,\n                'has-link': this.hasLink\n            }\n        },\n        ariaRoleItem() {\n            return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null\n        },\n        isClickable() {\n            return !this.parent.disabled && !this.separator && !this.disabled && !this.custom\n        },\n        isActive() {\n            if (this.parent.selected === null) return false\n            if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0\n            return this.value === this.parent.selected\n        },\n        isFocusable() {\n            return this.hasLink ? false : this.focusable\n        }\n    },\n    methods: {\n        /**\n        * Click listener, select the item.\n        */\n        selectItem() {\n            if (!this.isClickable) return\n\n            this.parent.selectItem(this.value)\n            this.$emit('click')\n        }\n    }\n}\n</script>\n",
      "path": "src/components/dropdown/DropdownItem.vue"
    },
    {
      "type": "registry:component",
      "target": "components/field/Field.vue",
      "content": "<template>\n    <div class=\"field\" :class=\"rootClasses\">\n        <div\n            v-if=\"horizontal\"\n            class=\"field-label\"\n            :class=\"[customClass, fieldLabelSize]\">\n            <label\n                v-if=\"hasLabel\"\n                :for=\"labelFor\"\n                :class=\"customClass\"\n                class=\"label\" >\n                <slot v-if=\"$slots.label\" name=\"label\"/>\n                <template v-else>{{ label }}</template>\n            </label>\n        </div>\n        <template v-else>\n            <label\n                v-if=\"hasLabel\"\n                :for=\"labelFor\"\n                :class=\"customClass\"\n                class=\"label\">\n                <slot v-if=\"$slots.label\" name=\"label\"/>\n                <template v-else>{{ label }}</template>\n            </label>\n        </template>\n        <b-field-body\n            v-if=\"horizontal\"\n            :message=\"newMessage ? formattedMessage : ''\"\n            :type=\"newType\">\n            <slot/>\n        </b-field-body>\n        <div v-else-if=\"hasInnerField\" class=\"field-body\">\n            <b-field\n                :addons=\"false\"\n                :type=\"type\"\n                :class=\"innerFieldClasses\">\n                <slot/>\n            </b-field>\n        </div>\n        <template v-else>\n            <slot/>\n        </template>\n        <p\n            v-if=\"hasMessage && !horizontal\"\n            class=\"help\"\n            :class=\"newType\"\n        >\n            <slot\n                v-if=\"$slots.message\"\n                name=\"message\"\n                :messages=\"formattedMessage\"\n            />\n            <template v-else>\n                <template v-for=\"(mess, i) in formattedMessage\">\n                    {{ mess }}\n                    <br :key=\"i\" v-if=\"(i + 1) < formattedMessage.length\">\n                </template>\n            </template>\n        </p>\n    </div>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport FieldBody from '@/components/field/FieldBody'\n\nexport default {\n    name: 'BField',\n    components: {\n        [FieldBody.name]: FieldBody\n    },\n    provide() {\n        return {\n            'BField': this\n        }\n    },\n    inject: {\n        parent: {\n            from: 'BField',\n            default: false\n        }\n    }, // Used internally only when using Field in Field\n    props: {\n        type: [String, Object],\n        label: String,\n        labelFor: String,\n        message: [String, Array, Object],\n        grouped: Boolean,\n        groupMultiline: Boolean,\n        position: String,\n        expanded: Boolean,\n        horizontal: Boolean,\n        addons: {\n            type: Boolean,\n            default: true\n        },\n        customClass: String,\n        labelPosition: {\n            type: String,\n            default: () => { return config.defaultFieldLabelPosition }\n        }\n    },\n    data() {\n        return {\n            newType: this.type,\n            newMessage: this.message,\n            fieldLabelSize: null,\n            _isField: true // Used internally by Input and Select\n        }\n    },\n    computed: {\n        rootClasses() {\n            return [{\n                'is-expanded': this.expanded,\n                'is-horizontal': this.horizontal,\n                'is-floating-in-label': this.hasLabel && !this.horizontal &&\n                    this.labelPosition === 'inside',\n                'is-floating-label': this.hasLabel && !this.horizontal &&\n                    this.labelPosition === 'on-border'\n            },\n            this.numberInputClasses]\n        },\n        innerFieldClasses() {\n            return [\n                this.fieldType(),\n                this.newPosition,\n                {\n                    'is-grouped-multiline': this.groupMultiline\n                }\n            ]\n        },\n        hasInnerField() {\n            return this.grouped || this.groupMultiline || this.hasAddons()\n        },\n        /**\n        * Correct Bulma class for the side of the addon or group.\n        *\n        * This is not kept like the others (is-small, etc.),\n        * because since 'has-addons' is set automatically it\n        * doesn't make sense to teach users what addons are exactly.\n        */\n        newPosition() {\n            if (this.position === undefined) return\n\n            const position = this.position.split('-')\n            if (position.length < 1) return\n\n            const prefix = this.grouped\n                ? 'is-grouped-'\n                : 'has-addons-'\n\n            if (this.position) return prefix + position[1]\n        },\n        /**\n        * Formatted message in case it's an array\n        * (each element is separated by <br> tag)\n        */\n        formattedMessage() {\n            if (this.parent && this.parent.hasInnerField) {\n                return '' // Message will be displayed in parent field\n            }\n            if (typeof this.newMessage === 'string') {\n                return [this.newMessage]\n            }\n            let messages = []\n            if (Array.isArray(this.newMessage)) {\n                this.newMessage.forEach((message) => {\n                    if (typeof message === 'string') {\n                        messages.push(message)\n                    } else {\n                        for (let key in message) {\n                            if (message[key]) {\n                                messages.push(key)\n                            }\n                        }\n                    }\n                })\n            } else {\n                for (let key in this.newMessage) {\n                    if (this.newMessage[key]) {\n                        messages.push(key)\n                    }\n                }\n            }\n            return messages.filter((m) => { if (m) return m })\n        },\n        hasLabel() {\n            return this.label || this.$slots.label\n        },\n        hasMessage() {\n            return ((!this.parent || !this.parent.hasInnerField) && this.newMessage) ||\n                this.$slots.message\n        },\n        numberInputClasses() {\n            if (this.$slots.default) {\n                const numberinput = this.$slots.default.filter((node) => node.tag && node.tag.toLowerCase().indexOf('numberinput') >= 0)[0]\n                if (numberinput) {\n                    const classes = ['has-numberinput']\n                    const controlsPosition = numberinput.componentOptions.propsData.controlsPosition\n                    const size = numberinput.componentOptions.propsData.size\n                    if (controlsPosition) {\n                        classes.push(`has-numberinput-${controlsPosition}`)\n                    }\n                    if (size) {\n                        classes.push(`has-numberinput-${size}`)\n                    }\n                    return classes\n                }\n            }\n            return null\n        }\n    },\n    watch: {\n        /**\n        * Set internal type when prop change.\n        */\n        type(value) {\n            this.newType = value\n        },\n\n        /**\n        * Set internal message when prop change.\n        */\n        message(value) {\n            // we deep comparison here becase an innner Field of another Field\n            // receives the message as a brand new array every time, so simple\n            // identity check won't work and will end up with infinite\n            // recursions\n            // https://github.com/buefy/buefy/issues/4018#issuecomment-1985026234\n            if (JSON.stringify(value) !== JSON.stringify(this.newMessage)) {\n                this.newMessage = value\n            }\n        },\n\n        /**\n        * Set parent message if we use Field in Field.\n        */\n        newMessage(value) {\n            if (this.parent && this.parent.hasInnerField) {\n                if (!this.parent.type) {\n                    this.parent.newType = this.newType\n                }\n                if (!this.parent.message) {\n                    this.parent.newMessage = value\n                }\n            }\n        }\n    },\n    methods: {\n        /**\n        * Field has addons if there are more than one slot\n        * (element / component) in the Field.\n        * Or is grouped when prop is set.\n        * Is a method to be called when component re-render.\n        */\n        fieldType() {\n            if (this.grouped) return 'is-grouped'\n            if (this.hasAddons()) return 'has-addons'\n        },\n        hasAddons() {\n            let renderedNode = 0\n            if (this.$slots.default) {\n                renderedNode = this.$slots.default.reduce((i, node) => node.tag ? i + 1 : i, 0)\n            }\n            return (\n                renderedNode > 1 &&\n                this.addons &&\n                !this.horizontal\n            )\n        }\n    },\n    mounted() {\n        if (this.horizontal) {\n            // Bulma docs: .is-normal for any .input or .button\n            const elements = this.$el.querySelectorAll('.input, .select, .button, .textarea, .b-slider')\n            if (elements.length > 0) {\n                this.fieldLabelSize = 'is-normal'\n            }\n        }\n    }\n}\n\n</script>\n",
      "path": "src/components/field/Field.vue"
    },
    {
      "type": "registry:component",
      "target": "components/field/FieldBody.vue",
      "content": "<script>\nexport default {\n    name: 'BFieldBody',\n    props: {\n        message: {\n            type: [String, Array]\n        },\n        type: {\n            type: [String, Object]\n        }\n    },\n    render(createElement) {\n        let first = true\n        return createElement('div', { attrs: { 'class': 'field-body' } }, this.$slots.default.map((element) => {\n            // skip returns and comments\n            if (!element.tag) {\n                return element\n            }\n            let message\n            if (first) {\n                message = this.message\n                first = false\n            }\n            return createElement('b-field', { attrs: { type: this.type, message } }, [element])\n        }))\n    }\n}\n</script>\n",
      "path": "src/components/field/FieldBody.vue"
    },
    {
      "type": "registry:component",
      "target": "components/icon/Icon.vue",
      "content": "<template>\n    <span class=\"icon\" :class=\"[newType, size]\">\n        <i\n            v-if=\"!useIconComponent\"\n            :class=\"[newPack, newIcon, newCustomSize, customClass]\"/>\n\n        <component\n            v-else\n            :is=\"useIconComponent\"\n            :icon=\"[newPack, newIcon]\"\n            :size=\"newCustomSize\"\n            :class=\"[customClass]\"/>\n    </span>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport getIcons from '@/utils/icons'\n\nexport default {\n    name: 'BIcon',\n    props: {\n        type: [String, Object],\n        component: String,\n        pack: String,\n        icon: String,\n        size: String,\n        customSize: String,\n        customClass: String,\n        both: Boolean // This is used internally to show both MDI and FA icon\n    },\n    computed: {\n        iconConfig() {\n            let allIcons = getIcons()\n            return allIcons[this.newPack]\n        },\n        iconPrefix() {\n            if (this.iconConfig && this.iconConfig.iconPrefix) {\n                return this.iconConfig.iconPrefix\n            }\n            return ''\n        },\n        /**\n        * Internal icon name based on the pack.\n        * If pack is 'fa', gets the equivalent FA icon name of the MDI,\n        * internal icons are always MDI.\n        */\n        newIcon() {\n            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`\n        },\n        newPack() {\n            return this.pack || config.defaultIconPack\n        },\n        newType() {\n            if (!this.type) return\n\n            let splitType = []\n            if (typeof this.type === 'string') {\n                splitType = this.type.split('-')\n            } else {\n                for (let key in this.type) {\n                    if (this.type[key]) {\n                        splitType = key.split('-')\n                        break\n                    }\n                }\n            }\n            if (splitType.length <= 1) return\n\n            const [, ...type] = splitType\n            return `has-text-${type.join('-')}`\n        },\n        newCustomSize() {\n            return this.customSize || this.customSizeByPack\n        },\n        customSizeByPack() {\n            if (this.iconConfig && this.iconConfig.sizes) {\n                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {\n                    return this.iconConfig.sizes[this.size]\n                } else if (this.iconConfig.sizes.default) {\n                    return this.iconConfig.sizes.default\n                }\n            }\n            return null\n        },\n        useIconComponent() {\n            return this.component || config.defaultIconComponent\n        }\n    },\n    methods: {\n        /**\n        * Equivalent icon name of the MDI.\n        */\n        getEquivalentIconOf(value) {\n            // Only transform the class if the both prop is set to true\n            if (!this.both) {\n                return value\n            }\n\n            if (this.iconConfig &&\n                this.iconConfig.internalIcons &&\n                this.iconConfig.internalIcons[value]) {\n                return this.iconConfig.internalIcons[value]\n            }\n            return value\n        }\n    }\n}\n</script>\n",
      "path": "src/components/icon/Icon.vue"
    },
    {
      "type": "registry:component",
      "target": "components/input/Input.vue",
      "content": "<template>\n    <div\n        class=\"control\"\n        :class=\"rootClasses\"\n    >\n        <input\n            v-if=\"type !== 'textarea'\"\n            ref=\"input\"\n            class=\"input\"\n            :class=\"[inputClasses, customClass]\"\n            :type=\"newType\"\n            :autocomplete=\"newAutocomplete\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\">\n\n        <textarea\n            v-else\n            ref=\"textarea\"\n            class=\"textarea\"\n            :class=\"[inputClasses, customClass]\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\"/>\n\n        <b-icon\n            v-if=\"icon\"\n            class=\"is-left\"\n            :class=\"{'is-clickable': iconClickable}\"\n            :icon=\"icon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            @click.native=\"iconClick('icon-click', $event)\"/>\n\n        <b-icon\n            v-if=\"!loading && hasIconRight\"\n            class=\"is-right\"\n            :class=\"{ 'is-clickable': passwordReveal || iconRightClickable }\"\n            :icon=\"rightIcon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            :type=\"rightIconType\"\n            both\n            @click.native=\"rightIconClick\"/>\n\n        <small\n            v-if=\"maxlength && hasCounter && type !== 'number'\"\n            class=\"help counter\"\n            :class=\"{ 'is-invisible': !isFocused }\">\n            {{ valueLength }} / {{ maxlength }}\n        </small>\n    </div>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport config from '@/utils/config'\nimport FormElementMixin from '@/utils/FormElementMixin'\n\nexport default {\n    name: 'BInput',\n    components: {\n        [Icon.name]: Icon\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: [Number, String],\n        type: {\n            type: String,\n            default: 'text'\n        },\n        lazy: {\n            type: Boolean,\n            default: false\n        },\n        passwordReveal: Boolean,\n        iconClickable: Boolean,\n        hasCounter: {\n            type: Boolean,\n            default: () => config.defaultInputHasCounter\n        },\n        customClass: {\n            type: String,\n            default: ''\n        },\n        iconRight: String,\n        iconRightClickable: Boolean,\n        iconRightType: String\n    },\n    data() {\n        return {\n            newValue: this.value,\n            newType: this.type,\n            newAutocomplete: this.autocomplete || config.defaultInputAutocomplete,\n            isPasswordVisible: false,\n            _elementRef: this.type === 'textarea'\n                ? 'textarea'\n                : 'input'\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.newValue\n            },\n            set(value) {\n                this.newValue = value\n                this.$emit('input', value)\n            }\n        },\n        rootClasses() {\n            return [\n                this.iconPosition,\n                this.size,\n                {\n                    'is-expanded': this.expanded,\n                    'is-loading': this.loading,\n                    'is-clearfix': !this.hasMessage\n                }\n            ]\n        },\n        inputClasses() {\n            return [\n                this.statusType,\n                this.size,\n                { 'is-rounded': this.rounded }\n            ]\n        },\n        hasIconRight() {\n            return this.passwordReveal ||\n                this.loading || (this.statusIcon && this.statusTypeIcon) || this.iconRight\n        },\n        rightIcon() {\n            if (this.passwordReveal) {\n                return this.passwordVisibleIcon\n            } else if (this.iconRight) {\n                return this.iconRight\n            }\n            return this.statusTypeIcon\n        },\n        rightIconType() {\n            if (this.passwordReveal) {\n                return 'is-primary'\n            } else if (this.iconRight) {\n                return this.iconRightType || null\n            }\n            return this.statusType\n        },\n\n        /**\n        * Position of the icon or if it's both sides.\n        */\n        iconPosition() {\n            let iconClasses = ''\n\n            if (this.icon) {\n                iconClasses += 'has-icons-left '\n            }\n\n            if (this.hasIconRight) {\n                iconClasses += 'has-icons-right'\n            }\n\n            return iconClasses\n        },\n\n        /**\n        * Icon name (MDI) based on the type.\n        */\n        statusTypeIcon() {\n            switch (this.statusType) {\n                case 'is-success': return 'check'\n                case 'is-danger': return 'alert-circle'\n                case 'is-info': return 'information'\n                case 'is-warning': return 'alert'\n            }\n        },\n\n        /**\n        * Check if have any message prop from parent if it's a Field.\n        */\n        hasMessage() {\n            return !!this.statusMessage\n        },\n\n        /**\n        * Current password-reveal icon name.\n        */\n        passwordVisibleIcon() {\n            return !this.isPasswordVisible ? 'eye' : 'eye-off'\n        },\n        /**\n        * Get value length\n        */\n        valueLength() {\n            if (typeof this.computedValue === 'string') {\n                return Array.from(this.computedValue).length\n            } else if (typeof this.computedValue === 'number') {\n                return this.computedValue.toString().length\n            }\n            return 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed:\n        *   1. Set internal value.\n        *   2. Validate it if the value came from outside;\n        *      i.e., not equal to computedValue\n        */\n        value(value) {\n            const fromOutside = this.computedValue != value // eslint-disable-line eqeqeq\n            this.newValue = value\n            if (fromOutside) {\n                // validation must wait for DOM updated\n                this.$nextTick(() => {\n                    !this.isValid && this.checkHtml5Validity()\n                })\n            }\n        },\n        type(type) {\n            this.newType = type\n        }\n    },\n    methods: {\n        /**\n        * Toggle the visibility of a password-reveal input\n        * by changing the type and focus the input right away.\n        */\n        togglePasswordVisibility() {\n            this.isPasswordVisible = !this.isPasswordVisible\n            this.newType = this.isPasswordVisible ? 'text' : 'password'\n\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        iconClick(emit, event) {\n            this.$emit(emit, event)\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        rightIconClick(event) {\n            if (this.passwordReveal) {\n                this.togglePasswordVisibility()\n            } else if (this.iconRightClickable) {\n                this.iconClick('icon-right-click', event)\n            }\n        },\n\n        onInput(event) {\n            if (!this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        onChange(event) {\n            if (this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        updateValue(value) {\n            this.computedValue = value\n            !this.isValid && this.checkHtml5Validity()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/input/Input.vue"
    },
    {
      "type": "registry:component",
      "target": "components/select/Select.vue",
      "content": "<template>\n    <div\n        class=\"control\"\n        :class=\"{ 'is-expanded': expanded, 'has-icons-left': icon }\">\n        <span class=\"select\" :class=\"spanClasses\">\n\n            <select\n                v-model=\"computedValue\"\n                ref=\"select\"\n                :multiple=\"multiple\"\n                :size=\"nativeSize\"\n                v-bind=\"$attrs\"\n                @blur=\"$emit('blur', $event) && checkHtml5Validity()\"\n                @focus=\"$emit('focus', $event)\">\n\n                <template v-if=\"placeholder\">\n                    <option\n                        v-if=\"computedValue == null\"\n                        :value=\"null\"\n                        disabled\n                        hidden>\n                        {{ placeholder }}\n                    </option>\n                </template>\n\n                <slot/>\n\n            </select>\n        </span>\n\n        <b-icon\n            v-if=\"icon\"\n            class=\"is-left\"\n            :icon=\"icon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"/>\n    </div>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport FormElementMixin from '@/utils/FormElementMixin'\n\nexport default {\n    name: 'BSelect',\n    components: {\n        [Icon.name]: Icon\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function, Date],\n            default: null\n        },\n        placeholder: String,\n        multiple: Boolean,\n        nativeSize: [String, Number]\n    },\n    data() {\n        return {\n            selected: this.value,\n            _elementRef: 'select'\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.selected\n            },\n            set(value) {\n                this.selected = value\n                this.$emit('input', value)\n                !this.isValid && this.checkHtml5Validity()\n            }\n        },\n        spanClasses() {\n            return [this.size, this.statusType, {\n                'is-fullwidth': this.expanded,\n                'is-loading': this.loading,\n                'is-multiple': this.multiple,\n                'is-rounded': this.rounded,\n                'is-empty': this.selected === null\n            }]\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed:\n        *   1. Set the selected option.\n        *   2. If it's invalid, validate again.\n        */\n        value(value) {\n            this.selected = value\n            !this.isValid && this.checkHtml5Validity()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/select/Select.vue"
    },
    {
      "type": "registry:component",
      "target": "components/tooltip/Tooltip.vue",
      "content": "<template>\n    <div ref=\"tooltip\" :class=\"rootClasses\">\n        <transition :name=\"newAnimation\">\n            <div\n                v-show=\"active && (isActive || always)\"\n                ref=\"content\"\n                :class=\"['tooltip-content', contentClass]\">\n                <template v-if=\"label\">{{ label }}</template>\n                <template v-else-if=\"$slots.content\">\n                    <slot name=\"content\" />\n                </template>\n            </div>\n        </transition>\n        <div\n            ref=\"trigger\"\n            class=\"tooltip-trigger\"\n            :style=\"triggerStyle\"\n            @click=\"onClick\"\n            @contextmenu=\"onContextMenu\"\n            @mouseenter=\"onHover\"\n            @focus.capture=\"onFocus\"\n            @blur.capture=\"close\"\n            @mouseleave=\"close\">\n            <slot ref=\"slot\" />\n        </div>\n    </div>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport { createAbsoluteElement, removeElement } from '@/utils/helpers'\n\nexport default {\n    name: 'BTooltip',\n    props: {\n        active: {\n            type: Boolean,\n            default: true\n        },\n        type: {\n            type: String,\n            default: () => config.defaultTooltipType\n        },\n        label: String,\n        delay: {\n            type: Number,\n            default: () => config.defaultTooltipDelay\n        },\n        closeDelay: {\n            type: Number,\n            default: () => config.defaultTooltipCloseDelay\n        },\n        position: {\n            type: String,\n            default: 'is-top',\n            validator(value) {\n                return [\n                    'is-top',\n                    'is-bottom',\n                    'is-left',\n                    'is-right'\n                ].indexOf(value) > -1\n            }\n        },\n        triggers: {\n            type: Array,\n            default: () => ['hover']\n        },\n        always: Boolean,\n        square: Boolean,\n        dashed: Boolean,\n        multilined: Boolean,\n        size: {\n            type: String,\n            default: 'is-medium'\n        },\n        appendToBody: Boolean,\n        animated: {\n            type: Boolean,\n            default: true\n        },\n        animation: {\n            type: String,\n            default: 'fade'\n        },\n        contentClass: String,\n        autoClose: {\n            type: [Array, Boolean],\n            default: true\n        }\n    },\n    data() {\n        return {\n            isActive: false,\n            triggerStyle: {},\n            timer: null,\n            _bodyEl: undefined, // Used to append to body\n            resizeObserver: undefined,\n            resizeListener: undefined,\n            timeOutID: null\n        }\n    },\n    computed: {\n        rootClasses() {\n            return ['b-tooltip', this.type, this.position, this.size, {\n                'is-square': this.square,\n                'is-always': this.always,\n                'is-multiline': this.multilined,\n                'is-dashed': this.dashed\n            }]\n        },\n        newAnimation() {\n            return this.animated ? this.animation : undefined\n        }\n    },\n    watch: {\n        isActive() {\n            this.$emit(this.isActive ? 'open' : 'close')\n            if (this.appendToBody) {\n                this.updateAppendToBody()\n            }\n        }\n    },\n    methods: {\n        updateAppendToBody() {\n            const tooltip = this.$refs.tooltip\n            const trigger = this.$refs.trigger\n            if (tooltip && trigger) {\n                // update wrapper tooltip\n                const tooltipEl = this.$data._bodyEl.children[0]\n                tooltipEl.classList.forEach((item) => tooltipEl.classList.remove(item))\n                if (\n                    this.$vnode &&\n                    this.$vnode.data &&\n                    this.$vnode.data.staticClass\n                ) {\n                    tooltipEl.classList.add(this.$vnode.data.staticClass)\n                }\n                this.rootClasses.forEach((item) => {\n                    if (typeof item === 'object') {\n                        for (let key in item) {\n                            if (item[key]) {\n                                tooltipEl.classList.add(key)\n                            }\n                        }\n                    } else {\n                        tooltipEl.classList.add(item)\n                    }\n                })\n\n                const rect = trigger.getBoundingClientRect()\n\n                const top = rect.top + window.scrollY\n                const left = rect.left + window.scrollX\n\n                // `tooltipEl` will be placed relative to `wrapper`\n                // because `wrapper` should create a stacking context\n                // as its z-index is non-auto\n                tooltipEl.style.position = 'absolute'\n                switch (this.position) {\n                    case 'is-top':\n                        tooltipEl.style.width = `${trigger.clientWidth}px`\n                        tooltipEl.style.height = '0px'\n                        tooltipEl.style.top = '0px'\n                        tooltipEl.style.left = '0px'\n                        break\n                    case 'is-bottom':\n                        tooltipEl.style.width = `${trigger.clientWidth}px`\n                        tooltipEl.style.height = '0px'\n                        tooltipEl.style.top = `${trigger.clientHeight}px`\n                        tooltipEl.style.left = '0px'\n                        break\n                    case 'is-left':\n                        tooltipEl.style.width = '0px'\n                        tooltipEl.style.height = `${trigger.clientHeight}px`\n                        tooltipEl.style.top = '0px'\n                        tooltipEl.style.left = '0px'\n                        break\n                    case 'is-right':\n                        tooltipEl.style.width = '0px'\n                        tooltipEl.style.height = `${trigger.clientHeight}px`\n                        tooltipEl.style.top = '0px'\n                        tooltipEl.style.left = `${trigger.clientWidth}px`\n                        break\n                }\n\n                const wrapper = this.$data._bodyEl\n                wrapper.style.position = 'absolute'\n                wrapper.style.top = `${top}px`\n                wrapper.style.left = `${left}px`\n                wrapper.style.width = '0px'\n                wrapper.style.zIndex = this.isActive || this.always ? '99' : '-1'\n                this.triggerStyle = {\n                    zIndex: this.isActive || this.always ? '100' : undefined\n                }\n            }\n        },\n        onClick() {\n            if (this.triggers.indexOf('click') < 0) return\n            // if not active, toggle after clickOutside event\n            // this fixes toggling programmatic\n            this.$nextTick(() => {\n                this.timeOutID = setTimeout(() => this.open())\n            })\n        },\n        onHover() {\n            if (this.triggers.indexOf('hover') < 0) return\n            this.open()\n        },\n        onContextMenu(e) {\n            if (this.triggers.indexOf('contextmenu') < 0) return\n            e.preventDefault()\n            this.open()\n        },\n        onFocus() {\n            if (this.triggers.indexOf('focus') < 0) return\n            this.open()\n        },\n        open() {\n            if (this.delay) {\n                this.timer = setTimeout(() => {\n                    this.isActive = true\n                    this.timer = null\n                }, this.delay)\n            } else {\n                this.isActive = true\n            }\n        },\n        close() {\n            if (typeof this.autoClose === 'boolean') {\n                if (this.autoClose && this.timer) clearTimeout(this.timer)\n                if (this.closeDelay) {\n                    this.timer = setTimeout(() => {\n                        this.isActive = !this.autoClose\n                        this.timer = null\n                    }, this.closeDelay)\n                } else {\n                    this.isActive = !this.autoClose\n                }\n            }\n        },\n        /**\n        * Close tooltip if clicked outside.\n        */\n        clickedOutside(event) {\n            if (this.isActive) {\n                if (Array.isArray(this.autoClose)) {\n                    if (this.autoClose.includes('outside')) {\n                        if (!this.isInWhiteList(event.target)) {\n                            this.isActive = false\n                            return\n                        }\n                    }\n                    if (this.autoClose.includes('inside')) {\n                        if (this.isInWhiteList(event.target)) this.isActive = false\n                    }\n                }\n            }\n        },\n        /**\n         * Keypress event that is bound to the document\n         */\n        keyPress({ key }) {\n            if (this.isActive && (key === 'Escape' || key === 'Esc')) {\n                if (Array.isArray(this.autoClose)) {\n                    if (this.autoClose.indexOf('escape') >= 0) this.isActive = false\n                }\n            }\n        },\n        /**\n        * White-listed items to not close when clicked.\n        */\n        isInWhiteList(el) {\n            if (el === this.$refs.content) return true\n            // All chidren from content\n            if (this.$refs.content !== undefined) {\n                const children = this.$refs.content.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            return false\n        }\n    },\n    mounted() {\n        if (this.appendToBody && typeof window !== 'undefined') {\n            this.controller = new window.AbortController()\n            this.$data._bodyEl = createAbsoluteElement(this.$refs.content)\n            this.updateAppendToBody()\n            // updates the tooltip position if the tooltip is inside\n            // `.animation-content`\n            const animation = this.$el.closest('.animation-content')\n            if (animation != null) {\n                const listener = () => {\n                    this.updateAppendToBody()\n                    animation.removeEventListener('transitionend', listener)\n                }\n                animation.addEventListener('transitionend', listener, {\n                    signal: this.controller.signal\n                })\n            }\n            // observes changes in the window size\n            this.resizeListener = () => this.updateAppendToBody()\n            window.addEventListener('resize', this.resizeListener)\n            // observes changes in the size of the immediate parent\n            this.resizeObserver = new ResizeObserver(this.resizeListener)\n            if (this.$el.parentNode != null && this.$el.parentNode.nodeType === Node.ELEMENT_NODE) {\n                this.resizeObserver.observe(this.$el.parentNode)\n            }\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('click', this.clickedOutside)\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('click', this.clickedOutside)\n            document.removeEventListener('keyup', this.keyPress)\n        }\n        if (this.resizeListener != null) {\n            window.removeEventListener('resize', this.resizeListener)\n        }\n        if (this.resizeObserver != null) {\n            this.resizeObserver.disconnect()\n        }\n        if (this.appendToBody) {\n            removeElement(this.$data._bodyEl)\n        }\n        if (this.controller != null) {\n            this.controller.abort()\n        }\n        clearTimeout(this.timer)\n        clearTimeout(this.timeOutID)\n    }\n}\n</script>\n",
      "path": "src/components/tooltip/Tooltip.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/color.js",
      "content": "export const colorChannels = ['red', 'green', 'blue', 'alpha']\n\nexport const colorsNammed = {\n    transparent: '#00000000',\n    black: '#000000',\n    silver: '#c0c0c0',\n    gray: '#808080',\n    white: '#ffffff',\n    maroon: '#800000',\n    red: '#ff0000',\n    purple: '#800080',\n    fuchsia: '#ff00ff',\n    green: '#008000',\n    lime: '#00ff00',\n    olive: '#808000',\n    yellow: '#ffff00',\n    navy: '#000080',\n    blue: '#0000ff',\n    teal: '#008080',\n    aqua: '#00ffff',\n    orange: '#ffa500',\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    blanchedalmond: '#ffebcd',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    oldlace: '#fdf5e6',\n    olivedrab: '#6b8e23',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    whitesmoke: '#f5f5f5',\n    yellowgreen: '#9acd32',\n    rebeccapurple: '#663399'\n}\n\nexport class ColorTypeError extends Error {\n    constructor() {\n        super('ColorTypeError: type must be hex(a), rgb(a) or hsl(a)')\n    }\n}\n\nclass Color {\n    constructor(...args) {\n        if (args.length > 0) {\n            return Color.parse(...args)\n        }\n\n        this.$channels = new Uint8Array(colorChannels.length)\n        colorChannels.forEach((channel, index) => {\n            Object.defineProperty(\n                this,\n                channel,\n                {\n                    get: () => this.$channels[index],\n                    set: (byte) => {\n                        if (!Number.isNaN(byte / 1)) {\n                            this.$channels[index] = Math.min(255, Math.max(0, byte))\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                }\n            )\n        })\n        // Required for observability\n        ;['hue', 'saturation', 'lightness'].forEach((name) => {\n            const capitalizedName = name.replace(/^./, (m) => m.toUpperCase())\n            Object.defineProperty(\n                this,\n                name,\n                {\n                    get: () => this[`get${capitalizedName}`](),\n                    set: (value) => {\n                        if (!Number.isNaN(value / 1)) {\n                            this[`set${capitalizedName}`](value)\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                }\n            )\n        })\n    }\n\n    getHue() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n        const delta = max - min\n        let hue = 0\n\n        if (delta === 0) {\n            return hue\n        }\n\n        if (red === max) {\n            hue = ((green - blue) / delta) % 6\n        } else if (green === max) {\n            hue = (blue - red) / delta + 2\n        } else {\n            hue = (red - green) / delta + 4\n        }\n\n        hue *= 60\n        while (hue !== -Infinity && hue < 0) hue += 360\n\n        return Math.round(hue % 360)\n    }\n\n    setHue(value) {\n        const color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255)\n        for (let i = 0; i < this.$channels.length; i++) {\n            this.$channels[i] = Number(color.$channels[i])\n        }\n    }\n\n    getSaturation() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n        const delta = max - min\n\n        return delta !== 0\n            ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100\n            : 0\n    }\n\n    setSaturation(value) {\n        const color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255)\n        colorChannels.forEach((_, i) => (this.$channels[i] = color.$channels[i]))\n    }\n\n    getLightness() {\n        const [red, green, blue] = Array.from(this.$channels).map((c) => c / 255)\n        const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)]\n\n        return Math.round((max + min) / 2 * 100) / 100\n    }\n\n    setLightness(value) {\n        const color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255)\n        colorChannels.forEach((_, i) => (this.$channels[i] = color.$channels[i]))\n    }\n\n    clone() {\n        const color = new Color()\n        colorChannels.forEach((_, i) => (color.$channels[i] = this.$channels[i]))\n\n        return color\n    }\n\n    toString(type = 'hex') {\n        switch (String(type).toLowerCase()) {\n            case 'hex':\n                return '#' + colorChannels.slice(0, 3)\n                    .map((channel) => this[channel].toString(16).padStart(2, '0'))\n                    .join('')\n            case 'hexa':\n                return '#' + colorChannels\n                    .map((channel) => this[channel].toString(16).padStart(2, '0'))\n                    .join('')\n            case 'rgb':\n                return `rgb(${this.red}, ${this.green}, ${this.blue})`\n            case 'rgba':\n                return `rgba(${this.red}, ${this.green}, ${this.blue}, ${Math.round(this.alpha / 2.55) / 100})`\n            case 'hsl':\n                return `hsl(${Math.round(this.hue)}deg, ${Math.round(this.saturation * 100)}%, ${Math.round(this.lightness * 100)}%)`\n            case 'hsla':\n                return `hsla(${Math.round(this.hue)}deg, ${Math.round(this.saturation * 100)}%, ${Math.round(this.lightness * 100)}%, ${Math.round(this.alpha / 2.55) / 100})`\n            default:\n                throw new ColorTypeError()\n        }\n    }\n\n    get [Symbol.toString]() {\n        return this.toString('hex')\n    }\n\n    static parse(...args) {\n        if (typeof args[0] === 'object') {\n            return Color.parseObject(args[0])\n        } else if (args.every((arg) => !Number.isNaN(arg / 1))) {\n            const color = new Color()\n            if (args.length > 3) {\n                color.red = args[0]\n                color.green = args[1]\n                color.blue = args[2]\n\n                if (args[3]) {\n                    color.alpha = args[3]\n                }\n            } else if (args.length === 1) {\n                const index = Number(args[0])\n\n                return Color.parseIndex(index, index > 2 ** 24 ? 3 : 4)\n            }\n        } else if (typeof args[0] === 'string') {\n            let match = null\n\n            if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {\n                return Color.parseHex(colorsNammed[args[0].toLowerCase()])\n            } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {\n                return Color.parseHex(match[2])\n            } else if ((match = args[0].match(/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(\\s*,\\s*(\\d*\\.?\\d+))?\\s*\\)$/i)) !== null) {\n                const channels = [\n                    match[1],\n                    match[2],\n                    match[3],\n                    typeof match[5] !== 'undefined'\n                        ? match[5]\n                        : 1\n                ]\n\n                return Color.fromRGB(...channels.map((value) => Number(value)))\n            } else if ((args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\\(/i))) {\n                throw new Error('Color expression not implemented yet')\n            }\n        }\n\n        throw new Error('Invalid color expression')\n    }\n\n    static parseObject(object) {\n        const color = new Color()\n\n        if (object === null || typeof object !== 'object') {\n            return color\n        }\n        if (Color.isColor(object)) {\n            return object.clone()\n        }\n\n        colorChannels.forEach((channel) => {\n            if (!Number.isNaN(object[channel])) {\n                color[channel] = object[channel]\n            }\n        })\n\n        return color\n    }\n\n    static parseHex(hex) {\n        if (typeof hex !== 'string') {\n            throw new Error('Hex expression must be a string')\n        }\n\n        hex = hex.trim().replace(/^(0x|&h|#)/i, '')\n        if (hex.length === 3 || hex.length === 4) {\n            hex = hex.split('')\n                .map((c) => c.repeat(2))\n                .join('')\n        }\n\n        if (!(hex.length === 6 || hex.length === 8)) {\n            throw new Error('Incorrect Hex expression length')\n        }\n\n        const chans = hex.split(/(..)/)\n            .filter((value) => value)\n            .map((value) => Number.parseInt(value, 16))\n        if (typeof chans[3] === 'number') {\n            chans[3] /= 255\n        }\n        return Color.fromRGB(...chans)\n    }\n\n    static parseIndex(value, channels = 3) {\n        const color = new Color()\n\n        for (let i = 0; i < 4; i++) {\n            color[colorChannels[i]] = (value >> ((channels - i) * 8)) && 0xff\n        }\n\n        return color\n    }\n\n    static fromRGB(red, green, blue, alpha = 1) {\n        if ([red, green, blue, alpha].some((arg) => Number.isNaN(arg / 1))) {\n            throw new Error('Invalid arguments')\n        }\n        alpha *= 255\n\n        const color = new Color()\n        ;[red, green, blue, alpha].forEach((value, index) => {\n            color[colorChannels[index]] = value\n        })\n\n        return color\n    }\n\n    static fromHSL(hue, saturation, lightness, alpha = 1) {\n        if ([hue, saturation, lightness, alpha].some((arg) => Number.isNaN(arg))) {\n            throw new Error('Invalid arguments')\n        }\n        while (hue < 0 && hue !== -Infinity) hue += 360\n        hue = hue % 360\n        saturation = Math.max(0, Math.min(1, saturation))\n        lightness = Math.max(0, Math.min(1, lightness))\n        alpha = Math.max(0, Math.min(1, alpha))\n\n        const c = (1 - Math.abs(2 * lightness - 1)) * saturation\n        const x = c * (1 - Math.abs(hue / 60 % 2 - 1))\n        const m = lightness - c / 2\n\n        const [r, g, b] = hue < 60\n            ? [c, x, 0]\n            : hue < 120\n                ? [x, c, 0]\n                : hue < 180\n                    ? [0, c, x]\n                    : hue < 240\n                        ? [0, x, c]\n                        : hue < 300\n                            ? [x, 0, c]\n                            : [c, 0, x]\n\n        return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha)\n    }\n\n    static isColor(arg) {\n        return arg instanceof Color\n    }\n}\n\nexport default Color\n",
      "path": "src/utils/color.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/FormElementMixin.js",
      "content": "import config from '@/utils/config'\nimport { isVueComponent } from '@/utils/helpers'\n\nexport default {\n    props: {\n        size: String,\n        expanded: Boolean,\n        loading: Boolean,\n        rounded: Boolean,\n        icon: String,\n        iconPack: String,\n        // Native options to use in HTML5 validation\n        autocomplete: String,\n        maxlength: [Number, String],\n        useHtml5Validation: {\n            type: Boolean,\n            default: () => config.defaultUseHtml5Validation\n        },\n        validationMessage: String,\n        locale: {\n            type: [String, Array],\n            default: () => {\n                return config.defaultLocale\n            }\n        },\n        statusIcon: {\n            type: Boolean,\n            default: () => {\n                return config.defaultStatusIcon\n            }\n        }\n    },\n    data() {\n        return {\n            isValid: true,\n            isFocused: false,\n            newIconPack: this.iconPack || config.defaultIconPack\n        }\n    },\n    computed: {\n        /**\n         * Find parent Field, max 3 levels deep.\n         */\n        parentField() {\n            let parent = this.$parent\n            for (let i = 0; i < 3; i++) {\n                if (parent && !parent.$data._isField) {\n                    parent = parent.$parent\n                }\n            }\n            return parent\n        },\n\n        /**\n         * Get the type prop from parent if it's a Field.\n         */\n        statusType() {\n            const { newType } = this.parentField || {}\n\n            if (!newType) return\n\n            if (typeof newType === 'string') {\n                return newType\n            } else {\n                for (const key in newType) {\n                    if (newType[key]) {\n                        return key\n                    }\n                }\n            }\n        },\n\n        /**\n         * Get the message prop from parent if it's a Field.\n         */\n        statusMessage() {\n            if (!this.parentField) return\n\n            return this.parentField.newMessage || this.parentField.$slots.message\n        },\n\n        /**\n         * Fix icon size for inputs, large was too big\n         */\n        iconSize() {\n            switch (this.size) {\n                case 'is-small': return this.size\n                case 'is-medium': return\n                case 'is-large': return this.newIconPack === 'mdi'\n                    ? 'is-medium'\n                    : ''\n            }\n        }\n    },\n    methods: {\n        /**\n         * Focus method that work dynamically depending on the component.\n         */\n        focus() {\n            const el = this.getElement()\n            if (el === undefined) return\n\n            this.$nextTick(() => {\n                if (el) el.focus()\n            })\n        },\n\n        onBlur($event) {\n            this.isFocused = false\n            this.$emit('blur', $event)\n            this.checkHtml5Validity()\n        },\n\n        onFocus($event) {\n            this.isFocused = true\n            this.$emit('focus', $event)\n        },\n\n        getElement() {\n            let el = this.$refs[this.$data._elementRef]\n            while (isVueComponent(el)) {\n                el = el.$refs[el.$data._elementRef]\n            }\n            return el\n        },\n\n        setInvalid() {\n            let type = 'is-danger'\n            let message = this.validationMessage || this.getElement().validationMessage\n            this.setValidity(type, message)\n        },\n\n        setValidity(type, message) {\n            this.$nextTick(() => {\n                if (this.parentField) {\n                    // Set type only if not defined\n                    if (!this.parentField.type) {\n                        this.parentField.newType = type\n                    }\n                    // Set message only if not defined\n                    if (!this.parentField.message) {\n                        this.parentField.newMessage = message\n                    }\n                }\n            })\n        },\n\n        /**\n         * Check HTML5 validation, set isValid property.\n         * If validation fail, send 'is-danger' type,\n         * and error message to parent if it's a Field.\n         */\n        checkHtml5Validity() {\n            if (!this.useHtml5Validation) return\n\n            const el = this.getElement()\n            if (el === undefined) return\n\n            if (!el.checkValidity()) {\n                this.setInvalid()\n                this.isValid = false\n            } else {\n                this.setValidity(null, null)\n                this.isValid = true\n            }\n\n            return this.isValid\n        }\n    }\n}\n",
      "path": "src/utils/FormElementMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/icons.js",
      "content": "import config from '@/utils/config'\nimport { merge } from '@/utils/helpers'\n\nconst mdiIcons = {\n    sizes: {\n        'default': 'mdi-24px',\n        'is-small': null,\n        'is-medium': 'mdi-36px',\n        'is-large': 'mdi-48px'\n    },\n    iconPrefix: 'mdi-'\n}\n\nconst faIcons = () => {\n    const faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-'\n    return {\n        sizes: {\n            'default': null,\n            'is-small': null,\n            'is-medium': faIconPrefix + 'lg',\n            'is-large': faIconPrefix + '2x'\n        },\n        iconPrefix: faIconPrefix,\n        internalIcons: {\n            'information': 'info-circle',\n            'alert': 'exclamation-triangle',\n            'alert-circle': 'exclamation-circle',\n            'chevron-right': 'angle-right',\n            'chevron-left': 'angle-left',\n            'chevron-down': 'angle-down',\n            'eye-off': 'eye-slash',\n            'menu-down': 'caret-down',\n            'menu-up': 'caret-up',\n            'close-circle': 'times-circle'\n        }\n    }\n}\n\nconst getIcons = () => {\n    let icons = {\n        mdi: mdiIcons,\n        fa: faIcons(),\n        fas: faIcons(),\n        far: faIcons(),\n        fad: faIcons(),\n        fab: faIcons(),\n        fal: faIcons(),\n        'fa-solid': faIcons(),\n        'fa-regular': faIcons(),\n        'fa-light': faIcons(),\n        'fa-thin': faIcons(),\n        'fa-duotone': faIcons(),\n        'fa-brands': faIcons()\n    }\n\n    if (config && config.customIconPacks) {\n        icons = merge(icons, config.customIconPacks, true)\n    }\n\n    return icons\n}\n\nexport default getIcons\n",
      "path": "src/utils/icons.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/InjectedChildMixin.js",
      "content": "import {hasFlag} from '@/utils/helpers'\n\nconst sorted = 1\nconst optional = 2\n\nexport const Sorted = sorted\nexport const Optional = optional\n\nexport default (parentItemName, flags = 0) => {\n    const mixin = {\n        inject: {parent: {from: 'b' + parentItemName, default: false}},\n        created() {\n            if (!this.parent) {\n                if (!hasFlag(flags, optional)) {\n                    this.$destroy()\n                    throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName)\n                }\n            } else if (this.parent._registerItem) {\n                this.parent._registerItem(this)\n            }\n        },\n        beforeDestroy() {\n            if (this.parent && this.parent._unregisterItem) {\n                this.parent._unregisterItem(this)\n            }\n        }\n    }\n    if (hasFlag(flags, sorted)) {\n        mixin.data = () => {\n            return {\n                index: null\n            }\n        }\n    }\n    return mixin\n}\n",
      "path": "src/utils/InjectedChildMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/plugins.js",
      "content": "\nexport const use = (plugin) => {\n    if (typeof window !== 'undefined' && window.Vue) {\n        window.Vue.use(plugin)\n    }\n}\n\nexport const registerComponent = (Vue, component) => {\n    Vue.component(component.name, component)\n}\n\nexport const registerComponentProgrammatic = (Vue, property, component) => {\n    if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {}\n    Vue.prototype.$buefy[property] = component\n}\n",
      "path": "src/utils/plugins.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/ProviderParentMixin.js",
      "content": "import {hasFlag} from '@/utils/helpers'\n\nconst items = 1\nconst sorted = 3\n\nexport const Items = items\nexport const Sorted = sorted\n\nexport default (itemName, flags = 0) => {\n    const mixin = {\n        provide() {\n            return {\n                ['b' + itemName]: this\n            }\n        }\n    }\n\n    if (hasFlag(flags, items)) {\n        mixin.data = function () {\n            return {\n                childItems: []\n            }\n        }\n        mixin.methods = {\n            _registerItem(item) {\n                this.childItems.push(item)\n            },\n            _unregisterItem(item) {\n                this.childItems = this.childItems.filter((i) => i !== item)\n            }\n        }\n\n        if (hasFlag(flags, sorted)) {\n            mixin.watch = {\n                /**\n                 * When items are added/removed deep search in the elements default's slot\n                 * And mark the items with their index\n                 */\n                childItems(items) {\n                    if (items.length > 0 && this.$scopedSlots.default) {\n                        let tag = items[0].$vnode.tag\n                        let index = 0\n\n                        const deepSearch = (children) => {\n                            for (let child of children) {\n                                if (child.tag === tag) {\n                                    // An item with the same tag will for sure be found\n                                    const it = items.find((i) => i.$vnode === child)\n                                    if (it) {\n                                        it.index = index++\n                                    }\n                                } else if (child.tag) {\n                                    const sub = child.componentInstance\n                                        ? (child.componentInstance.$scopedSlots.default\n                                            ? child.componentInstance.$scopedSlots.default()\n                                            : child.componentInstance.$children)\n                                        : child.children\n                                    if (Array.isArray(sub) && sub.length > 0) {\n                                        deepSearch(sub.map((e) => e.$vnode))\n                                    }\n                                }\n                            }\n                            return false\n                        }\n\n                        deepSearch(this.$scopedSlots.default())\n                    }\n                }\n            }\n            mixin.computed = {\n                /**\n                 * When items are added/removed sort them according to their position\n                 */\n                sortedItems() {\n                    return this.childItems.slice().sort((i1, i2) => {\n                        return i1.index - i2.index\n                    })\n                }\n            }\n        }\n    }\n    return mixin\n}\n",
      "path": "src/utils/ProviderParentMixin.js"
    }
  ]
}
