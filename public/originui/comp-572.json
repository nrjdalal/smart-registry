{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "comp-572",
  "type": "registry:component",
  "dependencies": [
    "@headless-tree/core",
    "@headless-tree/react",
    "lucide-react",
    "radix-ui"
  ],
  "registryDependencies": [
    "https://originui.com/r/input.json",
    "https://originui.com/r/tree.json"
  ],
  "files": [
    {
      "type": "registry:component",
      "target": "components/comp-572.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport {\n  expandAllFeature,\n  hotkeysCoreFeature,\n  searchFeature,\n  selectionFeature,\n  syncDataLoaderFeature,\n  TreeState,\n} from \"@headless-tree/core\"\nimport { useTree } from \"@headless-tree/react\"\nimport {\n  CircleXIcon,\n  FilterIcon,\n  FolderIcon,\n  FolderOpenIcon,\n} from \"lucide-react\"\n\nimport { Input } from \"@/components/ui/input\"\nimport { Tree, TreeItem, TreeItemLabel } from \"@/components/ui/tree\"\n\ninterface Item {\n  name: string\n  children?: string[]\n}\n\nconst items: Record<string, Item> = {\n  company: {\n    name: \"Company\",\n    children: [\"engineering\", \"marketing\", \"operations\"],\n  },\n  engineering: {\n    name: \"Engineering\",\n    children: [\"frontend\", \"backend\", \"platform-team\"],\n  },\n  frontend: { name: \"Frontend\", children: [\"design-system\", \"web-platform\"] },\n  \"design-system\": {\n    name: \"Design System\",\n    children: [\"components\", \"tokens\", \"guidelines\"],\n  },\n  components: { name: \"Components\" },\n  tokens: { name: \"Tokens\" },\n  guidelines: { name: \"Guidelines\" },\n  \"web-platform\": { name: \"Web Platform\" },\n  backend: { name: \"Backend\", children: [\"apis\", \"infrastructure\"] },\n  apis: { name: \"APIs\" },\n  infrastructure: { name: \"Infrastructure\" },\n  \"platform-team\": { name: \"Platform Team\" },\n  marketing: { name: \"Marketing\", children: [\"content\", \"seo\"] },\n  content: { name: \"Content\" },\n  seo: { name: \"SEO\" },\n  operations: { name: \"Operations\", children: [\"hr\", \"finance\"] },\n  hr: { name: \"HR\" },\n  finance: { name: \"Finance\" },\n}\n\nconst indent = 20\n\nexport default function Component() {\n  // Store the initial expanded items to reset when search is cleared\n  const initialExpandedItems = [\"engineering\", \"frontend\", \"design-system\"]\n  const [state, setState] = useState<Partial<TreeState<Item>>>({})\n  const [searchValue, setSearchValue] = useState(\"\")\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const tree = useTree<Item>({\n    state,\n    setState,\n    initialState: {\n      expandedItems: initialExpandedItems,\n    },\n    indent,\n    rootItemId: \"company\",\n    getItemName: (item) => item.getItemData().name,\n    isItemFolder: (item) => (item.getItemData()?.children?.length ?? 0) > 0,\n    dataLoader: {\n      getItem: (itemId) => items[itemId],\n      getChildren: (itemId) => items[itemId].children ?? [],\n    },\n    features: [\n      syncDataLoaderFeature,\n      hotkeysCoreFeature,\n      selectionFeature,\n      searchFeature,\n      expandAllFeature,\n    ],\n  })\n\n  // Handle clearing the search\n  const handleClearSearch = () => {\n    setSearchValue(\"\")\n\n    // Manually trigger the tree's search onChange with an empty value\n    // to ensure item.isMatchingSearch() is correctly updated.\n    const searchProps = tree.getSearchInputElementProps()\n    if (searchProps.onChange) {\n      const syntheticEvent = {\n        target: { value: \"\" },\n      } as React.ChangeEvent<HTMLInputElement> // Cast to the expected event type\n      searchProps.onChange(syntheticEvent)\n    }\n\n    // Reset tree state to initial expanded items\n    setState((prevState) => ({\n      ...prevState,\n      expandedItems: initialExpandedItems,\n    }))\n\n    // Clear custom filtered items\n    setFilteredItems([])\n\n    if (inputRef.current) {\n      inputRef.current.focus()\n      // Also clear the internal search input\n      inputRef.current.value = \"\"\n    }\n  }\n\n  // Keep track of filtered items separately from the tree's internal search state\n  const [filteredItems, setFilteredItems] = useState<string[]>([])\n\n  // This function determines if an item should be visible based on our custom filtering\n  const shouldShowItem = (itemId: string) => {\n    if (!searchValue || searchValue.length === 0) return true\n    return filteredItems.includes(itemId)\n  }\n\n  // Update filtered items when search value changes\n  useEffect(() => {\n    if (!searchValue || searchValue.length === 0) {\n      setFilteredItems([])\n      return\n    }\n\n    // Get all items\n    const allItems = tree.getItems()\n\n    // First, find direct matches\n    const directMatches = allItems\n      .filter((item) => {\n        const name = item.getItemName().toLowerCase()\n        return name.includes(searchValue.toLowerCase())\n      })\n      .map((item) => item.getId())\n\n    // Then, find all parent IDs of matching items\n    const parentIds = new Set<string>()\n    directMatches.forEach((matchId) => {\n      let item = tree.getItems().find((i) => i.getId() === matchId)\n      while (item?.getParent && item.getParent()) {\n        const parent = item.getParent()\n        if (parent) {\n          parentIds.add(parent.getId())\n          item = parent\n        } else {\n          break\n        }\n      }\n    })\n\n    // Find all children of matching items\n    const childrenIds = new Set<string>()\n    directMatches.forEach((matchId) => {\n      const item = tree.getItems().find((i) => i.getId() === matchId)\n      if (item && item.isFolder()) {\n        // Get all descendants recursively\n        const getDescendants = (itemId: string) => {\n          const children = items[itemId]?.children || []\n          children.forEach((childId) => {\n            childrenIds.add(childId)\n            if (items[childId]?.children?.length) {\n              getDescendants(childId)\n            }\n          })\n        }\n\n        getDescendants(item.getId())\n      }\n    })\n\n    // Combine direct matches, parents, and children\n    setFilteredItems([\n      ...directMatches,\n      ...Array.from(parentIds),\n      ...Array.from(childrenIds),\n    ])\n\n    // Keep all folders expanded during search to ensure all matches are visible\n    // Store current expanded state first\n    const currentExpandedItems = tree.getState().expandedItems || []\n\n    // Get all folder IDs that need to be expanded to show matches\n    const folderIdsToExpand = allItems\n      .filter((item) => item.isFolder())\n      .map((item) => item.getId())\n\n    // Update expanded items in the tree state\n    setState((prevState) => ({\n      ...prevState,\n      expandedItems: [\n        ...new Set([...currentExpandedItems, ...folderIdsToExpand]),\n      ],\n    }))\n  }, [searchValue, tree])\n\n  return (\n    <div className=\"flex h-full flex-col gap-2 *:nth-2:grow\">\n      <div className=\"relative\">\n        <Input\n          ref={inputRef}\n          className=\"peer ps-9\"\n          value={searchValue}\n          onChange={(e) => {\n            const value = e.target.value\n            setSearchValue(value)\n\n            // Apply the search to the tree's internal state as well\n            const searchProps = tree.getSearchInputElementProps()\n            if (searchProps.onChange) {\n              searchProps.onChange(e)\n            }\n\n            if (value.length > 0) {\n              // If input has at least one character, expand all items\n              tree.expandAll()\n            } else {\n              // If input is cleared, reset to initial expanded state\n              setState((prevState) => ({\n                ...prevState,\n                expandedItems: initialExpandedItems,\n              }))\n              setFilteredItems([])\n            }\n          }}\n          // Prevent the internal search from being cleared on blur\n          onBlur={(e) => {\n            // Prevent default blur behavior\n            e.preventDefault()\n\n            // Re-apply the search to ensure it stays active\n            if (searchValue && searchValue.length > 0) {\n              const searchProps = tree.getSearchInputElementProps()\n              if (searchProps.onChange) {\n                const syntheticEvent = {\n                  target: { value: searchValue },\n                } as React.ChangeEvent<HTMLInputElement>\n                searchProps.onChange(syntheticEvent)\n              }\n            }\n          }}\n          type=\"search\"\n          placeholder=\"Filter items...\"\n        />\n        <div className=\"text-muted-foreground/80 pointer-events-none absolute inset-y-0 start-0 flex items-center justify-center ps-3 peer-disabled:opacity-50\">\n          <FilterIcon className=\"size-4\" aria-hidden=\"true\" />\n        </div>\n        {searchValue && (\n          <button\n            className=\"text-muted-foreground/80 hover:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 absolute inset-y-0 end-0 flex h-full w-9 items-center justify-center rounded-e-md transition-[color,box-shadow] outline-none focus:z-10 focus-visible:ring-[3px] disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\"\n            aria-label=\"Clear search\"\n            onClick={handleClearSearch}\n          >\n            <CircleXIcon className=\"size-4\" aria-hidden=\"true\" />\n          </button>\n        )}\n      </div>\n\n      <Tree indent={indent} tree={tree}>\n        {searchValue && filteredItems.length === 0 ? (\n          <p className=\"px-3 py-4 text-center text-sm\">\n            No items found for \"{searchValue}\"\n          </p>\n        ) : (\n          tree.getItems().map((item) => {\n            const isVisible = shouldShowItem(item.getId())\n\n            return (\n              <TreeItem\n                key={item.getId()}\n                item={item}\n                data-visible={isVisible || !searchValue}\n                className=\"data-[visible=false]:hidden\"\n              >\n                <TreeItemLabel>\n                  <span className=\"flex items-center gap-2\">\n                    {item.isFolder() &&\n                      (item.isExpanded() ? (\n                        <FolderOpenIcon className=\"text-muted-foreground pointer-events-none size-4\" />\n                      ) : (\n                        <FolderIcon className=\"text-muted-foreground pointer-events-none size-4\" />\n                      ))}\n                    {item.getItemName()}\n                  </span>\n                </TreeItemLabel>\n              </TreeItem>\n            )\n          })\n        )}\n      </Tree>\n\n      <p\n        aria-live=\"polite\"\n        role=\"region\"\n        className=\"text-muted-foreground mt-2 text-xs\"\n      >\n        Tree with filtering âˆ™{\" \"}\n        <a\n          href=\"https://headless-tree.lukasbach.com\"\n          className=\"hover:text-foreground underline\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          API\n        </a>\n      </p>\n    </div>\n  )\n}\n",
      "path": "registry/default/components/comp-572.tsx"
    },
    {
      "type": "registry:ui",
      "target": "components/ui/input.tsx",
      "content": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"border-input file:text-foreground placeholder:text-muted-foreground/70 flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-sm shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        type === \"search\" &&\n          \"[&::-webkit-search-cancel-button]:appearance-none [&::-webkit-search-decoration]:appearance-none [&::-webkit-search-results-button]:appearance-none [&::-webkit-search-results-decoration]:appearance-none\",\n        type === \"file\" &&\n          \"text-muted-foreground/70 file:border-input file:text-foreground p-0 pr-3 italic file:me-3 file:h-full file:border-0 file:border-r file:border-solid file:bg-transparent file:px-3 file:text-sm file:font-medium file:not-italic\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n",
      "path": "registry/default/ui/input.tsx"
    },
    {
      "type": "registry:ui",
      "target": "components/ui/tree.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { ItemInstance } from \"@headless-tree/core\"\nimport { ChevronDownIcon } from \"lucide-react\"\nimport { Slot } from \"radix-ui\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TreeContextValue<T = any> {\n  indent: number\n  currentItem?: ItemInstance<T>\n  tree?: any\n}\n\nconst TreeContext = React.createContext<TreeContextValue>({\n  indent: 20,\n  currentItem: undefined,\n  tree: undefined,\n})\n\nfunction useTreeContext<T = any>() {\n  return React.useContext(TreeContext) as TreeContextValue<T>\n}\n\ninterface TreeProps extends React.HTMLAttributes<HTMLDivElement> {\n  indent?: number\n  tree?: any\n}\n\nfunction Tree({ indent = 20, tree, className, ...props }: TreeProps) {\n  const containerProps =\n    tree && typeof tree.getContainerProps === \"function\"\n      ? tree.getContainerProps()\n      : {}\n  const mergedProps = { ...props, ...containerProps }\n\n  // Extract style from mergedProps to merge with our custom styles\n  const { style: propStyle, ...otherProps } = mergedProps\n\n  // Merge styles\n  const mergedStyle = {\n    ...propStyle,\n    \"--tree-indent\": `${indent}px`,\n  } as React.CSSProperties\n\n  return (\n    <TreeContext.Provider value={{ indent, tree }}>\n      <div\n        data-slot=\"tree\"\n        style={mergedStyle}\n        className={cn(\"flex flex-col\", className)}\n        {...otherProps}\n      />\n    </TreeContext.Provider>\n  )\n}\n\ninterface TreeItemProps<T = any>\n  extends React.HTMLAttributes<HTMLButtonElement> {\n  item: ItemInstance<T>\n  indent?: number\n  asChild?: boolean\n}\n\nfunction TreeItem<T = any>({\n  item,\n  className,\n  asChild,\n  children,\n  ...props\n}: Omit<TreeItemProps<T>, \"indent\">) {\n  const { indent } = useTreeContext<T>()\n\n  const itemProps = typeof item.getProps === \"function\" ? item.getProps() : {}\n  const mergedProps = { ...props, ...itemProps }\n\n  // Extract style from mergedProps to merge with our custom styles\n  const { style: propStyle, ...otherProps } = mergedProps\n\n  // Merge styles\n  const mergedStyle = {\n    ...propStyle,\n    \"--tree-padding\": `${item.getItemMeta().level * indent}px`,\n  } as React.CSSProperties\n\n  const Comp = asChild ? Slot.Root : \"button\"\n\n  return (\n    <TreeContext.Provider value={{ indent, currentItem: item }}>\n      <Comp\n        data-slot=\"tree-item\"\n        style={mergedStyle}\n        className={cn(\n          \"z-10 ps-(--tree-padding) outline-hidden select-none not-last:pb-0.5 focus:z-20 data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n          className\n        )}\n        data-focus={\n          typeof item.isFocused === \"function\"\n            ? item.isFocused() || false\n            : undefined\n        }\n        data-folder={\n          typeof item.isFolder === \"function\"\n            ? item.isFolder() || false\n            : undefined\n        }\n        data-selected={\n          typeof item.isSelected === \"function\"\n            ? item.isSelected() || false\n            : undefined\n        }\n        data-drag-target={\n          typeof item.isDragTarget === \"function\"\n            ? item.isDragTarget() || false\n            : undefined\n        }\n        data-search-match={\n          typeof item.isMatchingSearch === \"function\"\n            ? item.isMatchingSearch() || false\n            : undefined\n        }\n        aria-expanded={item.isExpanded()}\n        {...otherProps}\n      >\n        {children}\n      </Comp>\n    </TreeContext.Provider>\n  )\n}\n\ninterface TreeItemLabelProps<T = any>\n  extends React.HTMLAttributes<HTMLSpanElement> {\n  item?: ItemInstance<T>\n}\n\nfunction TreeItemLabel<T = any>({\n  item: propItem,\n  children,\n  className,\n  ...props\n}: TreeItemLabelProps<T>) {\n  const { currentItem } = useTreeContext<T>()\n  const item = propItem || currentItem\n\n  if (!item) {\n    console.warn(\"TreeItemLabel: No item provided via props or context\")\n    return null\n  }\n\n  return (\n    <span\n      data-slot=\"tree-item-label\"\n      className={cn(\n        \"in-focus-visible:ring-ring/50 bg-background hover:bg-accent in-data-[selected=true]:bg-accent in-data-[selected=true]:text-accent-foreground in-data-[drag-target=true]:bg-accent flex items-center gap-1 rounded-sm px-2 py-1.5 text-sm transition-colors not-in-data-[folder=true]:ps-7 in-focus-visible:ring-[3px] in-data-[search-match=true]:bg-blue-400/20! [&_svg]:pointer-events-none [&_svg]:shrink-0\",\n        className\n      )}\n      {...props}\n    >\n      {item.isFolder() && (\n        <ChevronDownIcon className=\"text-muted-foreground size-4 in-aria-[expanded=false]:-rotate-90\" />\n      )}\n      {children ||\n        (typeof item.getItemName === \"function\" ? item.getItemName() : null)}\n    </span>\n  )\n}\n\nfunction TreeDragLine({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  const { tree } = useTreeContext()\n\n  if (!tree || typeof tree.getDragLineStyle !== \"function\") {\n    console.warn(\n      \"TreeDragLine: No tree provided via context or tree does not have getDragLineStyle method\"\n    )\n    return null\n  }\n\n  const dragLine = tree.getDragLineStyle()\n  return (\n    <div\n      style={dragLine}\n      className={cn(\n        \"bg-primary before:bg-background before:border-primary absolute z-30 -mt-px h-0.5 w-[unset] before:absolute before:-top-[3px] before:left-0 before:size-2 before:rounded-full before:border-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Tree, TreeItem, TreeItemLabel, TreeDragLine }\n",
      "path": "registry/default/ui/tree.tsx"
    }
  ],
  "meta": {
    "tags": [
      "tree",
      "filter",
      "search"
    ]
  }
}
