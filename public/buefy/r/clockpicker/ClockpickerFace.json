{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "clockpicker/ClockpickerFace",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/clockpicker/ClockpickerFace.vue",
      "content": "<template>\r\n    <div\r\n        class=\"b-clockpicker-face\"\r\n        @mousedown=\"onMouseDown\"\r\n        @mouseup=\"onMouseUp\"\r\n        @mousemove=\"onDragMove\"\r\n        @touchstart=\"onMouseDown\"\r\n        @touchend=\"onMouseUp\"\r\n        @touchmove=\"onDragMove\">\r\n        <div\r\n            class=\"b-clockpicker-face-outer-ring\"\r\n            ref=\"clock\">\r\n            <div\r\n                class=\"b-clockpicker-face-hand\"\r\n                :style=\"handStyle\" />\r\n            <span\r\n                v-for=\"(num, index) of faceNumbers\"\r\n                :key=\"index\"\r\n                class=\"b-clockpicker-face-number\"\r\n                :class=\"getFaceNumberClasses(num)\"\r\n                :style=\"{ transform: getNumberTranslate(num.value) }\">\r\n                <span>{{ num.label }}</span>\r\n            </span>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n// These should match the variables in clockpicker.scss\r\nconst indicatorSize = 40\r\nconst paddingInner = 5\r\n\r\nexport default {\r\n    name: 'BClockpickerFace',\r\n    props: {\r\n        pickerSize: Number,\r\n        min: Number,\r\n        max: Number,\r\n        double: Boolean,\r\n        value: Number,\r\n        faceNumbers: Array,\r\n        disabledValues: Function\r\n    },\r\n    data() {\r\n        return {\r\n            isDragging: false,\r\n            inputValue: this.value,\r\n            prevAngle: 720\r\n        }\r\n    },\r\n    computed: {\r\n        /**\r\n        * How many number indicators are shown on the face\r\n        */\r\n        count() {\r\n            return this.max - this.min + 1\r\n        },\r\n        /**\r\n        * How many number indicators are shown per ring on the face\r\n        */\r\n        countPerRing() {\r\n            return this.double ? (this.count / 2) : this.count\r\n        },\r\n        /**\r\n        * Radius of the clock face\r\n        */\r\n        radius() {\r\n            return this.pickerSize / 2\r\n        },\r\n        /**\r\n        * Radius of the outer ring of number indicators\r\n        */\r\n        outerRadius() {\r\n            return this.radius -\r\n                paddingInner -\r\n                indicatorSize / 2\r\n        },\r\n        /**\r\n        * Radius of the inner ring of number indicators\r\n        */\r\n        innerRadius() {\r\n            return Math.max(this.outerRadius * 0.6,\r\n                this.outerRadius - paddingInner - indicatorSize)\r\n            // 48px gives enough room for the outer ring of numbers\r\n        },\r\n        /**\r\n        * The angle for each selectable value\r\n        * For hours this ends up being 30 degrees, for minutes 6 degrees\r\n        */\r\n        degreesPerUnit() {\r\n            return 360 / this.countPerRing\r\n        },\r\n        /**\r\n        * Used for calculating x/y grid location based on degrees\r\n        */\r\n        degrees() {\r\n            return this.degreesPerUnit * Math.PI / 180\r\n        },\r\n        /**\r\n        * Calculates the angle the clock hand should be rotated for the\r\n        * selected value\r\n        */\r\n        handRotateAngle() {\r\n            let currentAngle = this.prevAngle\r\n            while (currentAngle < 0) currentAngle += 360\r\n            let targetAngle = this.calcHandAngle(this.displayedValue)\r\n            let degreesDiff = this.shortestDistanceDegrees(currentAngle, targetAngle)\r\n            let angle = this.prevAngle + degreesDiff\r\n            return angle\r\n        },\r\n        /**\r\n        * Determines how long the selector hand is based on if the\r\n        * selected value is located along the outer or inner ring\r\n        */\r\n        handScale() {\r\n            return this.calcHandScale(this.displayedValue)\r\n        },\r\n        handStyle() {\r\n            return {\r\n                transform: `rotate(${this.handRotateAngle}deg) scaleY(${this.handScale})`,\r\n                transition: '.3s cubic-bezier(.25,.8,.50,1)'\r\n            }\r\n        },\r\n        /**\r\n        * The value the hand should be pointing at\r\n        */\r\n        displayedValue() {\r\n            return this.inputValue == null ? this.min : this.inputValue\r\n        }\r\n    },\r\n    watch: {\r\n        value(value) {\r\n            if (value !== this.inputValue) {\r\n                this.prevAngle = this.handRotateAngle\r\n            }\r\n            this.inputValue = value\r\n        }\r\n    },\r\n    methods: {\r\n        isDisabled(value) {\r\n            return this.disabledValues && this.disabledValues(value)\r\n        },\r\n        /**\r\n        * Calculates the distance between two points\r\n        */\r\n        euclidean(p0, p1) {\r\n            const dx = p1.x - p0.x\r\n            const dy = p1.y - p0.y\r\n\r\n            return Math.sqrt(dx * dx + dy * dy)\r\n        },\r\n        shortestDistanceDegrees(start, stop) {\r\n            const modDiff = (stop - start) % 360\r\n            let shortestDistance = 180 - Math.abs(Math.abs(modDiff) - 180)\r\n            return (modDiff + 360) % 360 < 180 ? shortestDistance * 1 : shortestDistance * -1\r\n        },\r\n        /**\r\n        * Calculates the angle of the line from the center point\r\n        * to the given point.\r\n        */\r\n        coordToAngle(center, p1) {\r\n            const value = 2 *\r\n                Math.atan2(p1.y - center.y - this.euclidean(center, p1), p1.x - center.x)\r\n            return Math.abs(value * 180 / Math.PI)\r\n        },\r\n        /**\r\n        * Generates the inline style translate() property for a\r\n        * number indicator, which determines it's location on the\r\n        * clock face\r\n        */\r\n        getNumberTranslate(value) {\r\n            const { x, y } = this.getNumberCoords(value)\r\n            return `translate(${x}px, ${y}px)`\r\n        },\r\n        /***\r\n        * Calculates the coordinates on the clock face for a number\r\n        * indicator value\r\n        */\r\n        getNumberCoords(value) {\r\n            const radius = this.isInnerRing(value) ? this.innerRadius : this.outerRadius\r\n            return {\r\n                x: Math.round(radius * Math.sin((value - this.min) * this.degrees)),\r\n                y: Math.round(-radius * Math.cos((value - this.min) * this.degrees))\r\n            }\r\n        },\r\n        getFaceNumberClasses(num) {\r\n            return {\r\n                'active': num.value === this.displayedValue,\r\n                'disabled': this.isDisabled(num.value)\r\n            }\r\n        },\r\n        /**\r\n        * Determines if a value resides on the inner ring\r\n        */\r\n        isInnerRing(value) {\r\n            return this.double && (value - this.min >= this.countPerRing)\r\n        },\r\n        calcHandAngle(value) {\r\n            let angle = this.degreesPerUnit * (value - this.min)\r\n            if (this.isInnerRing(value)) angle -= 360\r\n            return angle\r\n        },\r\n        calcHandScale(value) {\r\n            return this.isInnerRing(value)\r\n                ? ((this.innerRadius) / this.outerRadius)\r\n                : 1\r\n        },\r\n        onMouseDown(e) {\r\n            e.preventDefault()\r\n            this.isDragging = true\r\n            this.onDragMove(e)\r\n        },\r\n        onMouseUp() {\r\n            this.isDragging = false\r\n            if (!this.isDisabled(this.inputValue)) {\r\n                this.$emit('change', this.inputValue)\r\n            }\r\n        },\r\n        onDragMove(e) {\r\n            e.preventDefault()\r\n            if (!this.isDragging && e.type !== 'click') return\r\n\r\n            const { width, top, left } = this.$refs.clock.getBoundingClientRect()\r\n            const { clientX, clientY } = 'touches' in e ? e.touches[0] : e\r\n            const center = { x: width / 2, y: -width / 2 }\r\n            const coords = { x: clientX - left, y: top - clientY }\r\n            const handAngle = Math.round(this.coordToAngle(center, coords) + 360) % 360\r\n            const insideClick = this.double && this.euclidean(center, coords) <\r\n                (this.outerRadius + this.innerRadius) / 2 - 16\r\n\r\n            let value = Math.round(handAngle / this.degreesPerUnit) +\r\n                this.min +\r\n                (insideClick ? this.countPerRing : 0)\r\n\r\n            // Necessary to fix edge case when selecting left part of max value\r\n            if (handAngle >= (360 - this.degreesPerUnit / 2)) {\r\n                value = insideClick ? this.max : this.min\r\n            }\r\n            this.update(value)\r\n        },\r\n        update(value) {\r\n            if (this.inputValue !== value && !this.isDisabled(value)) {\r\n                this.prevAngle = this.handRotateAngle\r\n                this.inputValue = value\r\n                this.$emit('input', value)\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n",
      "path": "src/components/clockpicker/ClockpickerFace.vue"
    }
  ]
}
