{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "datetimepicker/Datetimepicker",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:file",
      "target": "directives/trapFocus.js",
      "content": "const findFocusable = (element, programmatic = false) => {\n    if (!element) {\n        return null\n    }\n    if (programmatic) {\n        return element.querySelectorAll(`*[tabindex=\"-1\"]`)\n    }\n    return element.querySelectorAll(`a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]`)\n}\n\nlet onKeyDown\n\nconst bind = (el, { value = true }) => {\n    if (value) {\n        let focusable = findFocusable(el)\n        let focusableProg = findFocusable(el, true)\n\n        if (focusable && focusable.length > 0) {\n            onKeyDown = (event) => {\n                // Need to get focusable each time since it can change between key events\n                // ex. changing month in a datepicker\n                focusable = findFocusable(el)\n                focusableProg = findFocusable(el, true)\n                const firstFocusable = focusable[0]\n                const lastFocusable = focusable[focusable.length - 1]\n\n                if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    lastFocusable.focus()\n                } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    firstFocusable.focus()\n                }\n            }\n            el.addEventListener('keydown', onKeyDown)\n        }\n    }\n}\n\nconst unbind = (el) => {\n    el.removeEventListener('keydown', onKeyDown)\n}\n\nconst directive = {\n    bind,\n    unbind\n}\n\nexport default directive\n",
      "path": "src/directives/trapFocus.js"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/Datepicker.vue",
      "content": "<template>\n    <div\n        class=\"datepicker control\"\n        :class=\"[size, {'is-expanded': expanded}]\"\n    >\n        <b-dropdown\n            v-if=\"!isMobile || inline\"\n            ref=\"dropdown\"\n            :position=\"position\"\n            :disabled=\"disabled\"\n            :inline=\"inline\"\n            :mobile-modal=\"mobileModal\"\n            :trap-focus=\"trapFocus\"\n            :aria-role=\"ariaRole\"\n            :append-to-body=\"appendToBody\"\n            append-to-body-copy-parent\n            @active-change=\"onActiveChange\"\n            :trigger-tabindex=\"-1\">\n            <template #trigger=\"props\" v-if=\"!inline\">\n                <slot name=\"trigger\" v-bind=\"props\">\n                    <b-input\n                        ref=\"input\"\n                        autocomplete=\"off\"\n                        :value=\"formattedValue\"\n                        :placeholder=\"placeholder\"\n                        :size=\"size\"\n                        :icon=\"icon\"\n                        :icon-right=\"iconRight\"\n                        :icon-right-clickable=\"iconRightClickable\"\n                        :icon-pack=\"iconPack\"\n                        :rounded=\"rounded\"\n                        :loading=\"loading\"\n                        :disabled=\"disabled\"\n                        :readonly=\"!editable\"\n                        v-bind=\"$attrs\"\n                        :use-html5-validation=\"false\"\n                        @click.native=\"onInputClick\"\n                        @icon-right-click=\"$emit('icon-right-click', $event)\"\n                        @keyup.native.enter=\"togglePicker(true)\"\n                        @change.native=\"onChange($event.target.value)\"\n                        @focus=\"handleOnFocus\" />\n                </slot>\n            </template>\n\n            <b-dropdown-item\n                :disabled=\"disabled\"\n                :focusable=\"focusable\"\n                custom\n                :class=\"{'dropdown-horizontal-timepicker': horizontalTimePicker}\">\n                <div>\n                    <header class=\"datepicker-header\">\n                        <template v-if=\"$slots.header !== undefined && $slots.header.length\">\n                            <slot name=\"header\" />\n                        </template>\n                        <div\n                            v-else\n                            class=\"pagination field is-centered\"\n                            :class=\"size\">\n                            <a\n                                v-show=\"!showPrev && !disabled\"\n                                class=\"pagination-previous\"\n                                role=\"button\"\n                                href=\"#\"\n                                :disabled=\"disabled\"\n                                :aria-label=\"ariaPreviousLabel\"\n                                @click.prevent=\"prev\"\n                                @keydown.enter.prevent=\"prev\"\n                                @keydown.space.prevent=\"prev\">\n\n                                <b-icon\n                                    :icon=\"iconPrev\"\n                                    :pack=\"iconPack\"\n                                    both\n                                    type=\"is-primary is-clickable\"/>\n                            </a>\n                            <a\n                                v-show=\"!showNext && !disabled\"\n                                class=\"pagination-next\"\n                                role=\"button\"\n                                href=\"#\"\n                                :disabled=\"disabled\"\n                                :aria-label=\"ariaNextLabel\"\n                                @click.prevent=\"next\"\n                                @keydown.enter.prevent=\"next\"\n                                @keydown.space.prevent=\"next\">\n\n                                <b-icon\n                                    :icon=\"iconNext\"\n                                    :pack=\"iconPack\"\n                                    both\n                                    type=\"is-primary is-clickable\"/>\n                            </a>\n                            <div class=\"pagination-list\">\n                                <b-field>\n                                    <b-select\n                                        v-if=\"!isTypeMonth\"\n                                        v-model=\"focusedDateData.month\"\n                                        :disabled=\"disabled\"\n                                        :size=\"size\">\n                                        <option\n                                            v-for=\"month in listOfMonths\"\n                                            :value=\"month.index\"\n                                            :key=\"month.name\"\n                                            :disabled=\"month.disabled\">\n                                            {{ month.name }}\n                                        </option>\n                                    </b-select>\n                                    <b-select\n                                        v-model=\"focusedDateData.year\"\n                                        :disabled=\"disabled\"\n                                        :size=\"size\">\n                                        <option\n                                            v-for=\"year in listOfYears\"\n                                            :value=\"year\"\n                                            :key=\"year\">\n                                            {{ year }}\n                                        </option>\n                                    </b-select>\n                                </b-field>\n                            </div>\n                        </div>\n                    </header>\n                    <div\n                        v-if=\"!isTypeMonth\"\n                        class=\"datepicker-content\"\n                        :class=\"{'content-horizontal-timepicker': horizontalTimePicker}\">\n                        <b-datepicker-table\n                            v-model=\"computedValue\"\n                            :day-names=\"newDayNames\"\n                            :month-names=\"newMonthNames\"\n                            :first-day-of-week=\"firstDayOfWeek\"\n                            :rules-for-first-week=\"rulesForFirstWeek\"\n                            :min-date=\"minDate\"\n                            :max-date=\"maxDate\"\n                            :focused=\"focusedDateData\"\n                            :disabled=\"disabled\"\n                            :unselectable-dates=\"unselectableDates\"\n                            :unselectable-days-of-week=\"unselectableDaysOfWeek\"\n                            :selectable-dates=\"selectableDates\"\n                            :events=\"events\"\n                            :indicators=\"indicators\"\n                            :date-creator=\"dateCreator\"\n                            :type-month=\"isTypeMonth\"\n                            :nearby-month-days=\"nearbyMonthDays\"\n                            :nearby-selectable-month-days=\"nearbySelectableMonthDays\"\n                            :show-week-number=\"showWeekNumber\"\n                            :week-number-clickable=\"weekNumberClickable\"\n                            :range=\"range\"\n                            :multiple=\"multiple\"\n                            @range-start=\"date => $emit('range-start', date)\"\n                            @range-end=\"date => $emit('range-end', date)\"\n                            @close=\"togglePicker(false)\"\n                            @update:focused=\"focusedDateData = $event\" />\n                    </div>\n                    <div v-else>\n                        <b-datepicker-month\n                            v-model=\"computedValue\"\n                            :month-names=\"newMonthNames\"\n                            :min-date=\"minDate\"\n                            :max-date=\"maxDate\"\n                            :focused=\"focusedDateData\"\n                            :disabled=\"disabled\"\n                            :unselectable-dates=\"unselectableDates\"\n                            :unselectable-days-of-week=\"unselectableDaysOfWeek\"\n                            :selectable-dates=\"selectableDates\"\n                            :events=\"events\"\n                            :indicators=\"indicators\"\n                            :date-creator=\"dateCreator\"\n                            :range=\"range\"\n                            :multiple=\"multiple\"\n                            @range-start=\"date => $emit('range-start', date)\"\n                            @range-end=\"date => $emit('range-end', date)\"\n                            @close=\"togglePicker(false)\"\n                            @change-focus=\"changeFocus\"\n                            @update:focused=\"focusedDateData = $event\" />\n                    </div>\n                </div>\n\n                <footer\n                    v-if=\"$slots.default !== undefined && $slots.default.length\"\n                    class=\"datepicker-footer\"\n                    :class=\"{'footer-horizontal-timepicker': horizontalTimePicker}\">\n                    <slot/>\n                </footer>\n            </b-dropdown-item>\n        </b-dropdown>\n\n        <b-input\n            v-else\n            ref=\"input\"\n            :type=\"!isTypeMonth ? 'date' : 'month'\"\n            autocomplete=\"off\"\n            :value=\"formatNative(computedValue)\"\n            :placeholder=\"placeholder\"\n            :size=\"size\"\n            :icon=\"icon\"\n            :icon-pack=\"iconPack\"\n            :rounded=\"rounded\"\n            :loading=\"loading\"\n            :max=\"formatNative(maxDate)\"\n            :min=\"formatNative(minDate)\"\n            :disabled=\"disabled\"\n            :readonly=\"false\"\n            v-bind=\"$attrs\"\n            :use-html5-validation=\"false\"\n            @change.native=\"onChangeNativePicker\"\n            @focus=\"onFocus\"\n            @blur=\"onBlur\"/>\n    </div>\n</template>\n\n<script>\nimport FormElementMixin from '@/utils/FormElementMixin'\nimport { isMobile, getMonthNames, getWeekdayNames, matchWithGroups } from '@/utils/helpers'\nimport config from '@/utils/config'\n\nimport Dropdown from '@/components/dropdown/Dropdown'\nimport DropdownItem from '@/components/dropdown/DropdownItem'\nimport Input from '@/components/input/Input'\nimport Field from '@/components/field/Field'\nimport Select from '@/components/select/Select'\nimport Icon from '@/components/icon/Icon'\n\nimport DatepickerTable from '@/components/datepicker/DatepickerTable'\nimport DatepickerMonth from '@/components/datepicker/DatepickerMonth'\n\nconst defaultDateFormatter = (date, vm) => {\n    const targetDates = Array.isArray(date) ? date : [date]\n    const dates = targetDates.map((date) => {\n        const d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12)\n        return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d)\n    })\n    return !vm.multiple ? dates.join(' - ') : dates.join(', ')\n}\n\nconst defaultDateParser = (date, vm) => {\n    if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {\n        const formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf)\n            .formatToParts(new Date(2000, 11, 25)).map((part) => {\n                if (part.type === 'literal') {\n                    return part.value\n                }\n                return `((?!=<${part.type}>)\\\\d+)`\n            }).join('')\n        const dateGroups = matchWithGroups(formatRegex, date)\n\n        // We do a simple validation for the group.\n        // If it is not valid, it will fallback to Date.parse below\n        if (\n            dateGroups.year &&\n            dateGroups.year.length === 4 &&\n            dateGroups.month &&\n            dateGroups.month <= 12\n        ) {\n            if (vm.isTypeMonth) return new Date(dateGroups.year, dateGroups.month - 1)\n            else if (dateGroups.day && dateGroups.day <= 31) {\n                return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12)\n            }\n        }\n    }\n    // Fallback if formatToParts is not supported or if we were not able to parse a valid date\n    if (!vm.isTypeMonth) return new Date(Date.parse(date))\n    if (date) {\n        const s = date.split('/')\n        const year = s[0].length === 4 ? s[0] : s[1]\n        const month = s[0].length === 2 ? s[0] : s[1]\n        if (year && month) {\n            return new Date(parseInt(year, 10), parseInt(month - 1, 10), 1, 0, 0, 0, 0)\n        }\n    }\n    return null\n}\n\nexport default {\n    name: 'BDatepicker',\n    components: {\n        [DatepickerTable.name]: DatepickerTable,\n        [DatepickerMonth.name]: DatepickerMonth,\n        [Input.name]: Input,\n        [Field.name]: Field,\n        [Select.name]: Select,\n        [Icon.name]: Icon,\n        [Dropdown.name]: Dropdown,\n        [DropdownItem.name]: DropdownItem\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    provide() {\n        return {\n            $datepicker: this\n        }\n    },\n    props: {\n        value: {\n            type: [Date, Array]\n        },\n        dayNames: {\n            type: Array,\n            default: () => {\n                if (!Array.isArray(config.defaultDayNames)) {\n                    return undefined\n                }\n                return config.defaultDayNames\n            }\n        },\n        monthNames: {\n            type: Array,\n            default: () => {\n                if (!Array.isArray(config.defaultMonthNames)) {\n                    return undefined\n                }\n                return config.defaultMonthNames\n            }\n        },\n        firstDayOfWeek: {\n            type: Number,\n            default: () => {\n                if (typeof config.defaultFirstDayOfWeek === 'number') {\n                    return config.defaultFirstDayOfWeek\n                } else {\n                    return 0\n                }\n            }\n        },\n        inline: Boolean,\n        minDate: Date,\n        maxDate: Date,\n        focusedDate: Date,\n        placeholder: String,\n        editable: Boolean,\n        disabled: Boolean,\n        horizontalTimePicker: Boolean,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: {\n            type: Array,\n            default: () => config.defaultUnselectableDaysOfWeek\n        },\n        selectableDates: [Array, Function],\n        dateFormatter: {\n            type: Function,\n            default: (date, vm) => {\n                if (typeof config.defaultDateFormatter === 'function') {\n                    return config.defaultDateFormatter(date)\n                } else {\n                    return defaultDateFormatter(date, vm)\n                }\n            }\n        },\n        dateParser: {\n            type: Function,\n            default: (date, vm) => {\n                if (typeof config.defaultDateParser === 'function') {\n                    return config.defaultDateParser(date)\n                } else {\n                    return defaultDateParser(date, vm)\n                }\n            }\n        },\n        dateCreator: {\n            type: Function,\n            default: () => {\n                if (typeof config.defaultDateCreator === 'function') {\n                    return config.defaultDateCreator()\n                } else {\n                    return new Date()\n                }\n            }\n        },\n        mobileNative: {\n            type: Boolean,\n            default: () => config.defaultDatepickerMobileNative\n        },\n        position: String,\n        iconRight: String,\n        iconRightClickable: Boolean,\n        events: Array,\n        indicators: {\n            type: String,\n            default: 'dots'\n        },\n        openOnFocus: Boolean,\n        iconPrev: {\n            type: String,\n            default: () => config.defaultIconPrev\n        },\n        iconNext: {\n            type: String,\n            default: () => config.defaultIconNext\n        },\n        yearsRange: {\n            type: Array,\n            default: () => config.defaultDatepickerYearsRange\n        },\n        type: {\n            type: String,\n            validator: (value) => {\n                return [\n                    'month'\n                ].indexOf(value) >= 0\n            }\n        },\n        nearbyMonthDays: {\n            type: Boolean,\n            default: () => config.defaultDatepickerNearbyMonthDays\n        },\n        nearbySelectableMonthDays: {\n            type: Boolean,\n            default: () => config.defaultDatepickerNearbySelectableMonthDays\n        },\n        showWeekNumber: {\n            type: Boolean,\n            default: () => config.defaultDatepickerShowWeekNumber\n        },\n        weekNumberClickable: {\n            type: Boolean,\n            default: () => config.defaultDatepickerWeekNumberClickable\n        },\n        rulesForFirstWeek: {\n            type: Number,\n            default: () => 4\n        },\n        range: {\n            type: Boolean,\n            default: false\n        },\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        multiple: {\n            type: Boolean,\n            default: false\n        },\n        mobileModal: {\n            type: Boolean,\n            default: () => config.defaultDatepickerMobileModal\n        },\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        trapFocus: {\n            type: Boolean,\n            default: () => config.defaultTrapFocus\n        },\n        appendToBody: Boolean,\n        ariaNextLabel: String,\n        ariaPreviousLabel: String\n    },\n    data() {\n        const focusedDate = (Array.isArray(this.value) ? this.value[0] : (this.value)) ||\n            this.focusedDate || this.dateCreator()\n\n        if (!this.value && this.maxDate && this.maxDate.getFullYear() < focusedDate.getFullYear()) {\n            focusedDate.setFullYear(this.maxDate.getFullYear())\n        }\n\n        return {\n            dateSelected: this.value,\n            focusedDateData: {\n                day: focusedDate.getDate(),\n                month: focusedDate.getMonth(),\n                year: focusedDate.getFullYear()\n            },\n            _elementRef: 'input',\n            _isDatepicker: true\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.dateSelected\n            },\n            set(value) {\n                this.updateInternalState(value)\n                if (!this.multiple) this.togglePicker(false)\n                this.$emit('input', value)\n                if (this.useHtml5Validation) {\n                    this.$nextTick(() => {\n                        this.checkHtml5Validity()\n                    })\n                }\n            }\n        },\n        formattedValue() {\n            return this.formatValue(this.computedValue)\n        },\n        localeOptions() {\n            return new Intl.DateTimeFormat(this.locale, {\n                year: 'numeric',\n                month: 'numeric'\n            }).resolvedOptions()\n        },\n        dtf() {\n            return new Intl.DateTimeFormat(this.locale)\n        },\n        dtfMonth() {\n            return new Intl.DateTimeFormat(this.locale, {\n                year: this.localeOptions.year || 'numeric',\n                month: this.localeOptions.month || '2-digit'\n            })\n        },\n        newMonthNames() {\n            if (Array.isArray(this.monthNames)) {\n                return this.monthNames\n            }\n            return getMonthNames(this.locale)\n        },\n        newDayNames() {\n            if (Array.isArray(this.dayNames)) {\n                return this.dayNames\n            }\n            return getWeekdayNames(this.locale)\n        },\n        listOfMonths() {\n            let minMonth = 0\n            let maxMonth = 12\n            if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {\n                minMonth = this.minDate.getMonth()\n            }\n            if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {\n                maxMonth = this.maxDate.getMonth()\n            }\n            return this.newMonthNames.map((name, index) => {\n                return {\n                    name: name,\n                    index: index,\n                    disabled: index < minMonth || index > maxMonth\n                }\n            })\n        },\n        /*\n         * Returns an array of years for the year dropdown. If earliest/latest\n         * dates are set by props, range of years will fall within those dates.\n         */\n        listOfYears() {\n            let latestYear = this.focusedDateData.year + this.yearsRange[1]\n            if (this.maxDate && this.maxDate.getFullYear() < latestYear) {\n                latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year)\n            }\n\n            let earliestYear = this.focusedDateData.year + this.yearsRange[0]\n            if (this.minDate && this.minDate.getFullYear() > earliestYear) {\n                earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year)\n            }\n\n            const arrayOfYears = []\n            for (let i = earliestYear; i <= latestYear; i++) {\n                arrayOfYears.push(i)\n            }\n\n            return arrayOfYears.reverse()\n        },\n\n        showPrev() {\n            if (!this.minDate) return false\n            if (this.isTypeMonth) {\n                return this.focusedDateData.year <= this.minDate.getFullYear()\n            }\n            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month)\n            const date = new Date(this.minDate.getFullYear(), this.minDate.getMonth())\n            return (dateToCheck <= date)\n        },\n\n        showNext() {\n            if (!this.maxDate) return false\n            if (this.isTypeMonth) {\n                return this.focusedDateData.year >= this.maxDate.getFullYear()\n            }\n            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month)\n            const date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth())\n            return (dateToCheck >= date)\n        },\n\n        isMobile() {\n            return this.mobileNative && isMobile.any()\n        },\n\n        isTypeMonth() {\n            return this.type === 'month'\n        },\n\n        ariaRole() {\n            if (!this.inline) {\n                return 'dialog'\n            }\n        }\n    },\n    watch: {\n        /**\n         * When v-model is changed:\n         *   1. Update internal value.\n         *   2. If it's invalid, validate again.\n         */\n        value(value) {\n            this.updateInternalState(value)\n            if (!this.multiple) this.togglePicker(false)\n        },\n\n        focusedDate(value) {\n            if (value) {\n                this.focusedDateData = {\n                    day: value.getDate(),\n                    month: value.getMonth(),\n                    year: value.getFullYear()\n                }\n            }\n        },\n\n        /*\n         * Emit input event on month and/or year change\n         */\n        'focusedDateData.month'(value) {\n            this.$emit('change-month', value)\n        },\n        'focusedDateData.year'(value) {\n            this.$emit('change-year', value)\n        }\n    },\n    methods: {\n        /*\n         * Parse string into date\n         */\n        onChange(value) {\n            const date = this.dateParser(value, this)\n            if (date && (!isNaN(date) ||\n                (Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1])))) {\n                this.computedValue = date\n            } else {\n                // Force refresh input value when not valid date\n                this.computedValue = null\n                if (this.$refs.input) {\n                    this.$refs.input.newValue = this.computedValue\n                }\n            }\n        },\n\n        /*\n         * Format date into string\n         */\n        formatValue(value) {\n            if (Array.isArray(value)) {\n                const isArrayWithValidDates = Array.isArray(value) && value.every((v) => !isNaN(v))\n                return isArrayWithValidDates ? this.dateFormatter([...value], this) : null\n            }\n            return (value && !isNaN(value)) ? this.dateFormatter(value, this) : null\n        },\n\n        /*\n         * Either decrement month by 1 if not January or decrement year by 1\n         * and set month to 11 (December) or decrement year when 'month'\n         */\n        prev() {\n            if (this.disabled) return\n\n            if (this.isTypeMonth) {\n                this.focusedDateData.year -= 1\n            } else {\n                if (this.focusedDateData.month > 0) {\n                    this.focusedDateData.month -= 1\n                } else {\n                    this.focusedDateData.month = 11\n                    this.focusedDateData.year -= 1\n                }\n            }\n        },\n\n        /*\n         * Either increment month by 1 if not December or increment year by 1\n         * and set month to 0 (January) or increment year when 'month'\n         */\n        next() {\n            if (this.disabled) return\n\n            if (this.isTypeMonth) {\n                this.focusedDateData.year += 1\n            } else {\n                if (this.focusedDateData.month < 11) {\n                    this.focusedDateData.month += 1\n                } else {\n                    this.focusedDateData.month = 0\n                    this.focusedDateData.year += 1\n                }\n            }\n        },\n\n        formatNative(value) {\n            return this.isTypeMonth\n                ? this.formatYYYYMM(value) : this.formatYYYYMMDD(value)\n        },\n\n        /*\n         * Format date into string 'YYYY-MM-DD'\n         */\n        formatYYYYMMDD(value) {\n            const date = new Date(value)\n            if (value && !isNaN(date)) {\n                const year = date.getFullYear()\n                const month = date.getMonth() + 1\n                const day = date.getDate()\n                return year + '-' +\n                    ((month < 10 ? '0' : '') + month) + '-' +\n                    ((day < 10 ? '0' : '') + day)\n            }\n            return ''\n        },\n\n        /*\n         * Format date into string 'YYYY-MM'\n         */\n        formatYYYYMM(value) {\n            const date = new Date(value)\n            if (value && !isNaN(date)) {\n                const year = date.getFullYear()\n                const month = date.getMonth() + 1\n                return year + '-' +\n                    ((month < 10 ? '0' : '') + month)\n            }\n            return ''\n        },\n\n        /*\n         * Parse date from string\n         */\n        onChangeNativePicker(event) {\n            const date = event.target.value\n            const s = date ? date.split('-') : []\n            if (s.length === 3) {\n                const year = parseInt(s[0], 10)\n                const month = parseInt(s[1]) - 1\n                const day = parseInt(s[2])\n                this.computedValue = new Date(year, month, day)\n            } else {\n                this.computedValue = null\n            }\n        },\n        updateInternalState(value) {\n            if (this.dateSelected === value) return\n            const isArray = Array.isArray(value)\n            const currentDate = isArray\n                ? (!value.length ? this.dateCreator() : value[value.length - 1])\n                : (!value ? this.dateCreator() : value)\n            if (!isArray ||\n                (isArray && this.dateSelected && value.length > this.dateSelected.length)) {\n                this.focusedDateData = {\n                    day: currentDate.getDate(),\n                    month: currentDate.getMonth(),\n                    year: currentDate.getFullYear()\n                }\n            }\n            this.dateSelected = value\n        },\n\n        /*\n         * Toggle datepicker\n         */\n        togglePicker(active) {\n            if (this.$refs.dropdown) {\n                const isActive = typeof active === 'boolean'\n                    ? active\n                    : !this.$refs.dropdown.isActive\n                if (isActive) {\n                    this.$refs.dropdown.isActive = isActive\n                } else if (this.closeOnClick) {\n                    this.$refs.dropdown.isActive = isActive\n                }\n            }\n        },\n\n        /*\n         * Call default onFocus method and show datepicker\n         */\n        handleOnFocus(event) {\n            this.onFocus(event)\n            if (this.openOnFocus) {\n                this.togglePicker(true)\n            }\n        },\n\n        /*\n         * Toggle dropdown\n         */\n        toggle() {\n            if (this.mobileNative && this.isMobile) {\n                const input = this.$refs.input.$refs.input\n                input.focus()\n                input.click()\n                return\n            }\n            this.$refs.dropdown.toggle()\n        },\n\n        /*\n         * Avoid dropdown toggle when is already visible\n         */\n        onInputClick(event) {\n            if (this.$refs.dropdown.isActive) {\n                event.stopPropagation()\n            }\n        },\n\n        /**\n         * Keypress event that is bound to the document.\n         */\n        keyPress({ key }) {\n            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {\n                this.togglePicker(false)\n            }\n        },\n\n        /**\n         * Emit 'blur' event on dropdown is not active (closed)\n         */\n        onActiveChange(value) {\n            if (!value) {\n                this.onBlur()\n            }\n            /*\n             * Emit 'active-change' when on dropdown active state change\n             */\n            this.$emit('active-change', value)\n        },\n\n        changeFocus(day) {\n            this.focusedDateData = {\n                day: day.getDate(),\n                month: day.getMonth(),\n                year: day.getFullYear()\n            }\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('keyup', this.keyPress)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/Datepicker.vue"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerMonth.vue",
      "content": "<template>\n    <section class=\"datepicker-table\">\n        <div class=\"datepicker-body\" :class=\"{'has-events':hasEvents}\">\n            <div class=\"datepicker-months\">\n                <template v-for=\"(date, index) in monthDates\">\n                    <a\n                        :ref=\"`month-${date.getMonth()}`\"\n                        v-if=\"selectableDate(date) && !disabled\"\n                        :key=\"index\"\n                        :class=\"[\n                            classObject(date),\n                            {'has-event': eventsDateMatch(date)},\n                            indicators\n                        ]\"\n                        class=\"datepicker-cell\"\n                        role=\"button\"\n                        href=\"#\"\n                        :disabled=\"disabled\"\n                        @click.prevent=\"updateSelectedDate(date)\"\n                        @mouseenter=\"setRangeHoverEndDate(date)\"\n                        @keydown.prevent=\"manageKeydown($event, date)\"\n                        :tabindex=\"focused.month === date.getMonth() ? null : -1\">\n                        {{ monthNames[date.getMonth()] }}\n                        <div class=\"events\" v-if=\"eventsDateMatch(date)\">\n                            <div\n                                class=\"event\"\n                                :class=\"event.type\"\n                                v-for=\"(event, index) in eventsDateMatch(date)\"\n                                :key=\"index\"/>\n                        </div>\n                    </a>\n                    <div\n                        v-else\n                        :key=\"index\"\n                        :class=\"classObject(date)\"\n                        class=\"datepicker-cell\">\n                        {{ monthNames[date.getMonth()] }}\n                    </div>\n                </template>\n            </div>\n        </div>\n    </section>\n</template>\n\n<script>\nimport { isDefined } from '@/utils/helpers'\n\nexport default {\n    name: 'BDatepickerMonth',\n    props: {\n        value: {\n            type: [Date, Array]\n        },\n        monthNames: Array,\n        events: Array,\n        indicators: String,\n        minDate: Date,\n        maxDate: Date,\n        focused: Object,\n        disabled: Boolean,\n        dateCreator: Function,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        range: Boolean,\n        multiple: Boolean\n    },\n    data() {\n        return {\n            selectedBeginDate: undefined,\n            selectedEndDate: undefined,\n            hoveredEndDate: undefined,\n            multipleSelectedDates: this.multiple && this.value ? this.value : []\n        }\n    },\n    computed: {\n        hasEvents() {\n            return this.events && this.events.length\n        },\n\n        /*\n        * Return array of all events in the specified month\n        */\n        eventsInThisYear() {\n            if (!this.events) return []\n\n            const yearEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                let event = this.events[i]\n\n                if (!event.hasOwnProperty('date')) {\n                    event = { date: event }\n                }\n                if (!event.hasOwnProperty('type')) {\n                    event.type = 'is-primary'\n                }\n                if (\n                    event.date.getFullYear() === this.focused.year\n                ) {\n                    yearEvents.push(event)\n                }\n            }\n\n            return yearEvents\n        },\n        monthDates() {\n            const year = this.focused.year\n            const months = []\n            for (let i = 0; i < 12; i++) {\n                const d = new Date(year, i, 1)\n                d.setHours(0, 0, 0, 0)\n                months.push(d)\n            }\n            return months\n        },\n\n        focusedMonth() {\n            return this.focused.month\n        },\n\n        hoveredDateRange() {\n            if (!this.range) {\n                return []\n            }\n            if (!isNaN(this.selectedEndDate)) {\n                return []\n            }\n            if (this.hoveredEndDate < this.selectedBeginDate) {\n                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)\n            }\n            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)\n        }\n    },\n    watch: {\n        focusedMonth(month) {\n            const refName = `month-${month}`\n            if (this.$refs[refName] && this.$refs[refName].length > 0) {\n                this.$nextTick(() => {\n                    if (this.$refs[refName][0]) {\n                        this.$refs[refName][0].focus()\n                    }\n                }) // $nextTick needed when year is changed\n            }\n        }\n    },\n    methods: {\n        selectMultipleDates(date) {\n            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>\n                selectedDate.getDate() === date.getDate() &&\n                selectedDate.getFullYear() === date.getFullYear() &&\n                selectedDate.getMonth() === date.getMonth()\n            )\n            if (multipleSelect.length) {\n                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>\n                    selectedDate.getDate() !== date.getDate() ||\n                    selectedDate.getFullYear() !== date.getFullYear() ||\n                    selectedDate.getMonth() !== date.getMonth()\n                )\n            } else {\n                this.multipleSelectedDates.push(date)\n            }\n            this.$emit('input', this.multipleSelectedDates)\n        },\n\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            validity.push(day.getFullYear() === this.focused.year)\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n        eventsDateMatch(day) {\n            if (!this.eventsInThisYear.length) return false\n\n            const monthEvents = []\n\n            for (let i = 0; i < this.eventsInThisYear.length; i++) {\n                if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {\n                    monthEvents.push(this.events[i])\n                }\n            }\n\n            if (!monthEvents.length) {\n                return false\n            }\n\n            return monthEvents\n        },\n        /*\n        * Build classObject for cell using validations\n        */\n        classObject(day) {\n            function dateMatch(dateOne, dateTwo, multiple) {\n                // if either date is null or undefined, return false\n                if (!dateOne || !dateTwo || multiple) {\n                    return false\n                }\n                if (Array.isArray(dateTwo)) {\n                    return dateTwo.some((date) => (\n                        dateOne.getFullYear() === date.getFullYear() &&\n                        dateOne.getMonth() === date.getMonth()\n                    ))\n                }\n                return (dateOne.getFullYear() === dateTwo.getFullYear() &&\n                    dateOne.getMonth() === dateTwo.getMonth())\n            }\n            function dateWithin(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || multiple) { return false }\n\n                return dateOne > dates[0] && dateOne < dates[1]\n            }\n            function dateMultipleSelected(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || !multiple) { return false }\n                return dates.some((date) => (\n                    dateOne.getDate() === date.getDate() &&\n                    dateOne.getFullYear() === date.getFullYear() &&\n                    dateOne.getMonth() === date.getMonth()\n                ))\n            }\n\n            return {\n                'is-selected': dateMatch(day, this.value, this.multiple) ||\n                               dateWithin(day, this.value, this.multiple) ||\n                               dateMultipleSelected(day, this.multipleSelectedDates, this.multiple),\n                'is-first-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.value) && this.value[0],\n                        this.multiple\n                    ),\n                'is-within-selected':\n                    dateWithin(day, this.value, this.multiple),\n                'is-last-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.value) && this.value[1],\n                        this.multiple\n                    ),\n                'is-within-hovered-range':\n                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&\n                    (dateMatch(day, this.hoveredDateRange) ||\n                        dateWithin(day, this.hoveredDateRange)),\n                'is-first-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]\n                ),\n                'is-within-hovered':\n                    dateWithin(day, this.hoveredDateRange),\n                'is-last-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]\n                ),\n                'is-today': dateMatch(day, this.dateCreator()),\n                'is-selectable': this.selectableDate(day) && !this.disabled,\n                'is-unselectable': !this.selectableDate(day) || this.disabled\n            }\n        },\n\n        manageKeydown({ key }, date) {\n            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys\n            switch (key) {\n                case ' ':\n                case 'Space':\n                case 'Spacebar':\n                case 'Enter': {\n                    this.updateSelectedDate(date)\n                    break\n                }\n\n                case 'ArrowLeft':\n                case 'Left': {\n                    this.changeFocus(date, -1)\n                    break\n                }\n                case 'ArrowRight':\n                case 'Right': {\n                    this.changeFocus(date, 1)\n                    break\n                }\n                case 'ArrowUp':\n                case 'Up': {\n                    this.changeFocus(date, -3)\n                    break\n                }\n                case 'ArrowDown':\n                case 'Down': {\n                    this.changeFocus(date, 3)\n                    break\n                }\n            }\n        },\n\n        /*\n        * Emit input event with selected date as payload for v-model in parent\n        */\n        updateSelectedDate(date) {\n            if (!this.range && !this.multiple) {\n                this.emitChosenDate(date)\n            } else if (this.range) {\n                this.handleSelectRangeDate(date)\n            } else if (this.multiple) {\n                this.selectMultipleDates(date)\n            }\n        },\n\n        /*\n         * Emit select event with chosen date as payload\n         */\n        emitChosenDate(day) {\n            if (this.disabled) return\n\n            if (!this.multiple) {\n                if (this.selectableDate(day)) {\n                    this.$emit('input', day)\n                }\n            } else {\n                this.selectMultipleDates(day)\n            }\n        },\n\n        /*\n        * If both begin and end dates are set, reset the end date and set the begin date.\n        * If only begin date is selected, emit an array of the begin date and the new date.\n        * If not set, only set the begin date.\n        */\n        handleSelectRangeDate(date) {\n            if (this.disabled) return\n            if (this.selectedBeginDate && this.selectedEndDate) {\n                this.selectedBeginDate = date\n                this.selectedEndDate = undefined\n                this.$emit('range-start', date)\n            } else if (this.selectedBeginDate && !this.selectedEndDate) {\n                if (this.selectedBeginDate > date) {\n                    this.selectedEndDate = this.selectedBeginDate\n                    this.selectedBeginDate = date\n                } else {\n                    this.selectedEndDate = date\n                }\n                this.$emit('range-end', date)\n                this.$emit('input', [this.selectedBeginDate, this.selectedEndDate])\n            } else {\n                this.selectedBeginDate = date\n                this.$emit('range-start', date)\n            }\n        },\n\n        setRangeHoverEndDate(day) {\n            if (this.range) {\n                this.hoveredEndDate = day\n            }\n        },\n\n        changeFocus(month, inc) {\n            const nextMonth = month\n            nextMonth.setMonth(month.getMonth() + inc)\n            this.$emit('change-focus', nextMonth)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerMonth.vue"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerTable.vue",
      "content": "<template>\n    <section class=\"datepicker-table\">\n        <header class=\"datepicker-header\">\n            <div\n                v-for=\"(day, index) in visibleDayNames\"\n                :key=\"index\"\n                class=\"datepicker-cell\">\n                <span>{{ day }}</span>\n            </div>\n        </header>\n        <div class=\"datepicker-body\" :class=\"{'has-events':hasEvents}\">\n            <b-datepicker-table-row\n                v-for=\"(week, index) in weeksInThisMonth\"\n                :key=\"index\"\n                :selected-date=\"value\"\n                :day=\"focused.day\"\n                :week=\"week\"\n                :month=\"focused.month\"\n                :min-date=\"minDate\"\n                :max-date=\"maxDate\"\n                :disabled=\"disabled\"\n                :unselectable-dates=\"unselectableDates\"\n                :unselectable-days-of-week=\"unselectableDaysOfWeek\"\n                :selectable-dates=\"selectableDates\"\n                :events=\"eventsInThisWeek(week)\"\n                :indicators=\"indicators\"\n                :date-creator=\"dateCreator\"\n                :nearby-month-days=\"nearbyMonthDays\"\n                :nearby-selectable-month-days=\"nearbySelectableMonthDays\"\n                :show-week-number=\"showWeekNumber\"\n                :week-number-clickable=\"weekNumberClickable\"\n                :first-day-of-week=\"firstDayOfWeek\"\n                :rules-for-first-week=\"rulesForFirstWeek\"\n                :range=\"range\"\n                :hovered-date-range=\"hoveredDateRange\"\n                @select=\"updateSelectedDate\"\n                @rangeHoverEndDate=\"setRangeHoverEndDate\"\n                :multiple=\"multiple\"\n                @change-focus=\"changeFocus\"/>\n        </div>\n    </section>\n</template>\n\n<script>\nimport DatepickerTableRow from '@/components/datepicker/DatepickerTableRow'\nimport { isDefined } from '@/utils/helpers'\n\nexport default {\n    name: 'BDatepickerTable',\n    components: {\n        [DatepickerTableRow.name]: DatepickerTableRow\n    },\n    props: {\n        value: {\n            type: [Date, Array]\n        },\n        dayNames: Array,\n        monthNames: Array,\n        firstDayOfWeek: Number,\n        events: Array,\n        indicators: String,\n        minDate: Date,\n        maxDate: Date,\n        focused: Object,\n        disabled: Boolean,\n        dateCreator: Function,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        nearbyMonthDays: Boolean,\n        nearbySelectableMonthDays: Boolean,\n        showWeekNumber: Boolean,\n        weekNumberClickable: Boolean,\n        rulesForFirstWeek: Number,\n        range: Boolean,\n        multiple: Boolean\n    },\n    data() {\n        return {\n            selectedBeginDate: undefined,\n            selectedEndDate: undefined,\n            hoveredEndDate: undefined\n        }\n    },\n    computed: {\n        multipleSelectedDates: {\n            get() {\n                return this.multiple && this.value ? this.value : []\n            },\n            set(value) {\n                this.$emit('input', value)\n            }\n        },\n        visibleDayNames() {\n            const visibleDayNames = []\n            let index = this.firstDayOfWeek\n            while (visibleDayNames.length < this.dayNames.length) {\n                const currentDayName = this.dayNames[(index % this.dayNames.length)]\n                visibleDayNames.push(currentDayName)\n                index++\n            }\n            if (this.showWeekNumber) visibleDayNames.unshift('')\n            return visibleDayNames\n        },\n\n        hasEvents() {\n            return this.events && this.events.length\n        },\n\n        /*\n        * Return array of all events in the specified month\n        */\n        eventsInThisMonth() {\n            if (!this.events) return []\n\n            const monthEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                let event = this.events[i]\n\n                if (!event.hasOwnProperty('date')) {\n                    event = { date: event }\n                }\n                if (!event.hasOwnProperty('type')) {\n                    event.type = 'is-primary'\n                }\n                if (\n                    event.date.getMonth() === this.focused.month &&\n                    event.date.getFullYear() === this.focused.year\n                ) {\n                    monthEvents.push(event)\n                }\n            }\n\n            return monthEvents\n        },\n        /*\n        * Return array of all weeks in the specified month\n        */\n        weeksInThisMonth() {\n            this.validateFocusedDay()\n            const month = this.focused.month\n            const year = this.focused.year\n            const weeksInThisMonth = []\n\n            let startingDay = 1\n\n            while (weeksInThisMonth.length < 6) {\n                const newWeek = this.weekBuilder(startingDay, month, year)\n                weeksInThisMonth.push(newWeek)\n                startingDay += 7\n            }\n\n            return weeksInThisMonth\n        },\n        hoveredDateRange() {\n            if (!this.range) {\n                return []\n            }\n            if (!isNaN(this.selectedEndDate)) {\n                return []\n            }\n            if (this.hoveredEndDate < this.selectedBeginDate) {\n                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)\n            }\n            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)\n        }\n    },\n    methods: {\n        /*\n        * Emit input event with selected date as payload for v-model in parent\n        */\n        updateSelectedDate(date) {\n            if (!this.range && !this.multiple) {\n                this.$emit('input', date)\n            } else if (this.range) {\n                this.handleSelectRangeDate(date)\n            } else if (this.multiple) {\n                this.handleSelectMultipleDates(date)\n            }\n        },\n\n        /*\n        * If both begin and end dates are set, reset the end date and set the begin date.\n        * If only begin date is selected, emit an array of the begin date and the new date.\n        * If not set, only set the begin date.\n        */\n        handleSelectRangeDate(date) {\n            if (this.selectedBeginDate && this.selectedEndDate) {\n                this.selectedBeginDate = date\n                this.selectedEndDate = undefined\n                this.$emit('range-start', date)\n            } else if (this.selectedBeginDate && !this.selectedEndDate) {\n                if (this.selectedBeginDate > date) {\n                    this.selectedEndDate = this.selectedBeginDate\n                    this.selectedBeginDate = date\n                } else {\n                    this.selectedEndDate = date\n                }\n                this.$emit('range-end', date)\n                this.$emit('input', [this.selectedBeginDate, this.selectedEndDate])\n            } else {\n                this.selectedBeginDate = date\n                this.$emit('range-start', date)\n            }\n        },\n\n        /*\n        * If selected date already exists list of selected dates, remove it from the list\n        * Otherwise, add date to list of selected dates\n        */\n        handleSelectMultipleDates(date) {\n            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>\n                selectedDate.getDate() === date.getDate() &&\n                selectedDate.getFullYear() === date.getFullYear() &&\n                selectedDate.getMonth() === date.getMonth()\n            )\n            if (multipleSelect.length) {\n                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>\n                    selectedDate.getDate() !== date.getDate() ||\n                    selectedDate.getFullYear() !== date.getFullYear() ||\n                    selectedDate.getMonth() !== date.getMonth()\n                )\n            } else {\n                this.multipleSelectedDates = [...this.multipleSelectedDates, date]\n            }\n        },\n\n        /*\n         * Return array of all days in the week that the startingDate is within\n         */\n        weekBuilder(startingDate, month, year) {\n            const thisMonth = new Date(year, month)\n\n            const thisWeek = []\n\n            const dayOfWeek = new Date(year, month, startingDate).getDay()\n\n            const end = dayOfWeek >= this.firstDayOfWeek\n                ? (dayOfWeek - this.firstDayOfWeek)\n                : ((7 - this.firstDayOfWeek) + dayOfWeek)\n\n            let daysAgo = 1\n            for (let i = 0; i < end; i++) {\n                thisWeek.unshift(new Date(\n                    thisMonth.getFullYear(),\n                    thisMonth.getMonth(),\n                    startingDate - daysAgo)\n                )\n                daysAgo++\n            }\n\n            thisWeek.push(new Date(year, month, startingDate))\n\n            let daysForward = 1\n            while (thisWeek.length < 7) {\n                thisWeek.push(new Date(year, month, startingDate + daysForward))\n                daysForward++\n            }\n\n            return thisWeek\n        },\n\n        validateFocusedDay() {\n            const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day)\n            if (this.selectableDate(focusedDate)) return\n\n            let day = 0\n            // Number of days in the current month\n            const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate()\n            let firstFocusable = null\n            while (!firstFocusable && ++day < monthDays) {\n                const date = new Date(this.focused.year, this.focused.month, day)\n                if (this.selectableDate(date)) {\n                    firstFocusable = focusedDate\n\n                    const focused = {\n                        day: date.getDate(),\n                        month: date.getMonth(),\n                        year: date.getFullYear()\n                    }\n                    this.$emit('update:focused', focused)\n                }\n            }\n        },\n\n        /*\n         * Check that selected day is within earliest/latest params and\n         * is within this month\n         */\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {\n                validity.push(day.getMonth() === this.focused.month)\n            }\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getDate() === enabledDate.getDate() &&\n                            day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getDate() !== disabledDate.getDate() ||\n                                day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n\n        eventsInThisWeek(week) {\n            return this.eventsInThisMonth.filter((event) => {\n                const stripped = new Date(Date.parse(event.date))\n                stripped.setHours(0, 0, 0, 0)\n                const timed = stripped.getTime()\n\n                return week.some((weekDate) => weekDate.getTime() === timed)\n            })\n        },\n\n        setRangeHoverEndDate(day) {\n            this.hoveredEndDate = day\n        },\n\n        changeFocus(day) {\n            const focused = {\n                day: day.getDate(),\n                month: day.getMonth(),\n                year: day.getFullYear()\n            }\n            this.$emit('update:focused', focused)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerTable.vue"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerTableRow.vue",
      "content": "<template>\n    <div class=\"datepicker-row\">\n        <a\n            class=\"datepicker-cell is-week-number\"\n            :class=\"{'is-clickable': weekNumberClickable }\"\n            v-if=\"showWeekNumber\"\n            @click.prevent=\"clickWeekNumber(getWeekNumber(week[6]))\">\n            <span>{{ getWeekNumber(week[6]).week }}</span>\n        </a>\n        <template v-for=\"(weekDay, index) in week\">\n            <a\n                :ref=\"`day-${weekDay.getMonth()}-${weekDay.getDate()}`\"\n                v-if=\"selectableDate(weekDay) && !disabled\"\n                :key=\"index\"\n                :class=\"classObject(weekDay)\"\n                class=\"datepicker-cell\"\n                role=\"button\"\n                href=\"#\"\n                :disabled=\"disabled\"\n                @click.prevent=\"emitChosenDate(weekDay)\"\n                @mouseenter=\"setRangeHoverEndDate(weekDay)\"\n                @keydown=\"manageKeydown($event, weekDay)\"\n                :tabindex=\"day === weekDay.getDate() && month === weekDay.getMonth() ? null : -1\">\n                <span>{{ weekDay.getDate() }}</span>\n                <div class=\"events\" v-if=\"eventsDateMatch(weekDay)\">\n                    <div\n                        class=\"event\"\n                        :class=\"event.type\"\n                        v-for=\"(event, index) in eventsDateMatch(weekDay)\"\n                        :key=\"index\"/>\n                </div>\n            </a>\n            <div\n                v-else\n                :key=\"index\"\n                :class=\"classObject(weekDay)\"\n                class=\"datepicker-cell\">\n                <span>{{ weekDay.getDate() }}</span>\n                <div class=\"events\" v-if=\"eventsDateMatch(weekDay)\">\n                    <div\n                        class=\"event\"\n                        :class=\"event.type\"\n                        v-for=\"(event, index) in eventsDateMatch(weekDay)\"\n                        :key=\"index\"/>\n                </div>\n            </div>\n        </template>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'BDatepickerTableRow',\n    inject: {\n        $datepicker: { name: '$datepicker', default: false }\n    },\n    props: {\n        selectedDate: {\n            type: [Date, Array]\n        },\n        hoveredDateRange: Array,\n        day: {\n            type: Number\n        },\n        week: {\n            type: Array,\n            required: true\n        },\n        month: {\n            type: Number,\n            required: true\n        },\n        minDate: Date,\n        maxDate: Date,\n        disabled: Boolean,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        events: Array,\n        indicators: String,\n        dateCreator: Function,\n        nearbyMonthDays: Boolean,\n        nearbySelectableMonthDays: Boolean,\n        showWeekNumber: Boolean,\n        weekNumberClickable: Boolean,\n        range: Boolean,\n        multiple: Boolean,\n        rulesForFirstWeek: Number,\n        firstDayOfWeek: Number\n    },\n    watch: {\n        day(day) {\n            const refName = `day-${this.month}-${day}`\n            this.$nextTick(() => {\n                if (this.$refs[refName] && this.$refs[refName].length > 0) {\n                    if (this.$refs[refName][0]) {\n                        this.$refs[refName][0].focus()\n                    }\n                }\n            }) // $nextTick needed when month is changed\n        }\n    },\n    methods: {\n        firstWeekOffset(year, dow, doy) {\n            // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            const fwd = 7 + dow - doy\n            // first-week day local weekday -- which local weekday is fwd\n            const firstJanuary = new Date(year, 0, fwd)\n            const fwdlw = (7 + firstJanuary.getDay() - dow) % 7\n            return -fwdlw + fwd - 1\n        },\n        daysInYear(year) {\n            return this.isLeapYear(year) ? 366 : 365\n        },\n        isLeapYear(year) {\n            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\n        },\n        getSetDayOfYear(input) {\n            return Math.round((input - new Date(input.getFullYear(), 0, 1)) / 864e5) + 1\n        },\n        weeksInYear(year, dow, doy) {\n            const weekOffset = this.firstWeekOffset(year, dow, doy)\n            const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy)\n            return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7\n        },\n        getWeekNumber(mom) {\n            const dow = this.firstDayOfWeek // first day of week\n            // Rules for the first week : 1 for the 1st January, 4 for the 4th January\n            const doy = this.rulesForFirstWeek\n            const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy)\n            const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1\n            let resWeek\n            let resYear\n            if (week < 1) {\n                resYear = mom.getFullYear() - 1\n                resWeek = week + this.weeksInYear(resYear, dow, doy)\n            } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {\n                resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy)\n                resYear = mom.getFullYear() + 1\n            } else {\n                resYear = mom.getFullYear()\n                resWeek = week\n            }\n            return {week: resWeek, year: resYear}\n        },\n        clickWeekNumber(weekData) {\n            if (this.weekNumberClickable) {\n                this.$datepicker.$emit('week-number-click', weekData.week, weekData.year)\n            }\n        },\n        /*\n         * Check that selected day is within earliest/latest params and\n         * is within this month\n         */\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {\n                validity.push(day.getMonth() === this.month)\n            }\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getDate() === enabledDate.getDate() &&\n                            day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getDate() !== disabledDate.getDate() ||\n                                day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n\n        /*\n        * Emit select event with chosen date as payload\n        */\n        emitChosenDate(day) {\n            if (this.disabled) return\n\n            if (this.selectableDate(day)) {\n                this.$emit('select', day)\n            }\n        },\n\n        eventsDateMatch(day) {\n            if (!this.events || !this.events.length) return false\n\n            const dayEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                if (this.events[i].date.getDay() === day.getDay()) {\n                    dayEvents.push(this.events[i])\n                }\n            }\n\n            if (!dayEvents.length) {\n                return false\n            }\n\n            return dayEvents\n        },\n\n        /*\n        * Build classObject for cell using validations\n        */\n        classObject(day) {\n            function dateMatch(dateOne, dateTwo, multiple) {\n                // if either date is null or undefined, return false\n                // if using multiple flag, return false\n                if (!dateOne || !dateTwo || multiple) {\n                    return false\n                }\n\n                if (Array.isArray(dateTwo)) {\n                    return dateTwo.some((date) => (\n                        dateOne.getDate() === date.getDate() &&\n                        dateOne.getFullYear() === date.getFullYear() &&\n                        dateOne.getMonth() === date.getMonth()\n                    ))\n                }\n                return (dateOne.getDate() === dateTwo.getDate() &&\n                    dateOne.getFullYear() === dateTwo.getFullYear() &&\n                    dateOne.getMonth() === dateTwo.getMonth())\n            }\n\n            function dateWithin(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || multiple) { return false }\n\n                return dateOne > dates[0] && dateOne < dates[1]\n            }\n\n            return {\n                'is-selected': dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple),\n                'is-first-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.selectedDate) && this.selectedDate[0],\n                        this.multiple\n                    ),\n                'is-within-selected':\n                    dateWithin(day, this.selectedDate, this.multiple),\n                'is-last-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.selectedDate) && this.selectedDate[1],\n                        this.multiple\n                    ),\n                'is-within-hovered-range':\n                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&\n                    (dateMatch(day, this.hoveredDateRange) ||\n                        dateWithin(day, this.hoveredDateRange)),\n                'is-first-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]\n                ),\n                'is-within-hovered':\n                    dateWithin(day, this.hoveredDateRange),\n                'is-last-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]\n                ),\n                'is-today': dateMatch(day, this.dateCreator()),\n                'is-selectable': this.selectableDate(day) && !this.disabled,\n                'is-unselectable': !this.selectableDate(day) || this.disabled,\n                'is-invisible': !this.nearbyMonthDays && day.getMonth() !== this.month,\n                'is-nearby': this.nearbySelectableMonthDays && day.getMonth() !== this.month,\n                'has-event': this.eventsDateMatch(day),\n                [this.indicators]: this.eventsDateMatch(day)\n            }\n        },\n        setRangeHoverEndDate(day) {\n            if (this.range) {\n                this.$emit('rangeHoverEndDate', day)\n            }\n        },\n\n        manageKeydown(event, weekDay) {\n            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys\n            const { key } = event\n            let preventDefault = true\n            switch (key) {\n                case 'Tab': {\n                    preventDefault = false\n                    break\n                }\n\n                case ' ':\n                case 'Space':\n                case 'Spacebar':\n                case 'Enter': {\n                    this.emitChosenDate(weekDay)\n                    break\n                }\n\n                case 'ArrowLeft':\n                case 'Left': {\n                    this.changeFocus(weekDay, -1)\n                    break\n                }\n                case 'ArrowRight':\n                case 'Right': {\n                    this.changeFocus(weekDay, 1)\n                    break\n                }\n                case 'ArrowUp':\n                case 'Up': {\n                    this.changeFocus(weekDay, -7)\n                    break\n                }\n                case 'ArrowDown':\n                case 'Down': {\n                    this.changeFocus(weekDay, 7)\n                    break\n                }\n            }\n\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        },\n\n        changeFocus(day, inc) {\n            const nextDay = new Date(day.getTime())\n            nextDay.setDate(day.getDate() + inc)\n            while (\n                (!this.minDate || nextDay > this.minDate) &&\n                (!this.maxDate || nextDay < this.maxDate) &&\n                !this.selectableDate(nextDay)\n            ) {\n                nextDay.setDate(nextDay.getDate() + Math.sign(inc))\n            }\n            this.setRangeHoverEndDate(nextDay)\n            this.$emit('change-focus', nextDay)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerTableRow.vue"
    },
    {
      "type": "registry:component",
      "target": "components/datetimepicker/Datetimepicker.vue",
      "content": "<template>\n    <b-datepicker\n        v-if=\"!isMobile || inline\"\n        ref=\"datepicker\"\n        v-model=\"computedValue\"\n        v-bind=\"datepicker\"\n        :rounded=\"rounded\"\n        :open-on-focus=\"openOnFocus\"\n        :position=\"position\"\n        :loading=\"loading\"\n        :inline=\"inline\"\n        :editable=\"editable\"\n        :expanded=\"expanded\"\n        :close-on-click=\"false\"\n        :first-day-of-week=\"firstDayOfWeek\"\n        :rules-for-first-week=\"rulesForFirstWeek\"\n        :date-formatter=\"defaultDatetimeFormatter\"\n        :date-parser=\"defaultDatetimeParser\"\n        :min-date=\"minDate\"\n        :max-date=\"maxDate\"\n        :nearby-month-days=\"nearbyMonthDays\"\n        :icon=\"icon\"\n        :icon-right=\"iconRight\"\n        :icon-right-clickable=\"iconRightClickable\"\n        :icon-pack=\"iconPack\"\n        :size=\"datepickerSize\"\n        :placeholder=\"placeholder\"\n        :horizontal-time-picker=\"horizontalTimePicker\"\n        :range=\"false\"\n        :disabled=\"disabled\"\n        :mobile-native=\"isMobileNative\"\n        :locale=\"locale\"\n        :focusable=\"focusable\"\n        :append-to-body=\"appendToBody\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @active-change=\"onActiveChange\"\n        @icon-right-click=\"$emit('icon-right-click')\"\n        @change-month=\"$emit('change-month', $event)\"\n        @change-year=\"$emit('change-year', $event)\">\n        <nav class=\"level is-mobile\">\n            <div\n                class=\"level-item has-text-centered\"\n                v-if=\"$slots.left !== undefined\">\n                <slot name=\"left\" />\n            </div>\n            <div class=\"level-item has-text-centered\">\n                <b-timepicker\n                    ref=\"timepicker\"\n                    v-bind=\"timepicker\"\n                    v-model=\"computedValue\"\n                    inline\n                    :editable=\"editable\"\n                    :min-time=\"minTime\"\n                    :max-time=\"maxTime\"\n                    :size=\"timepickerSize\"\n                    :disabled=\"timepickerDisabled\"\n                    :focusable=\"focusable\"\n                    :mobile-native=\"isMobileNative\"\n                    :locale=\"locale\"\n                />\n            </div>\n            <div\n                class=\"level-item has-text-centered\"\n                v-if=\"$slots.right !== undefined\">\n                <slot name=\"right\" />\n            </div>\n        </nav>\n    </b-datepicker>\n    <b-input\n        v-else\n        ref=\"input\"\n        type=\"datetime-local\"\n        autocomplete=\"off\"\n        :value=\"formatNative(computedValue)\"\n        :placeholder=\"placeholder\"\n        :size=\"size\"\n        :icon=\"icon\"\n        :icon-pack=\"iconPack\"\n        :rounded=\"rounded\"\n        :loading=\"loading\"\n        :max=\"formatNative(maxDate)\"\n        :min=\"formatNative(minDate)\"\n        :disabled=\"disabled\"\n        :readonly=\"false\"\n        v-bind=\"$attrs\"\n        :use-html5-validation=\"useHtml5Validation\"\n        @change.native=\"onChangeNativePicker\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"/>\n</template>\n\n<script>\nimport FormElementMixin from '@/utils/FormElementMixin'\nimport { isMobile, matchWithGroups } from '@/utils/helpers'\nimport config from '@/utils/config'\n\nimport Datepicker from '@/components/datepicker/Datepicker'\nimport Timepicker from '@/components/timepicker/Timepicker'\n\nconst AM = 'AM'\nconst PM = 'PM'\nexport default {\n    name: 'BDatetimepicker',\n    components: {\n        [Datepicker.name]: Datepicker,\n        [Timepicker.name]: Timepicker\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: {\n            type: Date\n        },\n        editable: {\n            type: Boolean,\n            default: false\n        },\n        placeholder: String,\n        horizontalTimePicker: Boolean,\n        disabled: Boolean,\n        firstDayOfWeek: {\n            type: Number,\n            default: () => {\n                if (typeof config.defaultFirstDayOfWeek === 'number') {\n                    return config.defaultFirstDayOfWeek\n                } else {\n                    return 0\n                }\n            }\n        },\n        rulesForFirstWeek: {\n            type: Number,\n            default: () => 4\n        },\n        icon: String,\n        iconRight: String,\n        iconRightClickable: Boolean,\n        iconPack: String,\n        inline: Boolean,\n        openOnFocus: Boolean,\n        position: String,\n        mobileNative: {\n            type: Boolean,\n            default: true\n        },\n        minDatetime: Date,\n        maxDatetime: Date,\n        nearbyMonthDays: {\n            type: Boolean,\n            default: config.defaultDatepickerNearbyMonthDays\n        },\n        datetimeFormatter: {\n            type: Function\n        },\n        datetimeParser: {\n            type: Function\n        },\n        datetimeCreator: {\n            type: Function,\n            default: (date) => {\n                if (typeof config.defaultDatetimeCreator === 'function') {\n                    return config.defaultDatetimeCreator(date)\n                } else {\n                    return date\n                }\n            }\n        },\n        datepicker: Object,\n        timepicker: Object,\n        tzOffset: {\n            type: Number,\n            default: 0\n        },\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        appendToBody: Boolean\n    },\n    data() {\n        return {\n            newValue: this.adjustValue(this.value)\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.newValue\n            },\n            set(value) {\n                if (value) {\n                    let val = new Date(value.getTime())\n                    if (this.newValue) {\n                        // restore time part\n                        if ((value.getDate() !== this.newValue.getDate() ||\n                            value.getMonth() !== this.newValue.getMonth() ||\n                            value.getFullYear() !== this.newValue.getFullYear()) &&\n                            value.getHours() === 0 &&\n                            value.getMinutes() === 0 &&\n                            value.getSeconds() === 0) {\n                            val.setHours(this.newValue.getHours(),\n                                this.newValue.getMinutes(),\n                                this.newValue.getSeconds(), 0)\n                        }\n                    } else {\n                        val = this.datetimeCreator(value)\n                    }\n                    // check min and max range\n                    if (this.minDatetime && val < this.adjustValue(this.minDatetime)) {\n                        val = this.adjustValue(this.minDatetime)\n                    } else if (this.maxDatetime && val > this.adjustValue(this.maxDatetime)) {\n                        val = this.adjustValue(this.maxDatetime)\n                    }\n                    this.newValue = new Date(val.getTime())\n                } else {\n                    this.newValue = this.adjustValue(value)\n                }\n                var adjustedValue = this.adjustValue(this.newValue, true) // reverse adjust\n                this.$emit('input', adjustedValue)\n            }\n        },\n        localeOptions() {\n            return new Intl.DateTimeFormat(this.locale, {\n                year: 'numeric',\n                month: 'numeric',\n                day: 'numeric',\n                hour: 'numeric',\n                minute: 'numeric',\n                second: this.enableSeconds() ? 'numeric' : undefined\n            }).resolvedOptions()\n        },\n        dtf() {\n            return new Intl.DateTimeFormat(this.locale, {\n                year: this.localeOptions.year || 'numeric',\n                month: this.localeOptions.month || 'numeric',\n                day: this.localeOptions.day || 'numeric',\n                hour: this.localeOptions.hour || 'numeric',\n                minute: this.localeOptions.minute || 'numeric',\n                second: this.enableSeconds() ? this.localeOptions.second || 'numeric' : undefined,\n                hourCycle: !this.isHourFormat24() ? 'h12' : 'h23'\n            })\n        },\n        isMobileNative() {\n            return this.mobileNative && this.tzOffset === 0\n        },\n        isMobile() {\n            return this.isMobileNative && isMobile.any()\n        },\n        minDate() {\n            if (!this.minDatetime) {\n                return this.datepicker ? this.adjustValue(this.datepicker.minDate) : null\n            }\n            const adjMinDatetime = this.adjustValue(this.minDatetime)\n            return new Date(adjMinDatetime.getFullYear(),\n                adjMinDatetime.getMonth(),\n                adjMinDatetime.getDate(), 0, 0, 0, 0)\n        },\n        maxDate() {\n            if (!this.maxDatetime) {\n                return this.datepicker ? this.adjustValue(this.datepicker.maxDate) : null\n            }\n            const adjMaxDatetime = this.adjustValue(this.maxDatetime)\n            return new Date(adjMaxDatetime.getFullYear(),\n                adjMaxDatetime.getMonth(),\n                adjMaxDatetime.getDate(), 0, 0, 0, 0)\n        },\n        minTime() {\n            if (!this.minDatetime || (this.newValue === null || typeof this.newValue === 'undefined')) {\n                return this.timepicker ? this.adjustValue(this.timepicker.minTime) : null\n            }\n            const adjMinDatetime = this.adjustValue(this.minDatetime)\n            if (adjMinDatetime.getFullYear() === this.newValue.getFullYear() &&\n                adjMinDatetime.getMonth() === this.newValue.getMonth() &&\n                adjMinDatetime.getDate() === this.newValue.getDate()) {\n                return adjMinDatetime\n            }\n        },\n        maxTime() {\n            if (!this.maxDatetime || (this.newValue === null || typeof this.newValue === 'undefined')) {\n                return this.timepicker ? this.adjustValue(this.timepicker.maxTime) : null\n            }\n            const adjMaxDatetime = this.adjustValue(this.maxDatetime)\n            if (adjMaxDatetime.getFullYear() === this.newValue.getFullYear() &&\n                adjMaxDatetime.getMonth() === this.newValue.getMonth() &&\n                adjMaxDatetime.getDate() === this.newValue.getDate()) {\n                return adjMaxDatetime\n            }\n        },\n        datepickerSize() {\n            return this.datepicker && this.datepicker.size\n                ? this.datepicker.size : this.size\n        },\n        timepickerSize() {\n            return this.timepicker && this.timepicker.size\n                ? this.timepicker.size : this.size\n        },\n        timepickerDisabled() {\n            return this.timepicker && this.timepicker.disabled\n                ? this.timepicker.disabled : this.disabled\n        }\n    },\n    watch: {\n        value() {\n            this.newValue = this.adjustValue(this.value)\n        },\n        tzOffset() {\n            this.newValue = this.adjustValue(this.value)\n        }\n    },\n    methods: {\n        enableSeconds() {\n            if (this.$refs.timepicker) {\n                return this.$refs.timepicker.enableSeconds\n            }\n            return false\n        },\n        isHourFormat24() {\n            if (this.$refs.timepicker) {\n                return this.$refs.timepicker.isHourFormat24\n            }\n            return !this.localeOptions.hour12\n        },\n        adjustValue(value, reverse = false) {\n            if (!value) return value\n            if (reverse) {\n                return new Date(value.getTime() - this.tzOffset * 60000)\n            } else {\n                return new Date(value.getTime() + this.tzOffset * 60000)\n            }\n        },\n        defaultDatetimeParser(date) {\n            if (typeof this.datetimeParser === 'function') {\n                return this.datetimeParser(date)\n            } else if (typeof config.defaultDatetimeParser === 'function') {\n                return config.defaultDatetimeParser(date)\n            } else {\n                if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                    let dayPeriods = [AM, PM, AM.toLowerCase(), PM.toLowerCase()]\n                    if (this.$refs.timepicker) {\n                        dayPeriods.push(this.$refs.timepicker.amString)\n                        dayPeriods.push(this.$refs.timepicker.pmString)\n                    }\n                    const parts = this.dtf.formatToParts(new Date())\n                    const formatRegex = parts.map((part, idx) => {\n                        if (part.type === 'literal') {\n                            if (idx + 1 < parts.length && parts[idx + 1].type === 'hour') {\n                                return `[^\\\\d]+`\n                            }\n                            return part.value.replace(/ /g, '\\\\s?')\n                        } else if (part.type === 'dayPeriod') {\n                            return `((?!=<${part.type}>)(${dayPeriods.join('|')})?)`\n                        }\n                        return `((?!=<${part.type}>)\\\\d+)`\n                    }).join('')\n                    const datetimeGroups = matchWithGroups(formatRegex, date)\n\n                    // We do a simple validation for the group.\n                    // If it is not valid, it will fallback to Date.parse below\n                    if (\n                        datetimeGroups.year &&\n                        datetimeGroups.year.length === 4 &&\n                        datetimeGroups.month &&\n                        datetimeGroups.month <= 12 &&\n                        datetimeGroups.day &&\n                        datetimeGroups.day <= 31 &&\n                        datetimeGroups.hour &&\n                        datetimeGroups.hour >= 0 &&\n                        datetimeGroups.hour < 24 &&\n                        datetimeGroups.minute &&\n                        datetimeGroups.minute >= 0 &&\n                        datetimeGroups.minute <= 59\n                    ) {\n                        const d = new Date(\n                            datetimeGroups.year,\n                            datetimeGroups.month - 1,\n                            datetimeGroups.day,\n                            datetimeGroups.hour,\n                            datetimeGroups.minute,\n                            datetimeGroups.second || 0)\n                        return d\n                    }\n                }\n\n                return new Date(Date.parse(date))\n            }\n        },\n        defaultDatetimeFormatter(date) {\n            if (typeof this.datetimeFormatter === 'function') {\n                return this.datetimeFormatter(date)\n            } else if (typeof config.defaultDatetimeFormatter === 'function') {\n                return config.defaultDatetimeFormatter(date)\n            } else {\n                return this.dtf.format(date)\n            }\n        },\n        /*\n        * Parse date from string\n        */\n        onChangeNativePicker(event) {\n            const date = event.target.value\n            const s = date ? date.split(/\\D/) : []\n            if (s.length >= 5) {\n                const year = parseInt(s[0], 10)\n                const month = parseInt(s[1], 10) - 1\n                const day = parseInt(s[2], 10)\n                const hours = parseInt(s[3], 10)\n                const minutes = parseInt(s[4], 10)\n                // Seconds are omitted intentionally; they are unsupported by input\n                // type=datetime-local and cause the control to fail native validation\n                this.computedValue = new Date(year, month, day, hours, minutes)\n            } else {\n                this.computedValue = null\n            }\n        },\n        /*\n         * Emit 'active-change' on datepicker active state change\n         */\n        onActiveChange(value) {\n            this.$emit('active-change', value)\n        },\n        formatNative(value) {\n            const date = new Date(value)\n            if (value && !isNaN(date)) {\n                const year = date.getFullYear()\n                const month = date.getMonth() + 1\n                const day = date.getDate()\n                const hours = date.getHours()\n                const minutes = date.getMinutes()\n                const seconds = date.getSeconds()\n                return year + '-' +\n                    ((month < 10 ? '0' : '') + month) + '-' +\n                    ((day < 10 ? '0' : '') + day) + 'T' +\n                    ((hours < 10 ? '0' : '') + hours) + ':' +\n                    ((minutes < 10 ? '0' : '') + minutes) + ':' +\n                    ((seconds < 10 ? '0' : '') + seconds)\n            }\n            return ''\n        },\n        toggle() {\n            this.$refs.datepicker.toggle()\n        }\n    },\n    mounted() {\n        if (!this.isMobile || this.inline) {\n            // $refs attached, it's time to refresh datepicker (input)\n            if (this.newValue) {\n                this.$refs.datepicker.$forceUpdate()\n            }\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datetimepicker/Datetimepicker.vue"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/Dropdown.vue",
      "content": "<template>\n    <div\n        class=\"dropdown dropdown-menu-animation\"\n        ref=\"dropdown\"\n        :class=\"rootClasses\"\n        @mouseleave=\"isHoverable = false\"\n    >\n        <div\n            v-if=\"!inline\"\n            :tabindex=\"disabled ? false : triggerTabindex\"\n            ref=\"trigger\"\n            class=\"dropdown-trigger\"\n            @click=\"onClick\"\n            @contextmenu.prevent=\"onContextMenu\"\n            @mouseenter=\"onHover\"\n            @focus.capture=\"onFocus\"\n            @touchstart=\"onTouchStart\"\n            @touchmove=\"onTouchMove\"\n            @touchend=\"onTouchEnd\"\n            aria-haspopup=\"true\">\n            <slot name=\"trigger\" :active=\"isActive\"/>\n        </div>\n\n        <transition :name=\"animation\">\n            <div\n                v-if=\"isMobileModal\"\n                v-show=\"isActive\"\n                class=\"background\"\n                :aria-hidden=\"!isActive\"\n            />\n        </transition>\n        <transition :name=\"animation\">\n            <div\n                v-show=\"(!disabled && (isActive || isHoverable)) || inline\"\n                ref=\"dropdownMenu\"\n                class=\"dropdown-menu\"\n                :style=\"style\"\n                :aria-hidden=\"!isActive\"\n                v-trap-focus=\"trapFocus\">\n                <div\n                    class=\"dropdown-content\"\n                    :role=\"ariaRole\"\n                    :aria-modal=\"!inline\"\n                    :style=\"contentStyle\">\n                    <slot/>\n                </div>\n            </div>\n        </transition>\n    </div>\n</template>\n\n<script>\nimport trapFocus from '@/directives/trapFocus'\nimport config from '@/utils/config'\nimport { removeElement, createAbsoluteElement, isCustomElement, toCssWidth } from '@/utils/helpers'\nimport ProviderParentMixin from '@/utils/ProviderParentMixin'\n\nconst DEFAULT_CLOSE_OPTIONS = ['escape', 'outside']\n\nexport default {\n    name: 'BDropdown',\n    directives: {\n        trapFocus\n    },\n    mixins: [ProviderParentMixin('dropdown')],\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function],\n            default: null\n        },\n        disabled: Boolean,\n        inline: Boolean,\n        scrollable: Boolean,\n        maxHeight: {\n            type: [String, Number],\n            default: 200\n        },\n        position: {\n            type: String,\n            validator(value) {\n                return [\n                    'is-top-right',\n                    'is-top-left',\n                    'is-bottom-left',\n                    'is-bottom-right'\n                ].indexOf(value) > -1\n            }\n        },\n        triggers: {\n            type: Array,\n            default: () => ['click']\n        },\n        mobileModal: {\n            type: Boolean,\n            default: () => {\n                return config.defaultDropdownMobileModal\n            }\n        },\n        ariaRole: {\n            type: String,\n            validator(value) {\n                return [\n                    'menu',\n                    'list',\n                    'dialog'\n                ].indexOf(value) > -1\n            },\n            default: null\n        },\n        animation: {\n            type: String,\n            default: 'fade'\n        },\n        multiple: Boolean,\n        trapFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultTrapFocus\n            }\n        },\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        canClose: {\n            type: [Array, Boolean],\n            default: true\n        },\n        expanded: Boolean,\n        appendToBody: Boolean,\n        appendToBodyCopyParent: Boolean,\n        triggerTabindex: {\n            type: Number,\n            default: 0\n        }\n    },\n    data() {\n        return {\n            selected: this.value,\n            style: {},\n            isActive: false,\n            isHoverable: false,\n            maybeTap: false,\n            isTouchEnabled: false,\n            _bodyEl: undefined, // Used to append to body\n            timeOutID: null,\n            timeOutID2: null\n        }\n    },\n    computed: {\n        rootClasses() {\n            return [this.position, {\n                'is-disabled': this.disabled,\n                'is-hoverable': this.hoverable,\n                'is-inline': this.inline,\n                'is-active': this.isActive || this.inline,\n                'is-mobile-modal': this.isMobileModal,\n                'is-expanded': this.expanded,\n                'is-touch-enabled': this.isTouchEnabled\n            }]\n        },\n        isMobileModal() {\n            return this.mobileModal && !this.inline\n        },\n        cancelOptions() {\n            return typeof this.canClose === 'boolean'\n                ? this.canClose\n                    ? DEFAULT_CLOSE_OPTIONS\n                    : []\n                : this.canClose\n        },\n        contentStyle() {\n            return {\n                maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,\n                overflow: this.scrollable ? 'auto' : null\n            }\n        },\n        hoverable() {\n            return this.triggers.indexOf('hover') >= 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed set the new selected item.\n        */\n        value(value) {\n            this.selected = value\n        },\n\n        /**\n        * Emit event when isActive value is changed.\n        *\n        * Also resets `isTouchEnabled` when it turns inactive.\n        */\n        isActive(value) {\n            this.$emit('active-change', value)\n            if (!value) {\n                // delays to reset the touch enabled flag until the dropdown\n                // menu disappears to avoid glitches\n                // also takes care of chattering, e.g., repeated quick taps,\n                // otherwise the flag may become inconsistent with the actual\n                // state of the dropdown menu\n                this.timeOutID = setTimeout(() => {\n                    if (!this.isActive) {\n                        this.isTouchEnabled = false\n                    }\n                }, 250)\n            }\n            this.handleScroll()\n            if (this.appendToBody) {\n                this.$nextTick(() => {\n                    this.updateAppendToBody()\n                })\n            }\n        },\n\n        isHoverable(value) {\n            if (this.hoverable) {\n                this.$emit('active-change', value)\n            }\n        }\n    },\n    methods: {\n        handleScroll() {\n            if (typeof window === 'undefined') return\n\n            if (this.isMobileModal) {\n                if (this.isActive) {\n                    document.documentElement.classList.add('is-clipped-touch')\n                } else {\n                    document.documentElement.classList.remove('is-clipped-touch')\n                }\n            }\n        },\n\n        /**\n         * Click listener from DropdownItem.\n         *   1. Set new selected item.\n         *   2. Emit input event to update the user v-model.\n         *   3. Close the dropdown.\n         */\n        selectItem(value) {\n            if (this.multiple) {\n                if (this.selected) {\n                    if (this.selected.indexOf(value) === -1) {\n                        // Add value\n                        this.selected = [...this.selected, value]\n                    } else {\n                        // Remove value\n                        this.selected = this.selected.filter((val) => val !== value)\n                    }\n                } else {\n                    this.selected = [value]\n                }\n                this.$emit('change', this.selected)\n            } else {\n                if (this.selected !== value) {\n                    this.selected = value\n                    this.$emit('change', this.selected)\n                }\n            }\n            this.$emit('input', this.selected)\n            if (!this.multiple) {\n                this.isActive = !this.closeOnClick\n                if (this.hoverable && this.closeOnClick) {\n                    this.isHoverable = false\n                }\n            }\n        },\n\n        /**\n        * White-listed items to not close when clicked.\n        */\n        isInWhiteList(el) {\n            if (el === this.$refs.dropdownMenu) return true\n            if (el === this.$refs.trigger) return true\n            // All chidren from dropdown\n            if (this.$refs.dropdownMenu !== undefined) {\n                const children = this.$refs.dropdownMenu.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            // All children from trigger\n            if (this.$refs.trigger !== undefined) {\n                const children = this.$refs.trigger.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            return false\n        },\n\n        /**\n        * Close dropdown if clicked outside.\n        */\n        clickedOutside(event) {\n            if (this.cancelOptions.indexOf('outside') < 0) return\n            if (this.inline) return\n\n            const target = isCustomElement(this) ? event.composedPath()[0] : event.target\n            if (!this.isInWhiteList(target)) this.isActive = false\n        },\n\n        /**\n         * Keypress event that is bound to the document\n         */\n        keyPress({ key }) {\n            if (this.isActive && (key === 'Escape' || key === 'Esc')) {\n                if (this.cancelOptions.indexOf('escape') < 0) return\n                this.isActive = false\n            }\n        },\n\n        onClick() {\n            // hover precedes\n            if (this.triggers.indexOf('hover') !== -1) return\n            if (this.triggers.indexOf('click') < 0) return\n            this.toggle()\n        },\n        onContextMenu() {\n            if (this.triggers.indexOf('contextmenu') < 0) return\n            this.toggle()\n        },\n        onHover() {\n            if (this.triggers.indexOf('hover') < 0) return\n            // touch precedes\n            if (this.isTouchEnabled) return\n            this.isHoverable = true\n        },\n        // takes care of touch-enabled devices\n        // - does nothing if hover trigger is disabled\n        // - suppresses hover trigger by setting isTouchEnabled\n        // - handles only a tap; i.e., touchstart on the trigger immediately\n        //   folowed by touchend\n        onTouchStart() {\n            this.maybeTap = true\n        },\n        onTouchMove() {\n            this.maybeTap = false\n        },\n        onTouchEnd(e) {\n            if (this.triggers.indexOf('hover') === -1) return\n            if (!this.maybeTap) return\n            // tap on dropdown contents may happen without preventDefault\n            e.preventDefault()\n            this.maybeTap = false\n            this.isTouchEnabled = true\n            this.toggle()\n        },\n        onFocus() {\n            if (this.triggers.indexOf('focus') < 0) return\n            this.toggle()\n        },\n\n        /**\n        * Toggle dropdown if it's not disabled.\n        */\n        toggle() {\n            if (this.disabled) return\n\n            if (!this.isActive) {\n                // if not active, toggle after clickOutside event\n                // this fixes toggling programmatic\n                this.$nextTick(() => {\n                    const value = !this.isActive\n                    this.isActive = value\n                    // Vue 2.6.x ???\n                    this.timeOutID2 = setTimeout(() => (this.isActive = value))\n                })\n            } else {\n                this.isActive = !this.isActive\n            }\n        },\n\n        updateAppendToBody() {\n            const dropdown = this.$refs.dropdown\n            const dropdownMenu = this.$refs.dropdownMenu\n            const trigger = this.$refs.trigger\n            if (dropdownMenu && trigger) {\n                // update wrapper dropdown\n                const dropdownWrapper = this.$data._bodyEl.children[0]\n                dropdownWrapper.classList.forEach((item) => dropdownWrapper.classList.remove(item))\n                dropdownWrapper.classList.add('dropdown')\n                dropdownWrapper.classList.add('dropdown-menu-animation')\n                if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {\n                    dropdownWrapper.classList.add(this.$vnode.data.staticClass)\n                }\n                this.rootClasses.forEach((item) => {\n                    // skip position prop\n                    if (item && typeof item === 'object') {\n                        for (let key in item) {\n                            if (item[key]) {\n                                dropdownWrapper.classList.add(key)\n                            }\n                        }\n                    }\n                })\n                if (this.appendToBodyCopyParent) {\n                    const parentNode = this.$refs.dropdown.parentNode\n                    const parent = this.$data._bodyEl\n                    parent.classList.forEach((item) => parent.classList.remove(item))\n                    parentNode.classList.forEach((item) => {\n                        parent.classList.add(item)\n                    })\n                }\n                const rect = trigger.getBoundingClientRect()\n                let top = rect.top + window.scrollY\n                let left = rect.left + window.scrollX\n                if (!this.position || this.position.indexOf('bottom') >= 0) {\n                    top += trigger.clientHeight\n                } else {\n                    top -= dropdownMenu.clientHeight\n                }\n                if (this.position && this.position.indexOf('left') >= 0) {\n                    left -= (dropdownMenu.clientWidth - trigger.clientWidth)\n                }\n                this.style = {\n                    position: 'absolute',\n                    top: `${top}px`,\n                    left: `${left}px`,\n                    zIndex: '99',\n                    width: this.expanded ? `${dropdown.offsetWidth}px` : undefined\n                }\n            }\n        }\n    },\n    mounted() {\n        if (this.appendToBody) {\n            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu)\n            this.updateAppendToBody()\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('click', this.clickedOutside)\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('click', this.clickedOutside)\n            document.removeEventListener('keyup', this.keyPress)\n        }\n        if (this.appendToBody) {\n            removeElement(this.$data._bodyEl)\n        }\n        clearTimeout(this.timeOutID)\n        clearTimeout(this.timeOutID2)\n    }\n}\n</script>\n",
      "path": "src/components/dropdown/Dropdown.vue"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/DropdownItem.vue",
      "content": "<template>\n    <hr v-if=\"separator\" class=\"dropdown-divider\">\n    <a\n        v-else-if=\"!custom && !hasLink\"\n        class=\"dropdown-item\"\n        :class=\"anchorClasses\"\n        @click=\"selectItem\"\n        :role=\"ariaRoleItem\"\n        :tabindex=\"isFocusable ? 0 : null\">\n        <slot/>\n    </a>\n    <div\n        v-else\n        :class=\"itemClasses\"\n        @click=\"selectItem\"\n        :role=\"ariaRoleItem\"\n        :tabindex=\"isFocusable ? 0 : null\">\n        <slot/>\n    </div>\n</template>\n\n<script>\nimport InjectedChildMixin from '@/utils/InjectedChildMixin'\n\nexport default {\n    name: 'BDropdownItem',\n    mixins: [InjectedChildMixin('dropdown')],\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function],\n            default: null\n        },\n        separator: Boolean,\n        disabled: Boolean,\n        custom: Boolean,\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        paddingless: Boolean,\n        hasLink: Boolean,\n        ariaRole: {\n            type: String,\n            default: ''\n        }\n    },\n    computed: {\n        anchorClasses() {\n            return {\n                'is-disabled': this.parent.disabled || this.disabled,\n                'is-paddingless': this.paddingless,\n                'is-active': this.isActive\n            }\n        },\n        itemClasses() {\n            return {\n                'dropdown-item': !this.hasLink,\n                'is-disabled': this.disabled,\n                'is-paddingless': this.paddingless,\n                'is-active': this.isActive,\n                'has-link': this.hasLink\n            }\n        },\n        ariaRoleItem() {\n            return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null\n        },\n        isClickable() {\n            return !this.parent.disabled && !this.separator && !this.disabled && !this.custom\n        },\n        isActive() {\n            if (this.parent.selected === null) return false\n            if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0\n            return this.value === this.parent.selected\n        },\n        isFocusable() {\n            return this.hasLink ? false : this.focusable\n        }\n    },\n    methods: {\n        /**\n        * Click listener, select the item.\n        */\n        selectItem() {\n            if (!this.isClickable) return\n\n            this.parent.selectItem(this.value)\n            this.$emit('click')\n        }\n    }\n}\n</script>\n",
      "path": "src/components/dropdown/DropdownItem.vue"
    },
    {
      "type": "registry:component",
      "target": "components/field/Field.vue",
      "content": "<template>\n    <div class=\"field\" :class=\"rootClasses\">\n        <div\n            v-if=\"horizontal\"\n            class=\"field-label\"\n            :class=\"[customClass, fieldLabelSize]\">\n            <label\n                v-if=\"hasLabel\"\n                :for=\"labelFor\"\n                :class=\"customClass\"\n                class=\"label\" >\n                <slot v-if=\"$slots.label\" name=\"label\"/>\n                <template v-else>{{ label }}</template>\n            </label>\n        </div>\n        <template v-else>\n            <label\n                v-if=\"hasLabel\"\n                :for=\"labelFor\"\n                :class=\"customClass\"\n                class=\"label\">\n                <slot v-if=\"$slots.label\" name=\"label\"/>\n                <template v-else>{{ label }}</template>\n            </label>\n        </template>\n        <b-field-body\n            v-if=\"horizontal\"\n            :message=\"newMessage ? formattedMessage : ''\"\n            :type=\"newType\">\n            <slot/>\n        </b-field-body>\n        <div v-else-if=\"hasInnerField\" class=\"field-body\">\n            <b-field\n                :addons=\"false\"\n                :type=\"type\"\n                :class=\"innerFieldClasses\">\n                <slot/>\n            </b-field>\n        </div>\n        <template v-else>\n            <slot/>\n        </template>\n        <p\n            v-if=\"hasMessage && !horizontal\"\n            class=\"help\"\n            :class=\"newType\"\n        >\n            <slot\n                v-if=\"$slots.message\"\n                name=\"message\"\n                :messages=\"formattedMessage\"\n            />\n            <template v-else>\n                <template v-for=\"(mess, i) in formattedMessage\">\n                    {{ mess }}\n                    <br :key=\"i\" v-if=\"(i + 1) < formattedMessage.length\">\n                </template>\n            </template>\n        </p>\n    </div>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport FieldBody from '@/components/field/FieldBody'\n\nexport default {\n    name: 'BField',\n    components: {\n        [FieldBody.name]: FieldBody\n    },\n    provide() {\n        return {\n            'BField': this\n        }\n    },\n    inject: {\n        parent: {\n            from: 'BField',\n            default: false\n        }\n    }, // Used internally only when using Field in Field\n    props: {\n        type: [String, Object],\n        label: String,\n        labelFor: String,\n        message: [String, Array, Object],\n        grouped: Boolean,\n        groupMultiline: Boolean,\n        position: String,\n        expanded: Boolean,\n        horizontal: Boolean,\n        addons: {\n            type: Boolean,\n            default: true\n        },\n        customClass: String,\n        labelPosition: {\n            type: String,\n            default: () => { return config.defaultFieldLabelPosition }\n        }\n    },\n    data() {\n        return {\n            newType: this.type,\n            newMessage: this.message,\n            fieldLabelSize: null,\n            _isField: true // Used internally by Input and Select\n        }\n    },\n    computed: {\n        rootClasses() {\n            return [{\n                'is-expanded': this.expanded,\n                'is-horizontal': this.horizontal,\n                'is-floating-in-label': this.hasLabel && !this.horizontal &&\n                    this.labelPosition === 'inside',\n                'is-floating-label': this.hasLabel && !this.horizontal &&\n                    this.labelPosition === 'on-border'\n            },\n            this.numberInputClasses]\n        },\n        innerFieldClasses() {\n            return [\n                this.fieldType(),\n                this.newPosition,\n                {\n                    'is-grouped-multiline': this.groupMultiline\n                }\n            ]\n        },\n        hasInnerField() {\n            return this.grouped || this.groupMultiline || this.hasAddons()\n        },\n        /**\n        * Correct Bulma class for the side of the addon or group.\n        *\n        * This is not kept like the others (is-small, etc.),\n        * because since 'has-addons' is set automatically it\n        * doesn't make sense to teach users what addons are exactly.\n        */\n        newPosition() {\n            if (this.position === undefined) return\n\n            const position = this.position.split('-')\n            if (position.length < 1) return\n\n            const prefix = this.grouped\n                ? 'is-grouped-'\n                : 'has-addons-'\n\n            if (this.position) return prefix + position[1]\n        },\n        /**\n        * Formatted message in case it's an array\n        * (each element is separated by <br> tag)\n        */\n        formattedMessage() {\n            if (this.parent && this.parent.hasInnerField) {\n                return '' // Message will be displayed in parent field\n            }\n            if (typeof this.newMessage === 'string') {\n                return [this.newMessage]\n            }\n            let messages = []\n            if (Array.isArray(this.newMessage)) {\n                this.newMessage.forEach((message) => {\n                    if (typeof message === 'string') {\n                        messages.push(message)\n                    } else {\n                        for (let key in message) {\n                            if (message[key]) {\n                                messages.push(key)\n                            }\n                        }\n                    }\n                })\n            } else {\n                for (let key in this.newMessage) {\n                    if (this.newMessage[key]) {\n                        messages.push(key)\n                    }\n                }\n            }\n            return messages.filter((m) => { if (m) return m })\n        },\n        hasLabel() {\n            return this.label || this.$slots.label\n        },\n        hasMessage() {\n            return ((!this.parent || !this.parent.hasInnerField) && this.newMessage) ||\n                this.$slots.message\n        },\n        numberInputClasses() {\n            if (this.$slots.default) {\n                const numberinput = this.$slots.default.filter((node) => node.tag && node.tag.toLowerCase().indexOf('numberinput') >= 0)[0]\n                if (numberinput) {\n                    const classes = ['has-numberinput']\n                    const controlsPosition = numberinput.componentOptions.propsData.controlsPosition\n                    const size = numberinput.componentOptions.propsData.size\n                    if (controlsPosition) {\n                        classes.push(`has-numberinput-${controlsPosition}`)\n                    }\n                    if (size) {\n                        classes.push(`has-numberinput-${size}`)\n                    }\n                    return classes\n                }\n            }\n            return null\n        }\n    },\n    watch: {\n        /**\n        * Set internal type when prop change.\n        */\n        type(value) {\n            this.newType = value\n        },\n\n        /**\n        * Set internal message when prop change.\n        */\n        message(value) {\n            // we deep comparison here becase an innner Field of another Field\n            // receives the message as a brand new array every time, so simple\n            // identity check won't work and will end up with infinite\n            // recursions\n            // https://github.com/buefy/buefy/issues/4018#issuecomment-1985026234\n            if (JSON.stringify(value) !== JSON.stringify(this.newMessage)) {\n                this.newMessage = value\n            }\n        },\n\n        /**\n        * Set parent message if we use Field in Field.\n        */\n        newMessage(value) {\n            if (this.parent && this.parent.hasInnerField) {\n                if (!this.parent.type) {\n                    this.parent.newType = this.newType\n                }\n                if (!this.parent.message) {\n                    this.parent.newMessage = value\n                }\n            }\n        }\n    },\n    methods: {\n        /**\n        * Field has addons if there are more than one slot\n        * (element / component) in the Field.\n        * Or is grouped when prop is set.\n        * Is a method to be called when component re-render.\n        */\n        fieldType() {\n            if (this.grouped) return 'is-grouped'\n            if (this.hasAddons()) return 'has-addons'\n        },\n        hasAddons() {\n            let renderedNode = 0\n            if (this.$slots.default) {\n                renderedNode = this.$slots.default.reduce((i, node) => node.tag ? i + 1 : i, 0)\n            }\n            return (\n                renderedNode > 1 &&\n                this.addons &&\n                !this.horizontal\n            )\n        }\n    },\n    mounted() {\n        if (this.horizontal) {\n            // Bulma docs: .is-normal for any .input or .button\n            const elements = this.$el.querySelectorAll('.input, .select, .button, .textarea, .b-slider')\n            if (elements.length > 0) {\n                this.fieldLabelSize = 'is-normal'\n            }\n        }\n    }\n}\n\n</script>\n",
      "path": "src/components/field/Field.vue"
    },
    {
      "type": "registry:component",
      "target": "components/field/FieldBody.vue",
      "content": "<script>\nexport default {\n    name: 'BFieldBody',\n    props: {\n        message: {\n            type: [String, Array]\n        },\n        type: {\n            type: [String, Object]\n        }\n    },\n    render(createElement) {\n        let first = true\n        return createElement('div', { attrs: { 'class': 'field-body' } }, this.$slots.default.map((element) => {\n            // skip returns and comments\n            if (!element.tag) {\n                return element\n            }\n            let message\n            if (first) {\n                message = this.message\n                first = false\n            }\n            return createElement('b-field', { attrs: { type: this.type, message } }, [element])\n        }))\n    }\n}\n</script>\n",
      "path": "src/components/field/FieldBody.vue"
    },
    {
      "type": "registry:component",
      "target": "components/icon/Icon.vue",
      "content": "<template>\n    <span class=\"icon\" :class=\"[newType, size]\">\n        <i\n            v-if=\"!useIconComponent\"\n            :class=\"[newPack, newIcon, newCustomSize, customClass]\"/>\n\n        <component\n            v-else\n            :is=\"useIconComponent\"\n            :icon=\"[newPack, newIcon]\"\n            :size=\"newCustomSize\"\n            :class=\"[customClass]\"/>\n    </span>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport getIcons from '@/utils/icons'\n\nexport default {\n    name: 'BIcon',\n    props: {\n        type: [String, Object],\n        component: String,\n        pack: String,\n        icon: String,\n        size: String,\n        customSize: String,\n        customClass: String,\n        both: Boolean // This is used internally to show both MDI and FA icon\n    },\n    computed: {\n        iconConfig() {\n            let allIcons = getIcons()\n            return allIcons[this.newPack]\n        },\n        iconPrefix() {\n            if (this.iconConfig && this.iconConfig.iconPrefix) {\n                return this.iconConfig.iconPrefix\n            }\n            return ''\n        },\n        /**\n        * Internal icon name based on the pack.\n        * If pack is 'fa', gets the equivalent FA icon name of the MDI,\n        * internal icons are always MDI.\n        */\n        newIcon() {\n            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`\n        },\n        newPack() {\n            return this.pack || config.defaultIconPack\n        },\n        newType() {\n            if (!this.type) return\n\n            let splitType = []\n            if (typeof this.type === 'string') {\n                splitType = this.type.split('-')\n            } else {\n                for (let key in this.type) {\n                    if (this.type[key]) {\n                        splitType = key.split('-')\n                        break\n                    }\n                }\n            }\n            if (splitType.length <= 1) return\n\n            const [, ...type] = splitType\n            return `has-text-${type.join('-')}`\n        },\n        newCustomSize() {\n            return this.customSize || this.customSizeByPack\n        },\n        customSizeByPack() {\n            if (this.iconConfig && this.iconConfig.sizes) {\n                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {\n                    return this.iconConfig.sizes[this.size]\n                } else if (this.iconConfig.sizes.default) {\n                    return this.iconConfig.sizes.default\n                }\n            }\n            return null\n        },\n        useIconComponent() {\n            return this.component || config.defaultIconComponent\n        }\n    },\n    methods: {\n        /**\n        * Equivalent icon name of the MDI.\n        */\n        getEquivalentIconOf(value) {\n            // Only transform the class if the both prop is set to true\n            if (!this.both) {\n                return value\n            }\n\n            if (this.iconConfig &&\n                this.iconConfig.internalIcons &&\n                this.iconConfig.internalIcons[value]) {\n                return this.iconConfig.internalIcons[value]\n            }\n            return value\n        }\n    }\n}\n</script>\n",
      "path": "src/components/icon/Icon.vue"
    },
    {
      "type": "registry:component",
      "target": "components/input/Input.vue",
      "content": "<template>\n    <div\n        class=\"control\"\n        :class=\"rootClasses\"\n    >\n        <input\n            v-if=\"type !== 'textarea'\"\n            ref=\"input\"\n            class=\"input\"\n            :class=\"[inputClasses, customClass]\"\n            :type=\"newType\"\n            :autocomplete=\"newAutocomplete\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\">\n\n        <textarea\n            v-else\n            ref=\"textarea\"\n            class=\"textarea\"\n            :class=\"[inputClasses, customClass]\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\"/>\n\n        <b-icon\n            v-if=\"icon\"\n            class=\"is-left\"\n            :class=\"{'is-clickable': iconClickable}\"\n            :icon=\"icon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            @click.native=\"iconClick('icon-click', $event)\"/>\n\n        <b-icon\n            v-if=\"!loading && hasIconRight\"\n            class=\"is-right\"\n            :class=\"{ 'is-clickable': passwordReveal || iconRightClickable }\"\n            :icon=\"rightIcon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            :type=\"rightIconType\"\n            both\n            @click.native=\"rightIconClick\"/>\n\n        <small\n            v-if=\"maxlength && hasCounter && type !== 'number'\"\n            class=\"help counter\"\n            :class=\"{ 'is-invisible': !isFocused }\">\n            {{ valueLength }} / {{ maxlength }}\n        </small>\n    </div>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport config from '@/utils/config'\nimport FormElementMixin from '@/utils/FormElementMixin'\n\nexport default {\n    name: 'BInput',\n    components: {\n        [Icon.name]: Icon\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: [Number, String],\n        type: {\n            type: String,\n            default: 'text'\n        },\n        lazy: {\n            type: Boolean,\n            default: false\n        },\n        passwordReveal: Boolean,\n        iconClickable: Boolean,\n        hasCounter: {\n            type: Boolean,\n            default: () => config.defaultInputHasCounter\n        },\n        customClass: {\n            type: String,\n            default: ''\n        },\n        iconRight: String,\n        iconRightClickable: Boolean,\n        iconRightType: String\n    },\n    data() {\n        return {\n            newValue: this.value,\n            newType: this.type,\n            newAutocomplete: this.autocomplete || config.defaultInputAutocomplete,\n            isPasswordVisible: false,\n            _elementRef: this.type === 'textarea'\n                ? 'textarea'\n                : 'input'\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.newValue\n            },\n            set(value) {\n                this.newValue = value\n                this.$emit('input', value)\n            }\n        },\n        rootClasses() {\n            return [\n                this.iconPosition,\n                this.size,\n                {\n                    'is-expanded': this.expanded,\n                    'is-loading': this.loading,\n                    'is-clearfix': !this.hasMessage\n                }\n            ]\n        },\n        inputClasses() {\n            return [\n                this.statusType,\n                this.size,\n                { 'is-rounded': this.rounded }\n            ]\n        },\n        hasIconRight() {\n            return this.passwordReveal ||\n                this.loading || (this.statusIcon && this.statusTypeIcon) || this.iconRight\n        },\n        rightIcon() {\n            if (this.passwordReveal) {\n                return this.passwordVisibleIcon\n            } else if (this.iconRight) {\n                return this.iconRight\n            }\n            return this.statusTypeIcon\n        },\n        rightIconType() {\n            if (this.passwordReveal) {\n                return 'is-primary'\n            } else if (this.iconRight) {\n                return this.iconRightType || null\n            }\n            return this.statusType\n        },\n\n        /**\n        * Position of the icon or if it's both sides.\n        */\n        iconPosition() {\n            let iconClasses = ''\n\n            if (this.icon) {\n                iconClasses += 'has-icons-left '\n            }\n\n            if (this.hasIconRight) {\n                iconClasses += 'has-icons-right'\n            }\n\n            return iconClasses\n        },\n\n        /**\n        * Icon name (MDI) based on the type.\n        */\n        statusTypeIcon() {\n            switch (this.statusType) {\n                case 'is-success': return 'check'\n                case 'is-danger': return 'alert-circle'\n                case 'is-info': return 'information'\n                case 'is-warning': return 'alert'\n            }\n        },\n\n        /**\n        * Check if have any message prop from parent if it's a Field.\n        */\n        hasMessage() {\n            return !!this.statusMessage\n        },\n\n        /**\n        * Current password-reveal icon name.\n        */\n        passwordVisibleIcon() {\n            return !this.isPasswordVisible ? 'eye' : 'eye-off'\n        },\n        /**\n        * Get value length\n        */\n        valueLength() {\n            if (typeof this.computedValue === 'string') {\n                return Array.from(this.computedValue).length\n            } else if (typeof this.computedValue === 'number') {\n                return this.computedValue.toString().length\n            }\n            return 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed:\n        *   1. Set internal value.\n        *   2. Validate it if the value came from outside;\n        *      i.e., not equal to computedValue\n        */\n        value(value) {\n            const fromOutside = this.computedValue != value // eslint-disable-line eqeqeq\n            this.newValue = value\n            if (fromOutside) {\n                // validation must wait for DOM updated\n                this.$nextTick(() => {\n                    !this.isValid && this.checkHtml5Validity()\n                })\n            }\n        },\n        type(type) {\n            this.newType = type\n        }\n    },\n    methods: {\n        /**\n        * Toggle the visibility of a password-reveal input\n        * by changing the type and focus the input right away.\n        */\n        togglePasswordVisibility() {\n            this.isPasswordVisible = !this.isPasswordVisible\n            this.newType = this.isPasswordVisible ? 'text' : 'password'\n\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        iconClick(emit, event) {\n            this.$emit(emit, event)\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        rightIconClick(event) {\n            if (this.passwordReveal) {\n                this.togglePasswordVisibility()\n            } else if (this.iconRightClickable) {\n                this.iconClick('icon-right-click', event)\n            }\n        },\n\n        onInput(event) {\n            if (!this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        onChange(event) {\n            if (this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        updateValue(value) {\n            this.computedValue = value\n            !this.isValid && this.checkHtml5Validity()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/input/Input.vue"
    },
    {
      "type": "registry:component",
      "target": "components/select/Select.vue",
      "content": "<template>\n    <div\n        class=\"control\"\n        :class=\"{ 'is-expanded': expanded, 'has-icons-left': icon }\">\n        <span class=\"select\" :class=\"spanClasses\">\n\n            <select\n                v-model=\"computedValue\"\n                ref=\"select\"\n                :multiple=\"multiple\"\n                :size=\"nativeSize\"\n                v-bind=\"$attrs\"\n                @blur=\"$emit('blur', $event) && checkHtml5Validity()\"\n                @focus=\"$emit('focus', $event)\">\n\n                <template v-if=\"placeholder\">\n                    <option\n                        v-if=\"computedValue == null\"\n                        :value=\"null\"\n                        disabled\n                        hidden>\n                        {{ placeholder }}\n                    </option>\n                </template>\n\n                <slot/>\n\n            </select>\n        </span>\n\n        <b-icon\n            v-if=\"icon\"\n            class=\"is-left\"\n            :icon=\"icon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"/>\n    </div>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport FormElementMixin from '@/utils/FormElementMixin'\n\nexport default {\n    name: 'BSelect',\n    components: {\n        [Icon.name]: Icon\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function, Date],\n            default: null\n        },\n        placeholder: String,\n        multiple: Boolean,\n        nativeSize: [String, Number]\n    },\n    data() {\n        return {\n            selected: this.value,\n            _elementRef: 'select'\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.selected\n            },\n            set(value) {\n                this.selected = value\n                this.$emit('input', value)\n                !this.isValid && this.checkHtml5Validity()\n            }\n        },\n        spanClasses() {\n            return [this.size, this.statusType, {\n                'is-fullwidth': this.expanded,\n                'is-loading': this.loading,\n                'is-multiple': this.multiple,\n                'is-rounded': this.rounded,\n                'is-empty': this.selected === null\n            }]\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed:\n        *   1. Set the selected option.\n        *   2. If it's invalid, validate again.\n        */\n        value(value) {\n            this.selected = value\n            !this.isValid && this.checkHtml5Validity()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/select/Select.vue"
    },
    {
      "type": "registry:component",
      "target": "components/timepicker/Timepicker.vue",
      "content": "<template>\n    <div class=\"timepicker control\" :class=\"[size, {'is-expanded': expanded}]\">\n        <b-dropdown\n            v-if=\"!isMobile || inline\"\n            ref=\"dropdown\"\n            :position=\"position\"\n            :disabled=\"disabled\"\n            :inline=\"inline\"\n            :mobile-modal=\"mobileModal\"\n            :append-to-body=\"appendToBody\"\n            append-to-body-copy-parent\n            @active-change=\"onActiveChange\">\n            <template #trigger v-if=\"!inline\">\n                <slot name=\"trigger\">\n                    <b-input\n                        ref=\"input\"\n                        autocomplete=\"off\"\n                        :value=\"formatValue(computedValue)\"\n                        :placeholder=\"placeholder\"\n                        :size=\"size\"\n                        :icon=\"icon\"\n                        :icon-pack=\"iconPack\"\n                        :loading=\"loading\"\n                        :disabled=\"disabled\"\n                        :readonly=\"!editable\"\n                        :rounded=\"rounded\"\n                        v-bind=\"$attrs\"\n                        :use-html5-validation=\"useHtml5Validation\"\n                        @keyup.native.enter=\"toggle(true)\"\n                        @change.native=\"onChange($event.target.value)\"\n                        @focus=\"handleOnFocus\"/>\n                </slot>\n            </template>\n\n            <b-dropdown-item\n                :disabled=\"disabled\"\n                :focusable=\"focusable\"\n                custom>\n                <b-field grouped position=\"is-centered\">\n                    <b-select\n                        v-model=\"hoursSelected\"\n                        @change.native=\"onHoursChange($event.target.value)\"\n                        :disabled=\"disabled\"\n                        placeholder=\"00\">\n                        <option\n                            v-for=\"hour in hours\"\n                            :value=\"hour.value\"\n                            :key=\"hour.value\"\n                            :disabled=\"isHourDisabled(hour.value)\">\n                            {{ hour.label }}\n                        </option>\n                    </b-select>\n                    <span class=\"control is-colon\">{{ hourLiteral }}</span>\n                    <b-select\n                        v-model=\"minutesSelected\"\n                        @change.native=\"onMinutesChange($event.target.value)\"\n                        :disabled=\"disabled\"\n                        placeholder=\"00\">\n                        <option\n                            v-for=\"minute in minutes\"\n                            :value=\"minute.value\"\n                            :key=\"minute.value\"\n                            :disabled=\"isMinuteDisabled(minute.value)\">\n                            {{ minute.label }}\n                        </option>\n                    </b-select>\n                    <template v-if=\"enableSeconds\">\n                        <span class=\"control is-colon\">{{ minuteLiteral }}</span>\n                        <b-select\n                            v-model=\"secondsSelected\"\n                            @change.native=\"onSecondsChange($event.target.value)\"\n                            :disabled=\"disabled\"\n                            placeholder=\"00\">\n                            <option\n                                v-for=\"second in seconds\"\n                                :value=\"second.value\"\n                                :key=\"second.value\"\n                                :disabled=\"isSecondDisabled(second.value)\">\n                                {{ second.label }}\n                            </option>\n                        </b-select>\n                        <span class=\"control is-colon\">{{ secondLiteral }}</span>\n                    </template>\n                    <b-select\n                        v-model=\"meridienSelected\"\n                        @change.native=\"onMeridienChange($event.target.value)\"\n                        v-if=\"!isHourFormat24\"\n                        :disabled=\"disabled\">\n                        <option\n                            v-for=\"meridien in meridiens\"\n                            :value=\"meridien\"\n                            :key=\"meridien\">\n                            {{ meridien }}\n                        </option>\n                    </b-select>\n                </b-field>\n\n                <footer\n                    v-if=\"$slots.default !== undefined && $slots.default.length\"\n                    class=\"timepicker-footer\">\n                    <slot/>\n                </footer>\n            </b-dropdown-item>\n        </b-dropdown>\n\n        <b-input\n            v-else\n            ref=\"input\"\n            type=\"time\"\n            :step=\"nativeStep\"\n            autocomplete=\"off\"\n            :value=\"formatHHMMSS(computedValue)\"\n            :placeholder=\"placeholder\"\n            :size=\"size\"\n            :icon=\"icon\"\n            :icon-pack=\"iconPack\"\n            :rounded=\"rounded\"\n            :loading=\"loading\"\n            :max=\"formatHHMMSS(maxTime)\"\n            :min=\"formatHHMMSS(minTime)\"\n            :disabled=\"disabled\"\n            :readonly=\"false\"\n            v-bind=\"$attrs\"\n            :use-html5-validation=\"useHtml5Validation\"\n            @change.native=\"onChange($event.target.value)\"\n            @focus=\"handleOnFocus\"\n            @blur=\"onBlur() && checkHtml5Validity()\"/>\n    </div>\n</template>\n\n<script>\nimport TimepickerMixin from '@/utils/TimepickerMixin'\nimport Dropdown from '@/components/dropdown/Dropdown'\nimport DropdownItem from '@/components/dropdown/DropdownItem'\nimport Input from '@/components/input/Input'\nimport Field from '@/components/field/Field'\nimport Select from '@/components/select/Select'\nimport Icon from '@/components/icon/Icon'\n\nexport default {\n    name: 'BTimepicker',\n    components: {\n        [Input.name]: Input,\n        [Field.name]: Field,\n        [Select.name]: Select,\n        [Icon.name]: Icon,\n        [Dropdown.name]: Dropdown,\n        [DropdownItem.name]: DropdownItem\n    },\n    mixins: [TimepickerMixin],\n    inheritAttrs: false,\n    data() {\n        return {\n            _isTimepicker: true\n        }\n    },\n    computed: {\n        nativeStep() {\n            if (this.enableSeconds) return '1'\n        }\n    }\n}\n</script>\n",
      "path": "src/components/timepicker/Timepicker.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/FormElementMixin.js",
      "content": "import config from '@/utils/config'\nimport { isVueComponent } from '@/utils/helpers'\n\nexport default {\n    props: {\n        size: String,\n        expanded: Boolean,\n        loading: Boolean,\n        rounded: Boolean,\n        icon: String,\n        iconPack: String,\n        // Native options to use in HTML5 validation\n        autocomplete: String,\n        maxlength: [Number, String],\n        useHtml5Validation: {\n            type: Boolean,\n            default: () => config.defaultUseHtml5Validation\n        },\n        validationMessage: String,\n        locale: {\n            type: [String, Array],\n            default: () => {\n                return config.defaultLocale\n            }\n        },\n        statusIcon: {\n            type: Boolean,\n            default: () => {\n                return config.defaultStatusIcon\n            }\n        }\n    },\n    data() {\n        return {\n            isValid: true,\n            isFocused: false,\n            newIconPack: this.iconPack || config.defaultIconPack\n        }\n    },\n    computed: {\n        /**\n         * Find parent Field, max 3 levels deep.\n         */\n        parentField() {\n            let parent = this.$parent\n            for (let i = 0; i < 3; i++) {\n                if (parent && !parent.$data._isField) {\n                    parent = parent.$parent\n                }\n            }\n            return parent\n        },\n\n        /**\n         * Get the type prop from parent if it's a Field.\n         */\n        statusType() {\n            const { newType } = this.parentField || {}\n\n            if (!newType) return\n\n            if (typeof newType === 'string') {\n                return newType\n            } else {\n                for (const key in newType) {\n                    if (newType[key]) {\n                        return key\n                    }\n                }\n            }\n        },\n\n        /**\n         * Get the message prop from parent if it's a Field.\n         */\n        statusMessage() {\n            if (!this.parentField) return\n\n            return this.parentField.newMessage || this.parentField.$slots.message\n        },\n\n        /**\n         * Fix icon size for inputs, large was too big\n         */\n        iconSize() {\n            switch (this.size) {\n                case 'is-small': return this.size\n                case 'is-medium': return\n                case 'is-large': return this.newIconPack === 'mdi'\n                    ? 'is-medium'\n                    : ''\n            }\n        }\n    },\n    methods: {\n        /**\n         * Focus method that work dynamically depending on the component.\n         */\n        focus() {\n            const el = this.getElement()\n            if (el === undefined) return\n\n            this.$nextTick(() => {\n                if (el) el.focus()\n            })\n        },\n\n        onBlur($event) {\n            this.isFocused = false\n            this.$emit('blur', $event)\n            this.checkHtml5Validity()\n        },\n\n        onFocus($event) {\n            this.isFocused = true\n            this.$emit('focus', $event)\n        },\n\n        getElement() {\n            let el = this.$refs[this.$data._elementRef]\n            while (isVueComponent(el)) {\n                el = el.$refs[el.$data._elementRef]\n            }\n            return el\n        },\n\n        setInvalid() {\n            let type = 'is-danger'\n            let message = this.validationMessage || this.getElement().validationMessage\n            this.setValidity(type, message)\n        },\n\n        setValidity(type, message) {\n            this.$nextTick(() => {\n                if (this.parentField) {\n                    // Set type only if not defined\n                    if (!this.parentField.type) {\n                        this.parentField.newType = type\n                    }\n                    // Set message only if not defined\n                    if (!this.parentField.message) {\n                        this.parentField.newMessage = message\n                    }\n                }\n            })\n        },\n\n        /**\n         * Check HTML5 validation, set isValid property.\n         * If validation fail, send 'is-danger' type,\n         * and error message to parent if it's a Field.\n         */\n        checkHtml5Validity() {\n            if (!this.useHtml5Validation) return\n\n            const el = this.getElement()\n            if (el === undefined) return\n\n            if (!el.checkValidity()) {\n                this.setInvalid()\n                this.isValid = false\n            } else {\n                this.setValidity(null, null)\n                this.isValid = true\n            }\n\n            return this.isValid\n        }\n    }\n}\n",
      "path": "src/utils/FormElementMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/icons.js",
      "content": "import config from '@/utils/config'\nimport { merge } from '@/utils/helpers'\n\nconst mdiIcons = {\n    sizes: {\n        'default': 'mdi-24px',\n        'is-small': null,\n        'is-medium': 'mdi-36px',\n        'is-large': 'mdi-48px'\n    },\n    iconPrefix: 'mdi-'\n}\n\nconst faIcons = () => {\n    const faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-'\n    return {\n        sizes: {\n            'default': null,\n            'is-small': null,\n            'is-medium': faIconPrefix + 'lg',\n            'is-large': faIconPrefix + '2x'\n        },\n        iconPrefix: faIconPrefix,\n        internalIcons: {\n            'information': 'info-circle',\n            'alert': 'exclamation-triangle',\n            'alert-circle': 'exclamation-circle',\n            'chevron-right': 'angle-right',\n            'chevron-left': 'angle-left',\n            'chevron-down': 'angle-down',\n            'eye-off': 'eye-slash',\n            'menu-down': 'caret-down',\n            'menu-up': 'caret-up',\n            'close-circle': 'times-circle'\n        }\n    }\n}\n\nconst getIcons = () => {\n    let icons = {\n        mdi: mdiIcons,\n        fa: faIcons(),\n        fas: faIcons(),\n        far: faIcons(),\n        fad: faIcons(),\n        fab: faIcons(),\n        fal: faIcons(),\n        'fa-solid': faIcons(),\n        'fa-regular': faIcons(),\n        'fa-light': faIcons(),\n        'fa-thin': faIcons(),\n        'fa-duotone': faIcons(),\n        'fa-brands': faIcons()\n    }\n\n    if (config && config.customIconPacks) {\n        icons = merge(icons, config.customIconPacks, true)\n    }\n\n    return icons\n}\n\nexport default getIcons\n",
      "path": "src/utils/icons.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/InjectedChildMixin.js",
      "content": "import {hasFlag} from '@/utils/helpers'\n\nconst sorted = 1\nconst optional = 2\n\nexport const Sorted = sorted\nexport const Optional = optional\n\nexport default (parentItemName, flags = 0) => {\n    const mixin = {\n        inject: {parent: {from: 'b' + parentItemName, default: false}},\n        created() {\n            if (!this.parent) {\n                if (!hasFlag(flags, optional)) {\n                    this.$destroy()\n                    throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName)\n                }\n            } else if (this.parent._registerItem) {\n                this.parent._registerItem(this)\n            }\n        },\n        beforeDestroy() {\n            if (this.parent && this.parent._unregisterItem) {\n                this.parent._unregisterItem(this)\n            }\n        }\n    }\n    if (hasFlag(flags, sorted)) {\n        mixin.data = () => {\n            return {\n                index: null\n            }\n        }\n    }\n    return mixin\n}\n",
      "path": "src/utils/InjectedChildMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/ProviderParentMixin.js",
      "content": "import {hasFlag} from '@/utils/helpers'\n\nconst items = 1\nconst sorted = 3\n\nexport const Items = items\nexport const Sorted = sorted\n\nexport default (itemName, flags = 0) => {\n    const mixin = {\n        provide() {\n            return {\n                ['b' + itemName]: this\n            }\n        }\n    }\n\n    if (hasFlag(flags, items)) {\n        mixin.data = function () {\n            return {\n                childItems: []\n            }\n        }\n        mixin.methods = {\n            _registerItem(item) {\n                this.childItems.push(item)\n            },\n            _unregisterItem(item) {\n                this.childItems = this.childItems.filter((i) => i !== item)\n            }\n        }\n\n        if (hasFlag(flags, sorted)) {\n            mixin.watch = {\n                /**\n                 * When items are added/removed deep search in the elements default's slot\n                 * And mark the items with their index\n                 */\n                childItems(items) {\n                    if (items.length > 0 && this.$scopedSlots.default) {\n                        let tag = items[0].$vnode.tag\n                        let index = 0\n\n                        const deepSearch = (children) => {\n                            for (let child of children) {\n                                if (child.tag === tag) {\n                                    // An item with the same tag will for sure be found\n                                    const it = items.find((i) => i.$vnode === child)\n                                    if (it) {\n                                        it.index = index++\n                                    }\n                                } else if (child.tag) {\n                                    const sub = child.componentInstance\n                                        ? (child.componentInstance.$scopedSlots.default\n                                            ? child.componentInstance.$scopedSlots.default()\n                                            : child.componentInstance.$children)\n                                        : child.children\n                                    if (Array.isArray(sub) && sub.length > 0) {\n                                        deepSearch(sub.map((e) => e.$vnode))\n                                    }\n                                }\n                            }\n                            return false\n                        }\n\n                        deepSearch(this.$scopedSlots.default())\n                    }\n                }\n            }\n            mixin.computed = {\n                /**\n                 * When items are added/removed sort them according to their position\n                 */\n                sortedItems() {\n                    return this.childItems.slice().sort((i1, i2) => {\n                        return i1.index - i2.index\n                    })\n                }\n            }\n        }\n    }\n    return mixin\n}\n",
      "path": "src/utils/ProviderParentMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/TimepickerMixin.js",
      "content": "import FormElementMixin from '@/utils/FormElementMixin'\nimport { isMobile, matchWithGroups } from '@/utils/helpers'\nimport config from '@/utils/config'\n\nconst AM = 'AM'\nconst PM = 'PM'\nconst HOUR_FORMAT_24 = '24'\nconst HOUR_FORMAT_12 = '12'\n\nconst defaultTimeFormatter = (date, vm) => {\n    return vm.dtf.format(date)\n}\n\nconst defaultTimeParser = (timeString, vm) => {\n    if (timeString) {\n        let d = null\n        if (vm.computedValue && !isNaN(vm.computedValue)) {\n            d = new Date(vm.computedValue)\n        } else {\n            d = vm.timeCreator()\n            d.setMilliseconds(0)\n        }\n\n        if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {\n            const formatRegex = vm.dtf\n                .formatToParts(d).map((part) => {\n                    if (part.type === 'literal') {\n                        return part.value.replace(/ /g, '\\\\s?')\n                    } else if (part.type === 'dayPeriod') {\n                        return `((?!=<${part.type}>)(${vm.amString}|${vm.pmString}|${AM}|${PM}|${AM.toLowerCase()}|${PM.toLowerCase()})?)`\n                    }\n                    return `((?!=<${part.type}>)\\\\d+)`\n                }).join('')\n            const timeGroups = matchWithGroups(formatRegex, timeString)\n\n            // We do a simple validation for the group.\n            // If it is not valid, it will fallback to Date.parse below\n            timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null\n            timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null\n            timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null\n            if (\n                timeGroups.hour &&\n                timeGroups.hour >= 0 &&\n                timeGroups.hour < 24 &&\n                timeGroups.minute &&\n                timeGroups.minute >= 0 &&\n                timeGroups.minute < 59\n            ) {\n                if (timeGroups.dayPeriod &&\n                    (\n                        timeGroups.dayPeriod.toLowerCase() === vm.pmString.toLowerCase() ||\n                        timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()\n                    ) &&\n                    timeGroups.hour < 12) {\n                    timeGroups.hour += 12\n                }\n                d.setHours(timeGroups.hour)\n                d.setMinutes(timeGroups.minute)\n                d.setSeconds(timeGroups.second || 0)\n                return d\n            }\n        }\n\n        // Fallback if formatToParts is not supported or if we were not able to parse a valid date\n        let am = false\n        if (vm.hourFormat === HOUR_FORMAT_12) {\n            const dateString12 = timeString.split(' ')\n            timeString = dateString12[0]\n            am = (dateString12[1] === vm.amString || dateString12[1] === AM)\n        }\n        const time = timeString.split(':')\n        let hours = parseInt(time[0], 10)\n        const minutes = parseInt(time[1], 10)\n        const seconds = vm.enableSeconds ? parseInt(time[2], 10) : 0\n        if (isNaN(hours) || hours < 0 || hours > 23 ||\n            (vm.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12)) ||\n            isNaN(minutes) || minutes < 0 || minutes > 59) {\n            return null\n        }\n        d.setSeconds(seconds)\n        d.setMinutes(minutes)\n        if (vm.hourFormat === HOUR_FORMAT_12) {\n            if (am && hours === 12) {\n                hours = 0\n            } else if (!am && hours !== 12) {\n                hours += 12\n            }\n        }\n        d.setHours(hours)\n        return new Date(d.getTime())\n    }\n    return null\n}\n\nexport default {\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: Date,\n        inline: Boolean,\n        minTime: Date,\n        maxTime: Date,\n        placeholder: String,\n        editable: Boolean,\n        disabled: Boolean,\n        hourFormat: {\n            type: String,\n            validator: (value) => {\n                return value === HOUR_FORMAT_24 || value === HOUR_FORMAT_12\n            }\n        },\n        incrementHours: {\n            type: Number,\n            default: 1\n        },\n        incrementMinutes: {\n            type: Number,\n            default: 1\n        },\n        incrementSeconds: {\n            type: Number,\n            default: 1\n        },\n        timeFormatter: {\n            type: Function,\n            default: (date, vm) => {\n                if (typeof config.defaultTimeFormatter === 'function') {\n                    return config.defaultTimeFormatter(date)\n                } else {\n                    return defaultTimeFormatter(date, vm)\n                }\n            }\n        },\n        timeParser: {\n            type: Function,\n            default: (date, vm) => {\n                if (typeof config.defaultTimeParser === 'function') {\n                    return config.defaultTimeParser(date)\n                } else {\n                    return defaultTimeParser(date, vm)\n                }\n            }\n        },\n        mobileNative: {\n            type: Boolean,\n            default: () => config.defaultTimepickerMobileNative\n        },\n        mobileModal: {\n            type: Boolean,\n            default: () => config.defaultTimepickerMobileModal\n        },\n        timeCreator: {\n            type: Function,\n            default: () => {\n                if (typeof config.defaultTimeCreator === 'function') {\n                    return config.defaultTimeCreator()\n                } else {\n                    return new Date()\n                }\n            }\n        },\n        position: String,\n        unselectableTimes: Array,\n        openOnFocus: Boolean,\n        enableSeconds: Boolean,\n        defaultMinutes: Number,\n        defaultSeconds: Number,\n        focusable: {\n            type: Boolean,\n            default: true\n        },\n        tzOffset: {\n            type: Number,\n            default: 0\n        },\n        appendToBody: Boolean,\n        resetOnMeridianChange: {\n            type: Boolean,\n            default: false\n        }\n    },\n    data() {\n        return {\n            dateSelected: this.value,\n            hoursSelected: null,\n            minutesSelected: null,\n            secondsSelected: null,\n            meridienSelected: null,\n            _elementRef: 'input',\n            AM,\n            PM,\n            HOUR_FORMAT_24,\n            HOUR_FORMAT_12\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.dateSelected\n            },\n            set(value) {\n                this.dateSelected = value\n                this.$emit('input', this.dateSelected)\n            }\n        },\n        localeOptions() {\n            return new Intl.DateTimeFormat(this.locale, {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: this.enableSeconds ? 'numeric' : undefined\n            }).resolvedOptions()\n        },\n        dtf() {\n            return new Intl.DateTimeFormat(this.locale, {\n                hour: this.localeOptions.hour || 'numeric',\n                minute: this.localeOptions.minute || 'numeric',\n                second: this.enableSeconds ? this.localeOptions.second || 'numeric' : undefined,\n                // Fixes 12 hour display github.com/buefy/buefy/issues/3418\n                hourCycle: !this.isHourFormat24 ? 'h12' : 'h23'\n            })\n        },\n        newHourFormat() {\n            return this.hourFormat || (this.localeOptions.hour12 ? HOUR_FORMAT_12 : HOUR_FORMAT_24)\n        },\n        sampleTime() {\n            let d = this.timeCreator()\n            d.setHours(10)\n            d.setSeconds(0)\n            d.setMinutes(0)\n            d.setMilliseconds(0)\n            return d\n        },\n        hourLiteral() {\n            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                let d = this.sampleTime\n                const parts = this.dtf.formatToParts(d)\n                const literal = parts.find((part, idx) => (idx > 0 && parts[idx - 1].type === 'hour'))\n                if (literal) {\n                    return literal.value\n                }\n            }\n            return ':'\n        },\n        minuteLiteral() {\n            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                let d = this.sampleTime\n                const parts = this.dtf.formatToParts(d)\n                const literal = parts.find((part, idx) => (idx > 0 && parts[idx - 1].type === 'minute'))\n                if (literal) {\n                    return literal.value\n                }\n            }\n            return ':'\n        },\n        secondLiteral() {\n            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                let d = this.sampleTime\n                const parts = this.dtf.formatToParts(d)\n                const literal = parts.find((part, idx) => (idx > 0 && parts[idx - 1].type === 'second'))\n                if (literal) {\n                    return literal.value\n                }\n            }\n        },\n        amString() {\n            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                let d = this.sampleTime\n                d.setHours(10)\n                const dayPeriod = this.dtf.formatToParts(d).find((part) => part.type === 'dayPeriod')\n                if (dayPeriod) {\n                    return dayPeriod.value\n                }\n            }\n            return AM\n        },\n        pmString() {\n            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {\n                let d = this.sampleTime\n                d.setHours(20)\n                const dayPeriod = this.dtf.formatToParts(d).find((part) => part.type === 'dayPeriod')\n                if (dayPeriod) {\n                    return dayPeriod.value\n                }\n            }\n            return PM\n        },\n        hours() {\n            if (!this.incrementHours || this.incrementHours < 1) throw new Error('Hour increment cannot be null or less than 1.')\n            const hours = []\n            const numberOfHours = this.isHourFormat24 ? 24 : 12\n            for (let i = 0; i < numberOfHours; i += this.incrementHours) {\n                let value = i\n                let label = value\n                if (!this.isHourFormat24) {\n                    value = (i + 1)\n                    label = value\n                    if (this.meridienSelected === this.amString) {\n                        if (value === 12) {\n                            value = 0\n                        }\n                    } else if (this.meridienSelected === this.pmString) {\n                        if (value !== 12) {\n                            value += 12\n                        }\n                    }\n                }\n                hours.push({\n                    label: this.formatNumber(label),\n                    value: value\n                })\n            }\n            return hours\n        },\n\n        minutes() {\n            if (!this.incrementMinutes || this.incrementMinutes < 1) throw new Error('Minute increment cannot be null or less than 1.')\n            const minutes = []\n            for (let i = 0; i < 60; i += this.incrementMinutes) {\n                minutes.push({\n                    label: this.formatNumber(i, true),\n                    value: i\n                })\n            }\n            return minutes\n        },\n\n        seconds() {\n            if (!this.incrementSeconds || this.incrementSeconds < 1) throw new Error('Second increment cannot be null or less than 1.')\n            const seconds = []\n            for (let i = 0; i < 60; i += this.incrementSeconds) {\n                seconds.push({\n                    label: this.formatNumber(i, true),\n                    value: i\n                })\n            }\n            return seconds\n        },\n\n        meridiens() {\n            return [this.amString, this.pmString]\n        },\n\n        isMobile() {\n            return this.mobileNative && isMobile.any()\n        },\n\n        isHourFormat24() {\n            return this.newHourFormat === HOUR_FORMAT_24\n        }\n    },\n    watch: {\n        hourFormat() {\n            if (this.hoursSelected !== null) {\n                this.meridienSelected = this.hoursSelected >= 12 ? this.pmString : this.amString\n            }\n        },\n        locale() {\n            // see updateInternalState default\n            if (!this.value) {\n                this.meridienSelected = this.amString\n            }\n        },\n        /**\n         * When v-model is changed:\n         *   1. Update internal value.\n         *   2. If it's invalid, validate again.\n         */\n        value: {\n            handler(value) {\n                this.updateInternalState(value)\n                !this.isValid && this.$refs.input.checkHtml5Validity()\n            },\n            immediate: true\n        }\n    },\n    methods: {\n        onMeridienChange(value) {\n            if (this.hoursSelected !== null && this.resetOnMeridianChange) {\n                this.hoursSelected = null\n                this.minutesSelected = null\n                this.secondsSelected = null\n                this.computedValue = null\n            } else if (this.hoursSelected !== null) {\n                if (value === this.pmString) {\n                    this.hoursSelected += 12\n                } else if (value === this.amString) {\n                    this.hoursSelected -= 12\n                }\n            }\n            this.updateDateSelected(\n                this.hoursSelected,\n                this.minutesSelected,\n                this.enableSeconds ? this.secondsSelected : 0,\n                value)\n        },\n\n        onHoursChange(value) {\n            if (!this.minutesSelected && typeof this.defaultMinutes !== 'undefined') {\n                this.minutesSelected = this.defaultMinutes\n            }\n            if (!this.secondsSelected && typeof this.defaultSeconds !== 'undefined') {\n                this.secondsSelected = this.defaultSeconds\n            }\n            this.updateDateSelected(\n                parseInt(value, 10),\n                this.minutesSelected,\n                this.enableSeconds ? this.secondsSelected : 0,\n                this.meridienSelected\n            )\n        },\n\n        onMinutesChange(value) {\n            if (!this.secondsSelected && this.defaultSeconds) {\n                this.secondsSelected = this.defaultSeconds\n            }\n            this.updateDateSelected(\n                this.hoursSelected,\n                parseInt(value, 10),\n                this.enableSeconds ? this.secondsSelected : 0,\n                this.meridienSelected\n            )\n        },\n\n        onSecondsChange(value) {\n            this.updateDateSelected(\n                this.hoursSelected,\n                this.minutesSelected,\n                parseInt(value, 10),\n                this.meridienSelected\n            )\n        },\n\n        updateDateSelected(hours, minutes, seconds, meridiens) {\n            if (hours != null && minutes != null &&\n                ((!this.isHourFormat24 && meridiens !== null) || this.isHourFormat24)) {\n                let time = null\n                if (this.computedValue && !isNaN(this.computedValue)) {\n                    time = new Date(this.computedValue)\n                } else {\n                    time = this.timeCreator()\n                    time.setMilliseconds(0)\n                }\n                time.setHours(hours)\n                time.setMinutes(minutes)\n                time.setSeconds(seconds)\n\n                if (!isNaN(time.getTime())) this.computedValue = new Date(time.getTime())\n            }\n        },\n\n        updateInternalState(value) {\n            if (value) {\n                this.hoursSelected = value.getHours()\n                this.minutesSelected = value.getMinutes()\n                this.secondsSelected = value.getSeconds()\n                this.meridienSelected = value.getHours() >= 12 ? this.pmString : this.amString\n            } else {\n                this.hoursSelected = null\n                this.minutesSelected = null\n                this.secondsSelected = null\n                this.meridienSelected = this.amString\n            }\n            this.dateSelected = value\n        },\n\n        isHourDisabled(hour) {\n            let disabled = false\n            if (this.minTime) {\n                const minHours = this.minTime.getHours()\n                const noMinutesAvailable = this.minutes.every((minute) => {\n                    return this.isMinuteDisabledForHour(hour, minute.value)\n                })\n                disabled = hour < minHours || noMinutesAvailable\n            }\n            if (this.maxTime) {\n                if (!disabled) {\n                    const maxHours = this.maxTime.getHours()\n                    disabled = hour > maxHours\n                }\n            }\n            if (this.unselectableTimes) {\n                if (!disabled) {\n                    const unselectable = this.unselectableTimes.filter((time) => {\n                        if (this.enableSeconds && this.secondsSelected !== null) {\n                            return time.getHours() === hour &&\n                                time.getMinutes() === this.minutesSelected &&\n                                time.getSeconds() === this.secondsSelected\n                        } else if (this.minutesSelected !== null) {\n                            return time.getHours() === hour &&\n                                time.getMinutes() === this.minutesSelected\n                        }\n                        return false\n                    })\n                    if (unselectable.length > 0) {\n                        disabled = true\n                    } else {\n                        disabled = this.minutes.every((minute) => {\n                            return this.unselectableTimes.filter((time) => {\n                                return time.getHours() === hour &&\n                                    time.getMinutes() === minute.value\n                            }).length > 0\n                        })\n                    }\n                }\n            }\n            return disabled\n        },\n\n        isMinuteDisabledForHour(hour, minute) {\n            let disabled = false\n            if (this.minTime) {\n                const minHours = this.minTime.getHours()\n                const minMinutes = this.minTime.getMinutes()\n                disabled = hour === minHours && minute < minMinutes\n            }\n            if (this.maxTime) {\n                if (!disabled) {\n                    const maxHours = this.maxTime.getHours()\n                    const maxMinutes = this.maxTime.getMinutes()\n                    disabled = hour === maxHours && minute > maxMinutes\n                }\n            }\n\n            return disabled\n        },\n\n        isMinuteDisabled(minute) {\n            let disabled = false\n            if (this.hoursSelected !== null) {\n                if (this.isHourDisabled(this.hoursSelected)) {\n                    disabled = true\n                } else {\n                    disabled = this.isMinuteDisabledForHour(this.hoursSelected, minute)\n                }\n                if (this.unselectableTimes) {\n                    if (!disabled) {\n                        const unselectable = this.unselectableTimes.filter((time) => {\n                            if (this.enableSeconds && this.secondsSelected !== null) {\n                                return time.getHours() === this.hoursSelected &&\n                                    time.getMinutes() === minute &&\n                                    time.getSeconds() === this.secondsSelected\n                            } else {\n                                return time.getHours() === this.hoursSelected &&\n                                    time.getMinutes() === minute\n                            }\n                        })\n                        disabled = unselectable.length > 0\n                    }\n                }\n            }\n            return disabled\n        },\n\n        isSecondDisabled(second) {\n            let disabled = false\n            if (this.minutesSelected !== null) {\n                if (this.isMinuteDisabled(this.minutesSelected)) {\n                    disabled = true\n                } else {\n                    if (this.minTime) {\n                        const minHours = this.minTime.getHours()\n                        const minMinutes = this.minTime.getMinutes()\n                        const minSeconds = this.minTime.getSeconds()\n                        disabled = this.hoursSelected === minHours &&\n                            this.minutesSelected === minMinutes &&\n                            second < minSeconds\n                    }\n                    if (this.maxTime) {\n                        if (!disabled) {\n                            const maxHours = this.maxTime.getHours()\n                            const maxMinutes = this.maxTime.getMinutes()\n                            const maxSeconds = this.maxTime.getSeconds()\n                            disabled = this.hoursSelected === maxHours &&\n                                this.minutesSelected === maxMinutes &&\n                                second > maxSeconds\n                        }\n                    }\n                }\n                if (this.unselectableTimes) {\n                    if (!disabled) {\n                        const unselectable = this.unselectableTimes.filter((time) => {\n                            return time.getHours() === this.hoursSelected &&\n                                time.getMinutes() === this.minutesSelected &&\n                                time.getSeconds() === second\n                        })\n                        disabled = unselectable.length > 0\n                    }\n                }\n            }\n            return disabled\n        },\n\n        /*\n         * Parse string into date\n         */\n        onChange(value) {\n            const date = this.timeParser(value, this)\n            this.updateInternalState(date)\n            if (date && !isNaN(date)) {\n                this.computedValue = date\n            } else {\n                // Force refresh input value when not valid date\n                this.computedValue = null\n                this.$refs.input.newValue = this.computedValue\n            }\n        },\n\n        /*\n         * Toggle timepicker\n         */\n        toggle(active) {\n            if (this.$refs.dropdown) {\n                this.$refs.dropdown.isActive = typeof active === 'boolean'\n                    ? active\n                    : !this.$refs.dropdown.isActive\n            }\n        },\n\n        /*\n         * Close timepicker\n         */\n        close() {\n            this.toggle(false)\n        },\n\n        /*\n         * Call default onFocus method and show timepicker\n         */\n        handleOnFocus() {\n            this.onFocus()\n            if (this.openOnFocus) {\n                this.toggle(true)\n            }\n        },\n\n        /*\n         * Format date into string 'HH-MM-SS'\n         */\n        formatHHMMSS(value) {\n            const date = new Date(value)\n            if (value && !isNaN(date)) {\n                const hours = date.getHours()\n                const minutes = date.getMinutes()\n                const seconds = date.getSeconds()\n                return this.formatNumber(hours, true) + ':' +\n                    this.formatNumber(minutes, true) + ':' +\n                    this.formatNumber(seconds, true)\n            }\n            return ''\n        },\n\n        /*\n         * Parse time from string\n         */\n        onChangeNativePicker(event) {\n            const date = event.target.value\n            if (date) {\n                let time = null\n                if (this.computedValue && !isNaN(this.computedValue)) {\n                    time = new Date(this.computedValue)\n                } else {\n                    time = new Date()\n                    time.setMilliseconds(0)\n                }\n                const t = date.split(':')\n                time.setHours(parseInt(t[0], 10))\n                time.setMinutes(parseInt(t[1], 10))\n                time.setSeconds(t[2] ? parseInt(t[2], 10) : 0)\n                this.computedValue = new Date(time.getTime())\n            } else {\n                this.computedValue = null\n            }\n        },\n\n        formatNumber(value, prependZero) {\n            return this.isHourFormat24 || prependZero\n                ? this.pad(value)\n                : value\n        },\n\n        pad(value) {\n            return (value < 10 ? '0' : '') + value\n        },\n\n        /*\n         * Format date into string\n         */\n        formatValue(date) {\n            if (date && !isNaN(date)) {\n                return this.timeFormatter(date, this)\n            } else {\n                return null\n            }\n        },\n        /**\n         * Keypress event that is bound to the document.\n         */\n        keyPress({ key }) {\n            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {\n                this.toggle(false)\n            }\n        },\n        /**\n         * Emit 'blur' event on dropdown is not active (closed)\n         */\n        onActiveChange(value) {\n            if (!value) {\n                this.onBlur()\n            }\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('keyup', this.keyPress)\n        }\n    }\n}\n",
      "path": "src/utils/TimepickerMixin.js"
    }
  ]
}
