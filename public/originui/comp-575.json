{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "comp-575",
  "type": "registry:component",
  "dependencies": [
    "@headless-tree/core",
    "@headless-tree/react",
    "@remixicon/react",
    "lucide-react",
    "radix-ui"
  ],
  "registryDependencies": [
    "https://originui.com/r/tree.json"
  ],
  "files": [
    {
      "type": "registry:component",
      "target": "components/comp-575.tsx",
      "content": "\"use client\"\n\nimport React, { useState } from \"react\"\nimport {\n  createOnDropHandler,\n  dragAndDropFeature,\n  hotkeysCoreFeature,\n  keyboardDragAndDropFeature,\n  selectionFeature,\n  syncDataLoaderFeature,\n} from \"@headless-tree/core\"\nimport { AssistiveTreeDescription, useTree } from \"@headless-tree/react\"\nimport {\n  RiBracesLine,\n  RiCodeSSlashLine,\n  RiFileLine,\n  RiFileTextLine,\n  RiImageLine,\n  RiReactjsLine,\n} from \"@remixicon/react\"\n\nimport { Tree, TreeItem, TreeItemLabel } from \"@/components/ui/tree\"\n\ninterface Item {\n  name: string\n  children?: string[]\n  fileExtension?: string\n}\n\nconst initialItems: Record<string, Item> = {\n  app: {\n    name: \"app\",\n    children: [\"app/layout.tsx\", \"app/page.tsx\", \"app/(dashboard)\", \"app/api\"],\n  },\n  \"app/layout.tsx\": { name: \"layout.tsx\", fileExtension: \"tsx\" },\n  \"app/page.tsx\": { name: \"page.tsx\", fileExtension: \"tsx\" },\n  \"app/(dashboard)\": {\n    name: \"(dashboard)\",\n    children: [\"app/(dashboard)/dashboard\"],\n  },\n  \"app/(dashboard)/dashboard\": {\n    name: \"dashboard\",\n    children: [\"app/(dashboard)/dashboard/page.tsx\"],\n  },\n  \"app/(dashboard)/dashboard/page.tsx\": {\n    name: \"page.tsx\",\n    fileExtension: \"tsx\",\n  },\n  \"app/api\": { name: \"api\", children: [\"app/api/hello\"] },\n  \"app/api/hello\": { name: \"hello\", children: [\"app/api/hello/route.ts\"] },\n  \"app/api/hello/route.ts\": { name: \"route.ts\", fileExtension: \"ts\" },\n  components: {\n    name: \"components\",\n    children: [\"components/button.tsx\", \"components/card.tsx\"],\n  },\n  \"components/button.tsx\": { name: \"button.tsx\", fileExtension: \"tsx\" },\n  \"components/card.tsx\": { name: \"card.tsx\", fileExtension: \"tsx\" },\n  lib: { name: \"lib\", children: [\"lib/utils.ts\"] },\n  \"lib/utils.ts\": { name: \"utils.ts\", fileExtension: \"ts\" },\n  public: {\n    name: \"public\",\n    children: [\"public/favicon.ico\", \"public/vercel.svg\"],\n  },\n  \"public/favicon.ico\": { name: \"favicon.ico\", fileExtension: \"ico\" },\n  \"public/vercel.svg\": { name: \"vercel.svg\", fileExtension: \"svg\" },\n  \"package.json\": { name: \"package.json\", fileExtension: \"json\" },\n  \"tailwind.config.ts\": { name: \"tailwind.config.ts\", fileExtension: \"ts\" },\n  \"tsconfig.json\": { name: \"tsconfig.json\", fileExtension: \"json\" },\n  \"next.config.mjs\": { name: \"next.config.mjs\", fileExtension: \"mjs\" },\n  \"README.md\": { name: \"README.md\", fileExtension: \"md\" },\n  root: {\n    name: \"Project Root\",\n    children: [\n      \"app\",\n      \"components\",\n      \"lib\",\n      \"public\",\n      \"package.json\",\n      \"tailwind.config.ts\",\n      \"tsconfig.json\",\n      \"next.config.mjs\",\n      \"README.md\",\n    ],\n  },\n}\n\n// Helper function to get icon based on file extension\nfunction getFileIcon(extension: string | undefined, className: string) {\n  switch (extension) {\n    case \"tsx\":\n    case \"jsx\":\n      return <RiReactjsLine className={className} />\n    case \"ts\":\n    case \"js\":\n    case \"mjs\":\n      return <RiCodeSSlashLine className={className} />\n    case \"json\":\n      return <RiBracesLine className={className} />\n    case \"svg\":\n    case \"ico\":\n    case \"png\":\n    case \"jpg\":\n      return <RiImageLine className={className} />\n    case \"md\":\n      return <RiFileTextLine className={className} />\n    default:\n      return <RiFileLine className={className} />\n  }\n}\n\nconst indent = 20\n\nexport default function Component() {\n  const [items, setItems] = useState(initialItems)\n\n  const tree = useTree<Item>({\n    initialState: {\n      expandedItems: [\"app\", \"app/(dashboard)\", \"app/(dashboard)/dashboard\"],\n      selectedItems: [\"components\"],\n    },\n    indent,\n    rootItemId: \"root\",\n    getItemName: (item) => item.getItemData()?.name ?? \"Unknown\",\n    isItemFolder: (item) => (item.getItemData()?.children?.length ?? 0) > 0,\n    canReorder: false,\n    onDrop: createOnDropHandler((parentItem, newChildrenIds) => {\n      setItems((prevItems) => {\n        // Sort the children alphabetically\n        const sortedChildren = [...newChildrenIds].sort((a, b) => {\n          const itemA = prevItems[a]\n          const itemB = prevItems[b]\n\n          // First sort folders before files\n          const isAFolder = (itemA?.children?.length ?? 0) > 0\n          const isBFolder = (itemB?.children?.length ?? 0) > 0\n\n          if (isAFolder && !isBFolder) return -1\n          if (!isAFolder && isBFolder) return 1\n\n          // Then sort alphabetically by name\n          return (itemA?.name ?? \"\").localeCompare(itemB?.name ?? \"\")\n        })\n\n        return {\n          ...prevItems,\n          [parentItem.getId()]: {\n            ...prevItems[parentItem.getId()],\n            children: sortedChildren,\n          },\n        }\n      })\n    }),\n    dataLoader: {\n      getItem: (itemId) => items[itemId],\n      getChildren: (itemId) => items[itemId]?.children ?? [],\n    },\n    features: [\n      syncDataLoaderFeature,\n      selectionFeature,\n      hotkeysCoreFeature,\n      dragAndDropFeature,\n      keyboardDragAndDropFeature,\n    ],\n  })\n\n  return (\n    <div className=\"flex h-full flex-col gap-2 *:first:grow\">\n      <div>\n        <Tree\n          className=\"relative before:absolute before:inset-0 before:-ms-1 before:bg-[repeating-linear-gradient(to_right,transparent_0,transparent_calc(var(--tree-indent)-1px),var(--border)_calc(var(--tree-indent)-1px),var(--border)_calc(var(--tree-indent)))]\"\n          indent={indent}\n          tree={tree}\n        >\n          <AssistiveTreeDescription tree={tree} />\n          {tree.getItems().map((item) => {\n            return (\n              <TreeItem key={item.getId()} item={item} className=\"pb-0!\">\n                <TreeItemLabel className=\"rounded-none py-1\">\n                  <span className=\"flex items-center gap-2\">\n                    {!item.isFolder() &&\n                      getFileIcon(\n                        item.getItemData()?.fileExtension,\n                        \"text-muted-foreground pointer-events-none size-4\"\n                      )}\n                    {item.getItemName()}\n                  </span>\n                </TreeItemLabel>\n              </TreeItem>\n            )\n          })}\n        </Tree>\n      </div>\n\n      <p\n        aria-live=\"polite\"\n        role=\"region\"\n        className=\"text-muted-foreground mt-2 text-xs\"\n      >\n        File editor with drag and drop âˆ™{\" \"}\n        <a\n          href=\"https://headless-tree.lukasbach.com\"\n          className=\"hover:text-foreground underline\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          API\n        </a>\n      </p>\n    </div>\n  )\n}\n",
      "path": "registry/default/components/comp-575.tsx"
    },
    {
      "type": "registry:ui",
      "target": "components/ui/tree.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { ItemInstance } from \"@headless-tree/core\"\nimport { ChevronDownIcon } from \"lucide-react\"\nimport { Slot } from \"radix-ui\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TreeContextValue<T = any> {\n  indent: number\n  currentItem?: ItemInstance<T>\n  tree?: any\n}\n\nconst TreeContext = React.createContext<TreeContextValue>({\n  indent: 20,\n  currentItem: undefined,\n  tree: undefined,\n})\n\nfunction useTreeContext<T = any>() {\n  return React.useContext(TreeContext) as TreeContextValue<T>\n}\n\ninterface TreeProps extends React.HTMLAttributes<HTMLDivElement> {\n  indent?: number\n  tree?: any\n}\n\nfunction Tree({ indent = 20, tree, className, ...props }: TreeProps) {\n  const containerProps =\n    tree && typeof tree.getContainerProps === \"function\"\n      ? tree.getContainerProps()\n      : {}\n  const mergedProps = { ...props, ...containerProps }\n\n  // Extract style from mergedProps to merge with our custom styles\n  const { style: propStyle, ...otherProps } = mergedProps\n\n  // Merge styles\n  const mergedStyle = {\n    ...propStyle,\n    \"--tree-indent\": `${indent}px`,\n  } as React.CSSProperties\n\n  return (\n    <TreeContext.Provider value={{ indent, tree }}>\n      <div\n        data-slot=\"tree\"\n        style={mergedStyle}\n        className={cn(\"flex flex-col\", className)}\n        {...otherProps}\n      />\n    </TreeContext.Provider>\n  )\n}\n\ninterface TreeItemProps<T = any>\n  extends React.HTMLAttributes<HTMLButtonElement> {\n  item: ItemInstance<T>\n  indent?: number\n  asChild?: boolean\n}\n\nfunction TreeItem<T = any>({\n  item,\n  className,\n  asChild,\n  children,\n  ...props\n}: Omit<TreeItemProps<T>, \"indent\">) {\n  const { indent } = useTreeContext<T>()\n\n  const itemProps = typeof item.getProps === \"function\" ? item.getProps() : {}\n  const mergedProps = { ...props, ...itemProps }\n\n  // Extract style from mergedProps to merge with our custom styles\n  const { style: propStyle, ...otherProps } = mergedProps\n\n  // Merge styles\n  const mergedStyle = {\n    ...propStyle,\n    \"--tree-padding\": `${item.getItemMeta().level * indent}px`,\n  } as React.CSSProperties\n\n  const Comp = asChild ? Slot.Root : \"button\"\n\n  return (\n    <TreeContext.Provider value={{ indent, currentItem: item }}>\n      <Comp\n        data-slot=\"tree-item\"\n        style={mergedStyle}\n        className={cn(\n          \"z-10 ps-(--tree-padding) outline-hidden select-none not-last:pb-0.5 focus:z-20 data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n          className\n        )}\n        data-focus={\n          typeof item.isFocused === \"function\"\n            ? item.isFocused() || false\n            : undefined\n        }\n        data-folder={\n          typeof item.isFolder === \"function\"\n            ? item.isFolder() || false\n            : undefined\n        }\n        data-selected={\n          typeof item.isSelected === \"function\"\n            ? item.isSelected() || false\n            : undefined\n        }\n        data-drag-target={\n          typeof item.isDragTarget === \"function\"\n            ? item.isDragTarget() || false\n            : undefined\n        }\n        data-search-match={\n          typeof item.isMatchingSearch === \"function\"\n            ? item.isMatchingSearch() || false\n            : undefined\n        }\n        aria-expanded={item.isExpanded()}\n        {...otherProps}\n      >\n        {children}\n      </Comp>\n    </TreeContext.Provider>\n  )\n}\n\ninterface TreeItemLabelProps<T = any>\n  extends React.HTMLAttributes<HTMLSpanElement> {\n  item?: ItemInstance<T>\n}\n\nfunction TreeItemLabel<T = any>({\n  item: propItem,\n  children,\n  className,\n  ...props\n}: TreeItemLabelProps<T>) {\n  const { currentItem } = useTreeContext<T>()\n  const item = propItem || currentItem\n\n  if (!item) {\n    console.warn(\"TreeItemLabel: No item provided via props or context\")\n    return null\n  }\n\n  return (\n    <span\n      data-slot=\"tree-item-label\"\n      className={cn(\n        \"in-focus-visible:ring-ring/50 bg-background hover:bg-accent in-data-[selected=true]:bg-accent in-data-[selected=true]:text-accent-foreground in-data-[drag-target=true]:bg-accent flex items-center gap-1 rounded-sm px-2 py-1.5 text-sm transition-colors not-in-data-[folder=true]:ps-7 in-focus-visible:ring-[3px] in-data-[search-match=true]:bg-blue-50! [&_svg]:pointer-events-none [&_svg]:shrink-0\",\n        className\n      )}\n      {...props}\n    >\n      {item.isFolder() && (\n        <ChevronDownIcon className=\"text-muted-foreground size-4 in-aria-[expanded=false]:-rotate-90\" />\n      )}\n      {children ||\n        (typeof item.getItemName === \"function\" ? item.getItemName() : null)}\n    </span>\n  )\n}\n\nfunction TreeDragLine({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  const { tree } = useTreeContext()\n\n  if (!tree || typeof tree.getDragLineStyle !== \"function\") {\n    console.warn(\n      \"TreeDragLine: No tree provided via context or tree does not have getDragLineStyle method\"\n    )\n    return null\n  }\n\n  const dragLine = tree.getDragLineStyle()\n  return (\n    <div\n      style={dragLine}\n      className={cn(\n        \"bg-primary before:bg-background before:border-primary absolute z-30 -mt-px h-0.5 w-[unset] before:absolute before:-top-[3px] before:left-0 before:size-2 before:rounded-full before:border-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Tree, TreeItem, TreeItemLabel, TreeDragLine }\n",
      "path": "registry/default/ui/tree.tsx"
    }
  ],
  "meta": {
    "tags": [
      "tree"
    ]
  }
}
