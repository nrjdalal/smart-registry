{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bin-index",
  "type": "registry:file",
  "dependencies": [
    "tinyglobby"
  ],
  "files": [
    {
      "type": "registry:file",
      "target": "bin/index.ts",
      "content": "#!/usr/bin/env node\nimport fs from \"node:fs\"\nimport path from \"node:path\"\nimport { parseArgs } from \"node:util\"\nimport { getAliases } from \"@/bin/utils/aliases\"\nimport {\n  getFiles,\n  getImports,\n  normalizeAndFilter,\n  normalizeImports,\n} from \"@/bin/utils/files\"\nimport { author, name, version } from \"@/package.json\"\n\nconst helpMessage = `Version:\n  ${name}@${version}\n\nUsage:\n  $ ${name} [options]\n\nOptions:\n  -v, --version  Display version\n  -h, --help     Display help\n\nAuthor:\n  ${author.name} <${author.email}> (${author.url})`\n\nconst parse: typeof parseArgs = (config) => {\n  try {\n    return parseArgs(config)\n  } catch (err: any) {\n    throw new Error(`Error parsing arguments: ${err.message}`)\n  }\n}\n\nconst main = async () => {\n  try {\n    const { positionals, values } = parse({\n      allowPositionals: true,\n      options: {\n        files: { type: \"string\", multiple: true, short: \"f\" },\n        directories: { type: \"string\", multiple: true, short: \"d\" },\n        help: { type: \"boolean\", short: \"h\" },\n        version: { type: \"boolean\", short: \"v\" },\n      },\n    })\n\n    if (!positionals.length) {\n      if (values.version) {\n        console.log(`${name}@${version}`)\n        process.exit(0)\n      }\n      if (values.help) {\n        console.log(helpMessage)\n        process.exit(0)\n      }\n    }\n\n    const config = {\n      files: values.files || [],\n      directories: values.directories || [],\n    }\n\n    if (!config.files.length && !config.directories.length) {\n      if (\n        !fs.existsSync(\"registry\") &&\n        !fs.existsSync(\"components\") &&\n        !fs.existsSync(\"src/components\")\n      ) {\n        throw new Error(\n          \"No files or directories provided and no registry/component folder found\",\n        )\n      }\n\n      if (fs.existsSync(\"registry\")) {\n        config.directories.push(\"registry\")\n      } else if (fs.existsSync(\"components\")) {\n        config.directories.push(\"components\")\n      } else {\n        config.directories.push(\"src/components\")\n      }\n    }\n\n    const files = await getFiles()\n    const aliases = await getAliases()\n\n    const normalizedConfig = {\n      files: normalizeAndFilter({\n        paths: config.files,\n        files,\n        aliases,\n      }),\n      directories: normalizeAndFilter({\n        paths: config.directories,\n        files,\n        aliases,\n        directory: true,\n      }),\n    }\n\n    const configFiles = [\n      ...normalizedConfig.files,\n      ...files.filter((file) =>\n        normalizedConfig.directories.some((directory) =>\n          file.startsWith(directory),\n        ),\n      ),\n    ]\n\n    let registryConfig: { name?: string; homepage?: string; items?: any[] } = {}\n\n    if (fs.existsSync(\"registry.json\")) {\n      registryConfig = JSON.parse(\n        await fs.promises.readFile(\"registry.json\", \"utf-8\"),\n      )\n    }\n\n    const registryJson: {\n      $schema?: string\n      name?: string\n      homepage?: string\n      description?: string\n      items?: {\n        $schema?: string\n        name?: string\n        type?: string\n        dependencies?: string[]\n        files?: {\n          type?: string\n          target?: string\n          content?: string\n          path?: string\n        }[]\n      }[]\n    } = {\n      $schema: \"https://ui.shadcn.com/schema/registry.json\",\n      name: registryConfig.name || \"acme\",\n      homepage: registryConfig.homepage || \"https://acme.com\",\n      description: `${registryConfig.name || \"acme\"} registry schema w/o content`,\n      items: [],\n    }\n\n    registryJson.items = []\n\n    for (const file of configFiles) {\n      if (file === \"registry.json\") continue\n\n      let imports = normalizeImports({\n        imports: await getImports({\n          filePath: file,\n          aliases,\n          files,\n        }),\n        aliases,\n      })\n\n      console.log(`Processing ${file}`)\n\n      const name = file\n        .replace(/^src\\//, \"\")\n        .replace(/^registry\\/[^\\/]+\\/blocks\\//, \"blocks/\")\n        .replace(/^registry\\/default\\/components\\//, `components/`)\n        .replace(/^registry\\/([^\\/]+)\\/components\\//, \"components/$1/\")\n        .replace(/^registry\\/[^\\/]+\\/ui\\//, \"components/ui/\")\n        .replace(/^registry\\/[^\\/]+\\/hooks\\//, \"hooks/\")\n        .replace(/^registry\\/[^\\/]+\\/lib\\//, \"lib/\")\n        .replace(/^registry\\//, \"\")\n        .replace(/^blocks\\//, \"\")\n        .replace(/^components\\/ui\\//, \"\")\n        .replace(/^components\\//, \"\")\n        .replace(/^hooks\\//, \"\")\n        .replace(/^lib\\//, \"\")\n        .replace(/\\..*$/, \"\")\n        .replace(/\\//g, \"-\")\n\n      const getType = (filePath: string) => {\n        return (\n          filePath\n            .match(/^(block|components\\/ui|components|hooks|lib)/)?.[0]\n            .replace(\"components/ui\", \"registry:ui\")\n            .replace(\"components\", \"registry:component\")\n            .replace(\"hooks\", \"registry:hook\")\n            .replace(\"lib\", \"registry:lib\")\n            .replace(\"blocks\", \"registry:block\") || \"registry:file\"\n        )\n      }\n\n      let registryItem: boolean | { [key: string]: any } =\n        files.includes(\"registry.json\")\n      let registryFiles: any = null\n\n      if (registryConfig) {\n        const items = registryConfig.items || []\n\n        registryItem = items.find((item: any) => item.name === name) || {}\n\n        if (typeof registryItem === \"object\" && registryItem.files) {\n          registryFiles = await Promise.all(\n            registryItem.files.map(async (file: { path: string }) => {\n              return normalizeImports({\n                imports: await getImports({\n                  filePath: file.path,\n                  aliases,\n                  files,\n                }),\n                aliases,\n              })\n            }),\n          )\n\n          registryFiles = registryFiles.reduce((acc: any, curr: any) => {\n            return {\n              data: {\n                files: [...acc.data.files, ...curr.data.files],\n                dependencies: [\n                  ...acc.data.dependencies,\n                  ...curr.data.dependencies,\n                ],\n                orignal: [...acc.data.orignal, ...curr.data.orignal],\n              },\n              content: {\n                ...acc.content,\n                ...curr.content,\n              },\n            }\n          })\n\n          delete registryItem.dependencies\n          delete registryItem.files\n          delete registryItem.name\n          delete registryItem.type\n          delete registryItem.registryDependencies\n        }\n      }\n\n      if (registryFiles) {\n        imports.data = {\n          files: Array.from(\n            new Set([...imports.data.files, ...registryFiles.data.files]),\n          ),\n          dependencies: Array.from(\n            new Set([\n              ...imports.data.dependencies,\n              ...registryFiles.data.dependencies,\n            ]),\n          ),\n          orignal: Array.from(\n            new Set([...imports.data.orignal, ...registryFiles.data.orignal]),\n          ),\n        }\n        imports.content = {\n          ...imports.content,\n          ...registryFiles.content,\n        }\n      }\n\n      const outputPath = path.join(\"public\", \"r\", `${name}.json`)\n      const outputData = {\n        $schema: \"https://ui.shadcn.com/schema/registry-item.json\",\n        name,\n        type: getType(imports.data.files[0]),\n        ...(imports.data.dependencies.length && {\n          dependencies: imports.data.dependencies,\n        }),\n        files: imports.data.files.map((file) => {\n          return {\n            type: getType(file),\n            target: file,\n            content: imports.content[file],\n            path: imports.data.orignal[imports.data.files.indexOf(file)],\n          }\n        }),\n        ...(typeof registryItem === \"object\" && registryItem !== null\n          ? registryItem\n          : {}),\n      }\n\n      outputData.dependencies?.sort()\n\n      outputData.files.sort((a, b) => {\n        return a.target.localeCompare(b.target)\n      })\n      const typeOrder = {\n        \"registry:block\": 1,\n        \"registry:file\": 2,\n        \"registry:component\": 3,\n        \"registry:ui\": 4,\n        \"registry:hook\": 5,\n        \"registry:lib\": 6,\n      }\n      outputData.files.sort((a, b) => {\n        return (\n          typeOrder[a.type as keyof typeof typeOrder] -\n          typeOrder[b.type as keyof typeof typeOrder]\n        )\n      })\n\n      const prepareItem = {\n        ...outputData,\n        $schema: undefined,\n        files: outputData.files.map(({ content, ...rest }) => rest),\n      }\n\n      registryJson.items.push(prepareItem)\n\n      fs.mkdirSync(path.dirname(outputPath), { recursive: true })\n      fs.writeFileSync(\n        outputPath,\n        JSON.stringify(outputData, null, 2) + \"\\n\",\n        \"utf-8\",\n      )\n    }\n\n    registryJson.items = registryJson.items.sort((a, b) => {\n      return (a.name || \"\").localeCompare(b.name || \"\")\n    })\n\n    const registryMapPath = path.join(\"public\", \"r\", \"registry.json\")\n    fs.writeFileSync(\n      registryMapPath,\n      JSON.stringify(registryJson, null, 2) + \"\\n\",\n      \"utf-8\",\n    )\n\n    process.exit(0)\n  } catch (err: any) {\n    console.error(helpMessage)\n    console.error(`\\n${err.message}\\n`)\n    process.exit(1)\n  }\n}\n\nmain()\n",
      "path": "bin/index.ts"
    },
    {
      "type": "registry:file",
      "target": "bin/utils/aliases.ts",
      "content": "import fs from \"node:fs\"\n\nexport const getAliases = async () => {\n  const isTypescript = fs.existsSync(\"tsconfig.json\")\n\n  if (isTypescript) {\n    let tsconfig = await fs.promises.readFile(\"tsconfig.json\", \"utf8\")\n    tsconfig = tsconfig.replace(/,\\s*([\\}\\]])/g, \"$1\")\n    const { compilerOptions } = JSON.parse(tsconfig)\n    if (compilerOptions && compilerOptions.paths) {\n      return Object.entries(\n        compilerOptions.paths as Record<string, [string]>,\n      ).reduce(\n        (acc, [key, [value]]) => {\n          acc[key.replace(/\\*$/, \"\")] = value\n            .replace(/^\\.\\//, \"\")\n            .replace(/\\*$/, \"\")\n          return acc\n        },\n        {} as Record<string, string>,\n      )\n    }\n  }\n\n  return {}\n}\n",
      "path": "bin/utils/aliases.ts"
    },
    {
      "type": "registry:file",
      "target": "bin/utils/files.ts",
      "content": "import fs from \"node:fs\"\nimport path from \"node:path\"\nimport { glob } from \"tinyglobby\"\n\nexport const getFiles = async ({\n  patterns = [\"**\", \".**\"],\n  ignore = [] as string[],\n} = {}) => {\n  patterns = Array.isArray(patterns) ? patterns : [patterns]\n  ignore = Array.isArray(ignore) ? ignore : [ignore]\n\n  if (fs.existsSync(\".gitignore\")) {\n    const gitignorePatterns: string[] = (\n      await fs.promises.readFile(\".gitignore\", \"utf8\")\n    )\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line && !line.startsWith(\"#\"))\n      .map((line) => line.replace(/^\\//, \"\"))\n    ignore = ignore.concat(gitignorePatterns)\n  }\n\n  return await glob(patterns, {\n    ignore: ignore.filter((ig) => !patterns.includes(ig)),\n  })\n}\n\nexport const normalizeAndFilter = ({\n  paths = [],\n  directory = false,\n  aliases = {},\n  files = [],\n}: {\n  paths: string[]\n  directory?: boolean\n  aliases?: Record<string, string>\n  files?: string[]\n}): string[] => {\n  return paths\n    .map((path) => {\n      path = path.replace(/^\\.\\//, \"\")\n      for (const alias in aliases) {\n        if (path.startsWith(alias)) {\n          return path.replace(alias, aliases[alias])\n        }\n      }\n      return path\n    })\n    .filter((path) => {\n      if (directory) {\n        return files.some((file) => file.startsWith(path))\n      } else {\n        return files.includes(path)\n      }\n    })\n}\n\nexport const getImports = async ({\n  filePath,\n  aliases = {},\n  files = [],\n}: {\n  filePath: string\n  aliases?: Record<string, string>\n  files?: string[]\n}) => {\n  const content: Record<string, string> = {}\n\n  const data: { dependencies: string[]; files: string[] } = {\n    dependencies: [],\n    files: [],\n  }\n\n  const fileContent = content[filePath] || fs.readFileSync(filePath, \"utf-8\")\n\n  content[filePath] = fileContent\n\n  const importStatements = fileContent.match(\n    /import\\s+[\\s\\S]*?\\s+from\\s+['\"].*['\"]|import\\s+['\"].*['\"]/g,\n  )\n\n  if (!importStatements) {\n    data.files.push(filePath)\n    content[filePath] = fileContent\n    return { data, content }\n  }\n\n  const importFroms = importStatements\n    .map((statement) => {\n      const match = statement.match(/['\"](.*)['\"]/)\n      return match ? match[1] : null\n    })\n    .filter((importFrom): importFrom is string => Boolean(importFrom))\n\n  for (const importFrom of importFroms) {\n    const aliasKey = Object.keys(aliases).find((key) =>\n      importFrom.startsWith(key),\n    )\n    if (aliasKey) {\n      let resolvedPath = path.join(\n        aliases[aliasKey],\n        importFrom.slice(aliasKey.length),\n      )\n\n      resolvedPath =\n        files.find((file) => file.startsWith(resolvedPath + \".\")) ||\n        resolvedPath\n      if (!data.files.includes(resolvedPath)) {\n        data.files.push(resolvedPath)\n      }\n    } else if (importFrom.startsWith(\".\")) {\n      let resolvedPath = path.join(path.dirname(filePath), importFrom)\n      resolvedPath = files.find((file) => file.startsWith(resolvedPath)) || \"\"\n      if (!data.files.includes(resolvedPath)) {\n        data.files.push(resolvedPath)\n      }\n    } else {\n      const packageName = importFrom.startsWith(\"@\")\n        ? importFrom.split(\"/\").slice(0, 2).join(\"/\")\n        : importFrom.split(\"/\")[0]\n      if (!data.dependencies.includes(packageName)) {\n        data.dependencies.push(packageName)\n      }\n    }\n  }\n\n  const uniqueFiles = new Set(data.files)\n\n  for (const file of uniqueFiles) {\n    const importsData = await getImports({\n      filePath: file,\n      aliases,\n      files,\n    })\n    content[file] = importsData.content[file]\n    importsData.data.files.forEach((importFile) => uniqueFiles.add(importFile))\n    importsData.data.dependencies.forEach((dependency) => {\n      if (!data.dependencies.includes(dependency)) {\n        data.dependencies.push(dependency)\n      }\n    })\n  }\n\n  data.files = [filePath, ...Array.from(uniqueFiles)]\n\n  return { data, content }\n}\n\nexport const normalizeImports = ({\n  imports,\n  aliases,\n}: {\n  imports: {\n    content: Record<string, string>\n    data: {\n      files: string[]\n      dependencies: string[]\n    }\n  }\n  aliases: Record<string, string>\n}) => {\n  const cwd = path.basename(process.cwd())\n\n  const normalizePath = (file: string) => {\n    return file\n      .replace(/^registry\\/[^\\/]+\\/blocks\\//, \"blocks/\")\n      .replace(/^registry\\/default\\/components\\//, `components/${cwd}/`)\n      .replace(/^registry\\/([^\\/]+)\\/components\\//, \"components/$1/\")\n      .replace(/^registry\\/[^\\/]+\\/ui\\//, \"components/ui/\")\n      .replace(/^registry\\/[^\\/]+\\/hooks\\//, \"hooks/\")\n      .replace(/^registry\\/[^\\/]+\\/lib\\//, \"lib/\")\n  }\n\n  const content = Object.fromEntries(\n    Object.entries(imports.content).map(([key, value]) => {\n      const aliasKey = Object.keys(aliases).find((alias) =>\n        key.startsWith(aliases[alias]),\n      )\n      const normalizedKey = aliasKey ? key.replace(aliases[aliasKey], \"\") : key\n      return [normalizePath(normalizedKey), value]\n    }),\n  )\n\n  const target = imports.data.files.map((file: string) =>\n    normalizePath(\n      Object.keys(aliases).reduce(\n        (acc, alias) => acc.replace(aliases[alias], \"\"),\n        file,\n      ),\n    ),\n  )\n\n  const dependencies = imports.data.dependencies.filter(\n    (dep) => !dep.startsWith(\"node:\"),\n  )\n\n  const normalizedContent = Object.fromEntries(\n    Object.entries(content).map(([key, value]) => {\n      return [\n        key,\n        value\n          .replace(/import\\s+['\"](.*)['\"]/, (match) => {\n            return match\n          })\n          .replace(/@\\/registry\\/[^\\/]+\\/blocks\\//g, \"@/blocks/\")\n          .replace(\n            /@\\/registry\\/default\\/components\\//g,\n            `@/components/${cwd}/`,\n          )\n          .replace(/@\\/registry\\/([^\\/]+)\\/components\\//g, \"@/components/$1/\")\n          .replace(/@\\/registry\\/[^\\/]+\\/ui\\//g, \"@/components/ui/\")\n          .replace(/@\\/registry\\/[^\\/]+\\/hooks\\//g, \"@/hooks/\")\n          .replace(/@\\/registry\\/[^\\/]+\\/lib\\//g, \"@/lib/\"),\n      ]\n    }),\n  )\n\n  return {\n    content: normalizedContent,\n    data: { dependencies, files: target, orignal: imports.data.files },\n  }\n}\n",
      "path": "bin/utils/files.ts"
    },
    {
      "type": "registry:file",
      "target": "package.json",
      "content": "{\n  \"name\": \"smart-registry\",\n  \"version\": \"0.0.21\",\n  \"description\": \"smart-registry\",\n  \"keywords\": [\n    \"smart-registry\"\n  ],\n  \"homepage\": \"https://github.com/nrjdalal/smart-registry#readme\",\n  \"bugs\": \"https://github.com/nrjdalal/smart-registry/issues\",\n  \"repository\": \"nrjdalal/smart-registry\",\n  \"funding\": \"https://github.com/sponsors/nrjdalal\",\n  \"license\": \"MIT\",\n  \"author\": {\n    \"name\": \"Neeraj Dalal\",\n    \"email\": \"admin@nrjdalal.com\",\n    \"url\": \"https://nrjdalal.com\"\n  },\n  \"type\": \"module\",\n  \"bin\": \"./dist/bin/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"cli\": \"bun run build && node dist/bin/index.js\",\n    \"dev\": \"tsup --watch\",\n    \"prepare\": \"if [ \\\"$NODE_ENV\\\" != \\\"production\\\" ]; then npx simple-git-hooks; fi\",\n    \"publish:latest\": \"NODE_ENV=production changeset publish\"\n  },\n  \"simple-git-hooks\": {\n    \"pre-commit\": \"npx lint-staged\",\n    \"commit-msg\": \"npx commitlint --edit $1\"\n  },\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-conventional\"\n    ]\n  },\n  \"lint-staged\": {\n    \"*\": \"prettier --write --ignore-unknown\",\n    \"package.json\": \"sort-package-json\"\n  },\n  \"prettier\": {\n    \"plugins\": [\n      \"@ianvs/prettier-plugin-sort-imports\"\n    ],\n    \"semi\": false\n  },\n  \"dependencies\": {\n    \"tinyglobby\": \"^0.2.12\"\n  },\n  \"devDependencies\": {\n    \"@changesets/changelog-github\": \"^0.5.0\",\n    \"@changesets/cli\": \"^2.27.10\",\n    \"@commitlint/cli\": \"^19.6.0\",\n    \"@commitlint/config-conventional\": \"^19.6.0\",\n    \"@ianvs/prettier-plugin-sort-imports\": \"^4.4.0\",\n    \"@types/node\": \"^22.10.1\",\n    \"lint-staged\": \"^15.2.10\",\n    \"prettier\": \"^3.4.2\",\n    \"simple-git-hooks\": \"^2.11.1\",\n    \"sort-package-json\": \"^2.14.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.2\"\n  }\n}\n",
      "path": "package.json"
    }
  ]
}
