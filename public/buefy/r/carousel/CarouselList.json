{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "carousel/CarouselList",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/carousel/CarouselList.vue",
      "content": "<template>\n    <div\n        class=\"carousel-list\"\n        :class=\"{'has-shadow': scrollIndex > 0}\"\n        @mousedown.prevent=\"dragStart\"\n        @touchstart=\"dragStart\">\n        <div\n            class=\"carousel-slides\"\n            :class=\"listClass\"\n            :style=\"'transform:translateX('+translation+'px)'\">\n            <div\n                v-for=\"(list, index) in data\"\n                class=\"carousel-slide\"\n                :class=\"{'is-active': asIndicator ? activeItem === index : scrollIndex === index}\"\n                @mouseup=\"checkAsIndicator(index, $event)\"\n                @touchend=\"checkAsIndicator(index, $event)\"\n                :key=\"index\"\n                :style=\"itemStyle\">\n                <slot\n                    :index=\"index\"\n                    :active=\"activeItem\"\n                    :scroll=\"scrollIndex\"\n                    v-bind=\"list\"\n                    :list=\"list\"\n                    name=\"item\">\n                    <b-image\n                        :src=\"list.image\"\n                        v-bind=\"list\"\n                    />\n                </slot>\n            </div>\n        </div>\n        <div\n            v-if=\"arrow\"\n            class=\"carousel-arrow\"\n            :class=\"{'is-hovered': settings.arrowHover}\">\n            <b-icon\n                v-show=\"hasPrev\"\n                class=\"has-icons-left\"\n                @click.native.prevent=\"prev\"\n                :pack=\"settings.iconPack\"\n                :icon=\"settings.iconPrev\"\n                :size=\"settings.iconSize\"\n                both />\n            <b-icon\n                v-show=\"hasNext\"\n                class=\"has-icons-right\"\n                @click.native.prevent=\"next\"\n                :pack=\"settings.iconPack\"\n                :icon=\"settings.iconNext\"\n                :size=\"settings.iconSize\"\n                both />\n        </div>\n    </div>\n</template>\n\n<script>\nimport {sign, mod, bound} from '@/utils/helpers'\nimport config from '@/utils/config'\n\nimport Icon from '@/components/icon/Icon'\nimport Image from '@/components/image/Image'\n\nexport default {\n    name: 'BCarouselList',\n    components: {\n        [Icon.name]: Icon,\n        [Image.name]: Image\n    },\n    props: {\n        data: {\n            type: Array,\n            default: () => []\n        },\n        value: {\n            type: Number,\n            default: 0\n        },\n        scrollValue: {\n            type: Number,\n            default: 0\n        },\n        hasDrag: {\n            type: Boolean,\n            default: true\n        },\n        hasGrayscale: Boolean,\n        hasOpacity: Boolean,\n        repeat: Boolean,\n        itemsToShow: {\n            type: Number,\n            default: 4\n        },\n        itemsToList: {\n            type: Number,\n            default: 1\n        },\n        asIndicator: Boolean,\n        arrow: {\n            type: Boolean,\n            default: true\n        },\n        arrowHover: {\n            type: Boolean,\n            default: true\n        },\n        iconPack: String,\n        iconSize: String,\n        iconPrev: {\n            type: String,\n            default: () => {\n                return config.defaultIconPrev\n            }\n        },\n        iconNext: {\n            type: String,\n            default: () => {\n                return config.defaultIconNext\n            }\n        },\n        breakpoints: {\n            type: Object,\n            default: () => ({})\n        }\n    },\n    data() {\n        return {\n            activeItem: this.value,\n            scrollIndex: this.asIndicator ? this.scrollValue : this.value,\n            delta: 0,\n            dragX: false,\n            hold: 0,\n            windowWidth: 0,\n            touch: false,\n            observer: null,\n            refresh_: 0\n        }\n    },\n    computed: {\n        dragging() {\n            return this.dragX !== false\n        },\n        listClass() {\n            return [\n                {\n                    'has-grayscale': this.settings.hasGrayscale,\n                    'has-opacity': this.settings.hasOpacity,\n                    'is-dragging': this.dragging\n                }\n            ]\n        },\n        itemStyle() {\n            return `width: ${this.itemWidth}px;`\n        },\n        translation() {\n            return -bound(\n                this.delta + (this.scrollIndex * this.itemWidth), 0,\n                (this.data.length - this.settings.itemsToShow) * this.itemWidth\n            )\n        },\n        total() {\n            return this.data.length - this.settings.itemsToShow\n        },\n        hasPrev() {\n            return (this.settings.repeat || this.scrollIndex > 0)\n        },\n        hasNext() {\n            return (this.settings.repeat || this.scrollIndex < this.total)\n        },\n        breakpointKeys() {\n            return Object.keys(this.breakpoints).sort((a, b) => b - a)\n        },\n        settings() {\n            let breakpoint = this.breakpointKeys.filter((breakpoint) => {\n                if (this.windowWidth >= breakpoint) {\n                    return true\n                }\n            })[0]\n            if (breakpoint) {\n                return {...this.$props, ...this.breakpoints[breakpoint]}\n            }\n            return this.$props\n        },\n        itemWidth() {\n            if (this.windowWidth) { // Ensure component is mounted\n                /* eslint-disable-next-line */\n                this.refresh_; // We force the computed property to refresh if this prop is changed\n\n                const rect = this.$el.getBoundingClientRect()\n                return rect.width / this.settings.itemsToShow\n            }\n            return 0\n        }\n    },\n    watch: {\n        /**\n         * When v-model is changed set the new active item.\n         */\n        value(value) {\n            this.switchTo(this.asIndicator ? value - (this.itemsToShow - 3) / 2 : value)\n            if (this.activeItem !== value) {\n                this.activeItem = bound(value, 0, this.data.length - 1)\n            }\n        },\n        scrollValue(value) {\n            this.switchTo(value)\n        }\n    },\n    methods: {\n        resized() {\n            this.windowWidth = window.innerWidth\n        },\n        switchTo(newIndex) {\n            if (newIndex === this.scrollIndex || isNaN(newIndex)) { return }\n\n            if (this.settings.repeat) {\n                newIndex = mod(newIndex, this.total + 1)\n            }\n            newIndex = bound(newIndex, 0, this.total)\n            this.scrollIndex = newIndex\n            if (!this.asIndicator && this.value !== newIndex) {\n                this.$emit('input', newIndex)\n            } else if (this.scrollIndex !== newIndex) {\n                this.$emit('updated:scroll', newIndex)\n            }\n        },\n        next() {\n            this.switchTo(this.scrollIndex + this.settings.itemsToList)\n        },\n        prev() {\n            this.switchTo(this.scrollIndex - this.settings.itemsToList)\n        },\n        checkAsIndicator(value, event) {\n            if (!this.asIndicator) return\n\n            const dragEndX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX\n            if (this.hold - Date.now() > 2000 || Math.abs(this.dragX - dragEndX) > 10) return\n\n            this.dragX = false\n            this.hold = 0\n            event.preventDefault()\n\n            // Make the item appear in the middle\n            this.activeItem = value\n\n            this.$emit('switch', value)\n        },\n        // handle drag event\n        dragStart(event) {\n            if (this.dragging || !this.settings.hasDrag || (event.button !== 0 && event.type !== 'touchstart')) return\n            this.hold = Date.now()\n            this.touch = !!event.touches\n            this.dragX = this.touch ? event.touches[0].clientX : event.clientX\n            window.addEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove)\n            window.addEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd)\n        },\n        dragMove(event) {\n            if (!this.dragging) return\n            const dragEndX = event.touches\n                ? (event.changedTouches[0] || event.touches[0]).clientX : event.clientX\n            this.delta = this.dragX - dragEndX\n            if (!event.touches) {\n                event.preventDefault()\n            }\n        },\n        dragEnd() {\n            if (!this.dragging && !this.hold) return\n            if (this.hold) {\n                const signCheck = sign(this.delta)\n                const results = Math.round(Math.abs(this.delta / this.itemWidth) + 0.15)// Hack\n                this.switchTo(this.scrollIndex + signCheck * results)\n            }\n            this.delta = 0\n            this.dragX = false\n            window.removeEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove)\n            window.removeEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd)\n        },\n        refresh() {\n            this.$nextTick(() => {\n                this.refresh_++\n            })\n        }\n    },\n    mounted() {\n        if (typeof window !== 'undefined') {\n            if (window.ResizeObserver) {\n                this.observer = new ResizeObserver(this.refresh)\n                this.observer.observe(this.$el)\n            }\n            window.addEventListener('resize', this.resized)\n            document.addEventListener('animationend', this.refresh)\n            document.addEventListener('transitionend', this.refresh)\n            document.addEventListener('transitionstart', this.refresh)\n            this.resized()\n        }\n        if (this.$attrs.config) {\n            throw new Error('The config prop was removed, you need to use v-bind instead')\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            if (window.ResizeObserver) {\n                this.observer.disconnect()\n            }\n            window.removeEventListener('resize', this.resized)\n            document.removeEventListener('animationend', this.refresh)\n            document.removeEventListener('transitionend', this.refresh)\n            document.removeEventListener('transitionstart', this.refresh)\n            this.dragEnd()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/carousel/CarouselList.vue"
    },
    {
      "type": "registry:component",
      "target": "components/icon/Icon.vue",
      "content": "<template>\n    <span class=\"icon\" :class=\"[newType, size]\">\n        <i\n            v-if=\"!useIconComponent\"\n            :class=\"[newPack, newIcon, newCustomSize, customClass]\"/>\n\n        <component\n            v-else\n            :is=\"useIconComponent\"\n            :icon=\"[newPack, newIcon]\"\n            :size=\"newCustomSize\"\n            :class=\"[customClass]\"/>\n    </span>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport getIcons from '@/utils/icons'\n\nexport default {\n    name: 'BIcon',\n    props: {\n        type: [String, Object],\n        component: String,\n        pack: String,\n        icon: String,\n        size: String,\n        customSize: String,\n        customClass: String,\n        both: Boolean // This is used internally to show both MDI and FA icon\n    },\n    computed: {\n        iconConfig() {\n            let allIcons = getIcons()\n            return allIcons[this.newPack]\n        },\n        iconPrefix() {\n            if (this.iconConfig && this.iconConfig.iconPrefix) {\n                return this.iconConfig.iconPrefix\n            }\n            return ''\n        },\n        /**\n        * Internal icon name based on the pack.\n        * If pack is 'fa', gets the equivalent FA icon name of the MDI,\n        * internal icons are always MDI.\n        */\n        newIcon() {\n            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`\n        },\n        newPack() {\n            return this.pack || config.defaultIconPack\n        },\n        newType() {\n            if (!this.type) return\n\n            let splitType = []\n            if (typeof this.type === 'string') {\n                splitType = this.type.split('-')\n            } else {\n                for (let key in this.type) {\n                    if (this.type[key]) {\n                        splitType = key.split('-')\n                        break\n                    }\n                }\n            }\n            if (splitType.length <= 1) return\n\n            const [, ...type] = splitType\n            return `has-text-${type.join('-')}`\n        },\n        newCustomSize() {\n            return this.customSize || this.customSizeByPack\n        },\n        customSizeByPack() {\n            if (this.iconConfig && this.iconConfig.sizes) {\n                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {\n                    return this.iconConfig.sizes[this.size]\n                } else if (this.iconConfig.sizes.default) {\n                    return this.iconConfig.sizes.default\n                }\n            }\n            return null\n        },\n        useIconComponent() {\n            return this.component || config.defaultIconComponent\n        }\n    },\n    methods: {\n        /**\n        * Equivalent icon name of the MDI.\n        */\n        getEquivalentIconOf(value) {\n            // Only transform the class if the both prop is set to true\n            if (!this.both) {\n                return value\n            }\n\n            if (this.iconConfig &&\n                this.iconConfig.internalIcons &&\n                this.iconConfig.internalIcons[value]) {\n                return this.iconConfig.internalIcons[value]\n            }\n            return value\n        }\n    }\n}\n</script>\n",
      "path": "src/components/icon/Icon.vue"
    },
    {
      "type": "registry:component",
      "target": "components/image/Image.vue",
      "content": "<template>\n    <figure\n        class=\"b-image-wrapper\"\n        :class=\"figureClasses\"\n        :style=\"figureStyles\"\n    >\n        <figcaption v-if=\"isCaptionFirst\">\n            <slot name=\"caption\" />\n        </figcaption>\n        <transition name=\"fade\">\n            <img\n                v-if=\"isDisplayed\"\n                :srcset=\"computedSrcset\"\n                :src=\"computedSrc\"\n                :alt=\"alt\"\n                :class=\"imgClasses\"\n                :width=\"computedWidth\"\n                :sizes=\"computedSizes\"\n                :loading=\"computedNativeLazy\"\n                @load=\"onLoad\"\n                @error=\"onError\"\n            >\n        </transition>\n        <transition name=\"fade\">\n            <slot\n                v-if=\"isPlaceholderDisplayed\"\n                name=\"placeholder\"\n            >\n                <img\n                    :src=\"computedPlaceholder\"\n                    :alt=\"alt\"\n                    :class=\"imgClasses\"\n                    class=\"placeholder\"\n                >\n            </slot>\n        </transition>\n        <figcaption v-if=\"isCaptionLast\">\n            <slot name=\"caption\" />\n        </figcaption>\n    </figure>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport { isWebpSupported } from '@/utils/helpers'\n\nexport default {\n    name: 'BImage',\n    props: {\n        src: String,\n        alt: String,\n        srcFallback: String,\n        webpFallback: {\n            type: String,\n            default: () => {\n                return config.defaultImageWebpFallback\n            }\n        },\n        lazy: {\n            type: Boolean,\n            default: () => {\n                return config.defaultImageLazy\n            }\n        },\n        responsive: {\n            type: Boolean,\n            default: () => {\n                return config.defaultImageResponsive\n            }\n        },\n        ratio: {\n            type: String,\n            default: () => {\n                return config.defaultImageRatio\n            }\n        },\n        placeholder: String,\n        srcset: String,\n        srcsetSizes: Array,\n        srcsetFormatter: {\n            type: Function,\n            default: (src, size, vm) => {\n                if (typeof config.defaultImageSrcsetFormatter === 'function') {\n                    return config.defaultImageSrcsetFormatter(src, size)\n                } else {\n                    return vm.formatSrcset(src, size)\n                }\n            }\n        },\n        rounded: {\n            type: Boolean,\n            default: false\n        },\n        captionFirst: {\n            type: Boolean,\n            default: false\n        },\n        customClass: String\n    },\n    data() {\n        return {\n            clientWidth: 0,\n            webpSupportVerified: false,\n            webpSupported: false,\n            useNativeLazy: false,\n            observer: null,\n            inViewPort: false,\n            bulmaKnownRatio: ['square', '1by1', '5by4', '4by3', '3by2', '5by3', '16by9', 'b2y1', '3by1', '4by5', '3by4', '2by3', '3by5', '9by16', '1by2', '1by3'],\n            loaded: false,\n            failed: false\n        }\n    },\n    computed: {\n        ratioPattern() {\n            return new RegExp(/([0-9]+)by([0-9]+)/)\n        },\n        hasRatio() {\n            return this.ratio && this.ratioPattern.test(this.ratio)\n        },\n        figureClasses() {\n            const classes = { image: this.responsive }\n            if (this.hasRatio && this.bulmaKnownRatio.indexOf(this.ratio) >= 0) {\n                classes[`is-${this.ratio}`] = true\n            }\n            return classes\n        },\n        figureStyles() {\n            if (\n                this.hasRatio &&\n                this.bulmaKnownRatio.indexOf(this.ratio) < 0\n            ) {\n                const ratioValues = this.ratioPattern.exec(this.ratio)\n                return {\n                    paddingTop: `${(ratioValues[2] / ratioValues[1]) * 100}%`\n                }\n            }\n        },\n        imgClasses() {\n            return {\n                'is-rounded': this.rounded,\n                'has-ratio': this.hasRatio,\n                [this.customClass]: !!this.customClass\n            }\n        },\n        srcExt() {\n            return this.getExt(this.src)\n        },\n        isWepb() {\n            return this.srcExt === 'webp'\n        },\n        computedSrc() {\n            let src = this.src\n            if (this.failed && this.srcFallback) {\n                src = this.srcFallback\n            }\n            if (!this.webpSupported && this.isWepb && this.webpFallback) {\n                if (this.webpFallback.startsWith('.')) {\n                    return src.replace(/\\.webp/gi, `${this.webpFallback}`)\n                }\n                return this.webpFallback\n            }\n            return src\n        },\n        computedWidth() {\n            if (this.responsive && this.clientWidth > 0) {\n                return this.clientWidth\n            }\n        },\n        computedNativeLazy() {\n            if (this.lazy && this.useNativeLazy) {\n                return 'lazy'\n            }\n        },\n        isDisplayed() {\n            return (\n                (this.webpSupportVerified || !this.isWepb) &&\n                (!this.lazy || this.useNativeLazy || this.inViewPort)\n            )\n        },\n        placeholderExt() {\n            if (this.placeholder) {\n                return this.getExt(this.placeholder)\n            }\n        },\n        isPlaceholderWepb() {\n            if (this.placeholder) {\n                return this.placeholderExt === 'webp'\n            }\n        },\n        computedPlaceholder() {\n            if (!this.webpSupported && this.isPlaceholderWepb && this.webpFallback && this.webpFallback.startsWith('.')) {\n                return this.placeholder.replace(/\\.webp/gi, `${this.webpFallback}`)\n            }\n            return this.placeholder\n        },\n        isPlaceholderDisplayed() {\n            return (\n                !this.loaded &&\n                (\n                    this.$slots.placeholder || (\n                        this.placeholder &&\n                        (this.webpSupportVerified || !this.isPlaceholderWepb)\n                    )\n                )\n            )\n        },\n        computedSrcset() {\n            if (this.srcset) {\n                if (!this.webpSupported && this.isWepb && this.webpFallback && this.webpFallback.startsWith('.')) {\n                    return this.srcset.replace(/\\.webp/gi, `${this.webpFallback}`)\n                }\n                return this.srcset\n            }\n            if (\n                this.srcsetSizes && Array.isArray(this.srcsetSizes) && this.srcsetSizes.length > 0\n            ) {\n                return this.srcsetSizes.map((size) => {\n                    return `${this.srcsetFormatter(this.computedSrc, size, this)} ${size}w`\n                }).join(',')\n            }\n        },\n        computedSizes() {\n            if (this.computedSrcset && this.computedWidth) {\n                return `${this.computedWidth}px`\n            }\n        },\n        isCaptionFirst() {\n            return this.$slots.caption && this.captionFirst\n        },\n        isCaptionLast() {\n            return this.$slots.caption && !this.captionFirst\n        }\n    },\n    methods: {\n        getExt(filename, clean = true) {\n            if (filename) {\n                const noParam = clean ? filename.split('?')[0] : filename\n                return noParam.split('.').pop()\n            }\n            return ''\n        },\n        setWidth() {\n            this.clientWidth = this.$el.clientWidth\n        },\n        formatSrcset(src, size) {\n            const ext = this.getExt(src, false)\n            const name = src.split('.').slice(0, -1).join('.')\n            return `${name}-${size}.${ext}`\n        },\n        onLoad(event) {\n            this.loaded = true\n            this.emit('load', event)\n        },\n        onError(event) {\n            this.emit('error', event)\n            if (!this.failed) {\n                this.failed = true\n            }\n        },\n        emit(eventName, event) {\n            const { target } = event\n            this.$emit(eventName, event, target.currentSrc || target.src || this.computedSrc)\n        }\n    },\n    created() {\n        if (this.isWepb) {\n            isWebpSupported().then((supported) => {\n                this.webpSupportVerified = true\n                this.webpSupported = supported\n            })\n        }\n        if (this.lazy) {\n            // We use native lazy loading if supported\n            // We try to use Intersection Observer if native lazy loading is not supported\n            // We use the lazy attribute anyway if we cannot detect support (SSR for example).\n            const nativeLazySupported = typeof window !== 'undefined' && 'HTMLImageElement' in window && 'loading' in HTMLImageElement.prototype\n            const intersectionObserverSupported = typeof window !== 'undefined' && 'IntersectionObserver' in window\n            if (!nativeLazySupported && intersectionObserverSupported) {\n                this.observer = new IntersectionObserver((events) => {\n                    const {target, isIntersecting} = events[0]\n                    if (isIntersecting && !this.inViewPort) {\n                        this.inViewPort = true\n                        this.observer.unobserve(target)\n                    }\n                })\n            } else {\n                this.useNativeLazy = true\n            }\n        }\n    },\n    mounted() {\n        if (this.lazy && this.observer) {\n            this.observer.observe(this.$el)\n        }\n        this.setWidth()\n        if (typeof window !== 'undefined') {\n            window.addEventListener('resize', this.setWidth)\n        }\n    },\n    beforeDestroy() {\n        if (this.observer) {\n            this.observer.disconnect()\n        }\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('resize', this.setWidth)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/image/Image.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/icons.js",
      "content": "import config from '@/utils/config'\nimport { merge } from '@/utils/helpers'\n\nconst mdiIcons = {\n    sizes: {\n        'default': 'mdi-24px',\n        'is-small': null,\n        'is-medium': 'mdi-36px',\n        'is-large': 'mdi-48px'\n    },\n    iconPrefix: 'mdi-'\n}\n\nconst faIcons = () => {\n    const faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-'\n    return {\n        sizes: {\n            'default': null,\n            'is-small': null,\n            'is-medium': faIconPrefix + 'lg',\n            'is-large': faIconPrefix + '2x'\n        },\n        iconPrefix: faIconPrefix,\n        internalIcons: {\n            'information': 'info-circle',\n            'alert': 'exclamation-triangle',\n            'alert-circle': 'exclamation-circle',\n            'chevron-right': 'angle-right',\n            'chevron-left': 'angle-left',\n            'chevron-down': 'angle-down',\n            'eye-off': 'eye-slash',\n            'menu-down': 'caret-down',\n            'menu-up': 'caret-up',\n            'close-circle': 'times-circle'\n        }\n    }\n}\n\nconst getIcons = () => {\n    let icons = {\n        mdi: mdiIcons,\n        fa: faIcons(),\n        fas: faIcons(),\n        far: faIcons(),\n        fad: faIcons(),\n        fab: faIcons(),\n        fal: faIcons(),\n        'fa-solid': faIcons(),\n        'fa-regular': faIcons(),\n        'fa-light': faIcons(),\n        'fa-thin': faIcons(),\n        'fa-duotone': faIcons(),\n        'fa-brands': faIcons()\n    }\n\n    if (config && config.customIconPacks) {\n        icons = merge(icons, config.customIconPacks, true)\n    }\n\n    return icons\n}\n\nexport default getIcons\n",
      "path": "src/utils/icons.js"
    }
  ]
}
