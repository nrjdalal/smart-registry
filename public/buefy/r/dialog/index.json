{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dialog/index",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:file",
      "target": "directives/trapFocus.js",
      "content": "const findFocusable = (element, programmatic = false) => {\n    if (!element) {\n        return null\n    }\n    if (programmatic) {\n        return element.querySelectorAll(`*[tabindex=\"-1\"]`)\n    }\n    return element.querySelectorAll(`a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]`)\n}\n\nlet onKeyDown\n\nconst bind = (el, { value = true }) => {\n    if (value) {\n        let focusable = findFocusable(el)\n        let focusableProg = findFocusable(el, true)\n\n        if (focusable && focusable.length > 0) {\n            onKeyDown = (event) => {\n                // Need to get focusable each time since it can change between key events\n                // ex. changing month in a datepicker\n                focusable = findFocusable(el)\n                focusableProg = findFocusable(el, true)\n                const firstFocusable = focusable[0]\n                const lastFocusable = focusable[focusable.length - 1]\n\n                if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    lastFocusable.focus()\n                } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    firstFocusable.focus()\n                }\n            }\n            el.addEventListener('keydown', onKeyDown)\n        }\n    }\n}\n\nconst unbind = (el) => {\n    el.removeEventListener('keydown', onKeyDown)\n}\n\nconst directive = {\n    bind,\n    unbind\n}\n\nexport default directive\n",
      "path": "src/directives/trapFocus.js"
    },
    {
      "type": "registry:component",
      "target": "components/button/Button.vue",
      "content": "<template>\n    <component\n        :is=\"computedTag\"\n        class=\"button\"\n        v-bind=\"$attrs\"\n        :type=\"['button', 'input'].includes(computedTag) ? nativeType : undefined\"\n        :class=\"[size, type, {\n            'is-rounded': rounded,\n            'is-loading': loading,\n            'is-outlined': outlined,\n            'is-fullwidth': expanded,\n            'is-inverted': inverted,\n            'is-focused': focused,\n            'is-active': active,\n            'is-hovered': hovered,\n            'is-selected': selected\n        }]\"\n        v-on=\"$listeners\"\n    >\n        <b-icon\n            v-if=\"iconLeft\"\n            :pack=\"iconPack\"\n            :icon=\"iconLeft\"\n            :size=\"iconSize\"\n        />\n        <span v-if=\"label\">{{ label }}</span>\n        <span v-else-if=\"$slots.default\">\n            <slot />\n        </span>\n        <b-icon\n            v-if=\"iconRight\"\n            :pack=\"iconPack\"\n            :icon=\"iconRight\"\n            :size=\"iconSize\"\n        />\n    </component>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport config from '@/utils/config'\n\nexport default {\n    name: 'BButton',\n    components: {\n        [Icon.name]: Icon\n    },\n    inheritAttrs: false,\n    props: {\n        type: [String, Object],\n        size: String,\n        label: String,\n        iconPack: String,\n        iconLeft: String,\n        iconRight: String,\n        rounded: {\n            type: Boolean,\n            default: () => {\n                return config.defaultButtonRounded\n            }\n        },\n        loading: Boolean,\n        outlined: Boolean,\n        expanded: Boolean,\n        inverted: Boolean,\n        focused: Boolean,\n        active: Boolean,\n        hovered: Boolean,\n        selected: Boolean,\n        nativeType: {\n            type: String,\n            default: 'button',\n            validator: (value) => {\n                return [\n                    'button',\n                    'submit',\n                    'reset'\n                ].indexOf(value) >= 0\n            }\n        },\n        tag: {\n            type: String,\n            default: 'button',\n            validator: (value) => {\n                return config.defaultLinkTags.indexOf(value) >= 0\n            }\n        }\n    },\n    computed: {\n        computedTag() {\n            if (this.$attrs.disabled !== undefined && this.$attrs.disabled !== false) {\n                return 'button'\n            }\n            return this.tag\n        },\n        iconSize() {\n            if (!this.size || this.size === 'is-medium') {\n                return 'is-small'\n            } else if (this.size === 'is-large') {\n                return 'is-medium'\n            }\n            return this.size\n        }\n    }\n}\n</script>\n",
      "path": "src/components/button/Button.vue"
    },
    {
      "type": "registry:component",
      "target": "components/dialog/Dialog.vue",
      "content": "<template>\n    <transition :name=\"animation\">\n        <div\n            v-if=\"isActive\"\n            class=\"dialog modal is-active\"\n            :class=\"dialogClass\"\n            v-trap-focus=\"trapFocus\"\n            :role=\"ariaRole\"\n            :aria-modal=\"ariaModal\">\n            <div class=\"modal-background\" @click=\"cancel('outside')\"/>\n            <div class=\"modal-card animation-content\">\n                <header class=\"modal-card-head\" v-if=\"title\">\n                    <p class=\"modal-card-title\">{{ title }}</p>\n                </header>\n\n                <section\n                    class=\"modal-card-body\"\n                    :class=\"{ 'is-titleless': !title, 'is-flex': hasIcon }\">\n                    <div class=\"media\">\n                        <div\n                            class=\"media-left\"\n                            v-if=\"hasIcon && (icon || iconByType)\">\n                            <b-icon\n                                :icon=\"icon ? icon : iconByType\"\n                                :pack=\"iconPack\"\n                                :type=\"type\"\n                                :both=\"!icon\"\n                                size=\"is-large\"/>\n                        </div>\n                        <div class=\"media-content\">\n                            <p>\n                                <template v-if=\"$slots.default\">\n                                    <slot />\n                                </template>\n                                <template v-else>\n                                    <div v-html=\"message\" />\n                                </template>\n                            </p>\n\n                            <div v-if=\"hasInput\" class=\"field\">\n                                <div class=\"control\">\n                                    <input\n                                        v-model=\"prompt\"\n                                        class=\"input\"\n                                        ref=\"input\"\n                                        :class=\"{ 'is-danger': validationMessage }\"\n                                        v-bind=\"inputAttrs\"\n                                        @compositionstart=\"isCompositing = true\"\n                                        @compositionend=\"isCompositing = false\"\n                                        @keydown.enter=\"confirm\">\n                                </div>\n                                <p class=\"help is-danger\">{{ validationMessage }}</p>\n                            </div>\n                        </div>\n                    </div>\n                </section>\n\n                <footer class=\"modal-card-foot\">\n                    <b-button\n                        v-if=\"showCancel\"\n                        ref=\"cancelButton\"\n                        :disabled=\"isLoading\"\n                        @click=\"cancel('button')\">{{ cancelText }}</b-button>\n                    <b-button\n                        :type=\"type\"\n                        ref=\"confirmButton\"\n                        :loading=\"isLoading\"\n                        @click=\"confirm\">{{ confirmText }}</b-button>\n                </footer>\n            </div>\n        </div>\n    </transition>\n</template>\n\n<script>\nimport trapFocus from '@/directives/trapFocus'\nimport Icon from '@/components/icon/Icon'\nimport Modal from '@/components/modal/Modal'\nimport Button from '@/components/button/Button'\nimport config from '@/utils/config'\nimport { removeElement } from '@/utils/helpers'\n\nexport default {\n    name: 'BDialog',\n    components: {\n        [Icon.name]: Icon,\n        [Button.name]: Button\n    },\n    directives: {\n        trapFocus\n    },\n    extends: Modal,\n    props: {\n        title: String,\n        message: [String, Array],\n        icon: String,\n        iconPack: String,\n        hasIcon: Boolean,\n        type: {\n            type: String,\n            default: 'is-primary'\n        },\n        size: String,\n        confirmText: {\n            type: String,\n            default: () => {\n                return config.defaultDialogConfirmText\n                    ? config.defaultDialogConfirmText\n                    : 'OK'\n            }\n        },\n        cancelText: {\n            type: String,\n            default: () => {\n                return config.defaultDialogCancelText\n                    ? config.defaultDialogCancelText\n                    : 'Cancel'\n            }\n        },\n        hasInput: Boolean, // Used internally to know if it's prompt\n        inputAttrs: {\n            type: Object,\n            default: () => ({})\n        },\n        onConfirm: {\n            type: Function,\n            default: () => {}\n        },\n        closeOnConfirm: {\n            type: Boolean,\n            default: true\n        },\n        container: {\n            type: String,\n            default: () => {\n                return config.defaultContainerElement\n            }\n        },\n        focusOn: {\n            type: String,\n            default: 'confirm'\n        },\n        trapFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultTrapFocus\n            }\n        },\n        ariaRole: {\n            type: String,\n            validator: (value) => {\n                return [\n                    'dialog',\n                    'alertdialog'\n                ].indexOf(value) >= 0\n            }\n        },\n        ariaModal: Boolean\n    },\n    data() {\n        const prompt = this.hasInput\n            ? this.inputAttrs.value || ''\n            : ''\n\n        return {\n            prompt,\n            isActive: false,\n            validationMessage: '',\n            isCompositing: false,\n            isLoading: false\n        }\n    },\n    computed: {\n        dialogClass() {\n            return [this.size, {\n                'has-custom-container': this.container !== null\n            }]\n        },\n        /**\n        * Icon name (MDI) based on the type.\n        */\n        iconByType() {\n            switch (this.type) {\n                case 'is-info':\n                    return 'information'\n                case 'is-success':\n                    return 'check-circle'\n                case 'is-warning':\n                    return 'alert'\n                case 'is-danger':\n                    return 'alert-circle'\n                default:\n                    return null\n            }\n        },\n        showCancel() {\n            return this.cancelOptions.indexOf('button') >= 0\n        }\n    },\n    methods: {\n        /**\n        * If it's a prompt Dialog, validate the input.\n        * Call the onConfirm prop (function) and close the Dialog.\n        */\n        confirm() {\n            if (this.$refs.input !== undefined) {\n                if (this.isCompositing) return\n                if (!this.$refs.input.checkValidity()) {\n                    this.validationMessage = this.$refs.input.validationMessage\n                    this.$nextTick(() => this.$refs.input.select())\n                    return\n                }\n            }\n            this.$emit('confirm', this.prompt)\n            this.onConfirm(this.prompt, this)\n            if (this.closeOnConfirm) this.close()\n        },\n\n        /**\n        * Close the Dialog.\n        */\n        close() {\n            this.isActive = false\n            this.isLoading = false\n            // Timeout for the animation complete before destroying\n            setTimeout(() => {\n                this.$destroy()\n                removeElement(this.$el)\n            }, 150)\n        },\n\n        /**\n        * Start the Loading.\n        */\n        startLoading() {\n            this.isLoading = true\n        },\n\n        /**\n        * Cancel the Loading.\n        */\n        cancelLoading() {\n            this.isLoading = false\n        }\n    },\n    beforeMount() {\n        // Insert the Dialog component in the element container\n        if (typeof window !== 'undefined') {\n            this.$nextTick(() => {\n                const container = document.querySelector(this.container) || document.body\n                container.appendChild(this.$el)\n            })\n        }\n    },\n    mounted() {\n        this.isActive = true\n\n        if (typeof this.inputAttrs.required === 'undefined') {\n            this.$set(this.inputAttrs, 'required', true)\n        }\n\n        this.$nextTick(() => {\n            // Handle which element receives focus\n            if (this.hasInput) {\n                this.$refs.input.focus()\n            } else if (this.focusOn === 'cancel' && this.showCancel) {\n                this.$refs.cancelButton.$el.focus()\n            } else {\n                this.$refs.confirmButton.$el.focus()\n            }\n        })\n    }\n}\n</script>\n",
      "path": "src/components/dialog/Dialog.vue"
    },
    {
      "type": "registry:component",
      "target": "components/dialog/index.js",
      "content": "import Dialog from '@/components/dialog/Dialog'\n\nimport config, { VueInstance } from '@/utils/config'\nimport { merge } from '@/utils/helpers'\nimport { use, registerComponent, registerComponentProgrammatic } from '@/utils/plugins'\n\nlet localVueInstance\n\nfunction open(propsData) {\n    let slot\n    if (Array.isArray(propsData.message)) {\n        slot = propsData.message\n        delete propsData.message\n    }\n    const vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance || VueInstance\n    const DialogComponent = vm.extend(Dialog)\n    const component = new DialogComponent({\n        el: document.createElement('div'),\n        propsData\n    })\n    if (slot) {\n        component.$slots.default = slot\n        component.$forceUpdate()\n    }\n    if (!config.defaultProgrammaticPromise) {\n        return component\n    } else {\n        return new Promise((resolve) => {\n            component.$on('confirm', (event) => resolve({ result: event || true, dialog: component }))\n            component.$on('cancel', () => resolve({ result: false, dialog: component }))\n        })\n    }\n}\n\nconst DialogProgrammatic = {\n    alert(params) {\n        if (typeof params === 'string') {\n            params = {\n                message: params\n            }\n        }\n        const defaultParam = {\n            canCancel: false\n        }\n        const propsData = merge(defaultParam, params)\n        return open(propsData)\n    },\n    confirm(params) {\n        const defaultParam = {}\n        const propsData = merge(defaultParam, params)\n        return open(propsData)\n    },\n    prompt(params) {\n        const defaultParam = {\n            hasInput: true\n        }\n        const propsData = merge(defaultParam, params)\n        return open(propsData)\n    }\n}\n\nconst Plugin = {\n    install(Vue) {\n        localVueInstance = Vue\n        registerComponent(Vue, Dialog)\n        registerComponentProgrammatic(Vue, 'dialog', DialogProgrammatic)\n    }\n}\n\nuse(Plugin)\n\nexport default Plugin\n\nexport {\n    DialogProgrammatic,\n    Dialog as BDialog\n}\n",
      "path": "src/components/dialog/index.js"
    },
    {
      "type": "registry:component",
      "target": "components/icon/Icon.vue",
      "content": "<template>\n    <span class=\"icon\" :class=\"[newType, size]\">\n        <i\n            v-if=\"!useIconComponent\"\n            :class=\"[newPack, newIcon, newCustomSize, customClass]\"/>\n\n        <component\n            v-else\n            :is=\"useIconComponent\"\n            :icon=\"[newPack, newIcon]\"\n            :size=\"newCustomSize\"\n            :class=\"[customClass]\"/>\n    </span>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport getIcons from '@/utils/icons'\n\nexport default {\n    name: 'BIcon',\n    props: {\n        type: [String, Object],\n        component: String,\n        pack: String,\n        icon: String,\n        size: String,\n        customSize: String,\n        customClass: String,\n        both: Boolean // This is used internally to show both MDI and FA icon\n    },\n    computed: {\n        iconConfig() {\n            let allIcons = getIcons()\n            return allIcons[this.newPack]\n        },\n        iconPrefix() {\n            if (this.iconConfig && this.iconConfig.iconPrefix) {\n                return this.iconConfig.iconPrefix\n            }\n            return ''\n        },\n        /**\n        * Internal icon name based on the pack.\n        * If pack is 'fa', gets the equivalent FA icon name of the MDI,\n        * internal icons are always MDI.\n        */\n        newIcon() {\n            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`\n        },\n        newPack() {\n            return this.pack || config.defaultIconPack\n        },\n        newType() {\n            if (!this.type) return\n\n            let splitType = []\n            if (typeof this.type === 'string') {\n                splitType = this.type.split('-')\n            } else {\n                for (let key in this.type) {\n                    if (this.type[key]) {\n                        splitType = key.split('-')\n                        break\n                    }\n                }\n            }\n            if (splitType.length <= 1) return\n\n            const [, ...type] = splitType\n            return `has-text-${type.join('-')}`\n        },\n        newCustomSize() {\n            return this.customSize || this.customSizeByPack\n        },\n        customSizeByPack() {\n            if (this.iconConfig && this.iconConfig.sizes) {\n                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {\n                    return this.iconConfig.sizes[this.size]\n                } else if (this.iconConfig.sizes.default) {\n                    return this.iconConfig.sizes.default\n                }\n            }\n            return null\n        },\n        useIconComponent() {\n            return this.component || config.defaultIconComponent\n        }\n    },\n    methods: {\n        /**\n        * Equivalent icon name of the MDI.\n        */\n        getEquivalentIconOf(value) {\n            // Only transform the class if the both prop is set to true\n            if (!this.both) {\n                return value\n            }\n\n            if (this.iconConfig &&\n                this.iconConfig.internalIcons &&\n                this.iconConfig.internalIcons[value]) {\n                return this.iconConfig.internalIcons[value]\n            }\n            return value\n        }\n    }\n}\n</script>\n",
      "path": "src/components/icon/Icon.vue"
    },
    {
      "type": "registry:component",
      "target": "components/modal/Modal.vue",
      "content": "<template>\n    <transition\n        :name=\"animation\"\n        @after-enter=\"afterEnter\"\n        @before-leave=\"beforeLeave\"\n        @after-leave=\"afterLeave\"\n    >\n        <div\n            v-if=\"!destroyed\"\n            v-show=\"isActive\"\n            class=\"modal is-active\"\n            :class=\"[{'is-full-screen': fullScreen}, customClass]\"\n            v-trap-focus=\"trapFocus\"\n            tabindex=\"-1\"\n            :role=\"ariaRole\"\n            :aria-label=\"ariaLabel\"\n            :aria-modal=\"ariaModal\">\n            <div class=\"modal-background\" @click=\"cancel('outside')\"/>\n            <div\n                class=\"animation-content\"\n                :class=\"[{ 'modal-content': !hasModalCard }, customContentClass]\"\n                :style=\"customStyle\">\n                <component\n                    v-if=\"component\"\n                    v-bind=\"props\"\n                    v-on=\"events\"\n                    :is=\"component\"\n                    :can-cancel=\"canCancel\"\n                    @close=\"close\"\n                />\n                <template v-else-if=\"content\">\n                    <div v-html=\"content\" />\n                </template>\n                <slot\n                    v-else\n                    :can-cancel=\"canCancel\"\n                    :close=\"close\"/>\n                <button\n                    type=\"button\"\n                    v-if=\"showX\"\n                    v-show=\"!animating\"\n                    class=\"modal-close is-large\"\n                    :aria-label=\"closeButtonAriaLabel\"\n                    @click=\"cancel('x')\"/>\n            </div>\n        </div>\n    </transition>\n</template>\n\n<script>\nimport trapFocus from '@/directives/trapFocus'\nimport { removeElement } from '@/utils/helpers'\nimport config from '@/utils/config'\n\nexport default {\n    name: 'BModal',\n    directives: {\n        trapFocus\n    },\n    // deprecated, to replace with default 'value' in the next breaking change\n    model: {\n        prop: 'active',\n        event: 'update:active'\n    },\n    props: {\n        active: Boolean,\n        component: [Object, Function, String],\n        content: [String, Array],\n        programmatic: Boolean,\n        props: Object,\n        events: Object,\n        width: {\n            type: [String, Number],\n            default: 960\n        },\n        hasModalCard: Boolean,\n        animation: {\n            type: String,\n            default: 'zoom-out'\n        },\n        canCancel: {\n            type: [Array, Boolean],\n            default: () => {\n                return config.defaultModalCanCancel\n            }\n        },\n        onCancel: {\n            type: Function,\n            default: () => {}\n        },\n        scroll: {\n            type: String,\n            default: () => {\n                return config.defaultModalScroll\n                    ? config.defaultModalScroll\n                    : 'clip'\n            },\n            validator: (value) => {\n                return [\n                    'clip',\n                    'keep'\n                ].indexOf(value) >= 0\n            }\n        },\n        fullScreen: Boolean,\n        trapFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultTrapFocus\n            }\n        },\n        autoFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultAutoFocus\n            }\n        },\n        customClass: String,\n        customContentClass: [String, Array, Object],\n        ariaRole: {\n            type: String,\n            validator: (value) => {\n                return [\n                    'dialog',\n                    'alertdialog'\n                ].indexOf(value) >= 0\n            }\n        },\n        ariaModal: Boolean,\n        ariaLabel: {\n            type: String,\n            validator: (value) => {\n                return Boolean(value)\n            }\n        },\n        closeButtonAriaLabel: String,\n        destroyOnHide: {\n            type: Boolean,\n            default: true\n        },\n        renderOnMounted: {\n            type: Boolean,\n            default: false\n        }\n    },\n    data() {\n        return {\n            isActive: this.active || false,\n            savedScrollTop: null,\n            newWidth: typeof this.width === 'number'\n                ? this.width + 'px'\n                : this.width,\n            animating: !this.active,\n            destroyed: !(this.active || this.renderOnMounted)\n        }\n    },\n    computed: {\n        cancelOptions() {\n            return typeof this.canCancel === 'boolean'\n                ? this.canCancel\n                    ? config.defaultModalCanCancel\n                    : []\n                : this.canCancel\n        },\n        showX() {\n            return this.cancelOptions.indexOf('x') >= 0\n        },\n        customStyle() {\n            if (!this.fullScreen) {\n                return { maxWidth: this.newWidth }\n            }\n            return null\n        }\n    },\n    watch: {\n        active(value) {\n            this.isActive = value\n        },\n        isActive(value) {\n            if (value) this.destroyed = false\n            this.handleScroll()\n            this.$nextTick(() => {\n                if (value && this.$el && this.$el.focus && this.autoFocus) {\n                    this.$el.focus()\n                }\n            })\n        }\n    },\n    methods: {\n        handleScroll() {\n            if (typeof window === 'undefined') return\n\n            if (this.scroll === 'clip') {\n                if (this.isActive) {\n                    document.documentElement.classList.add('is-clipped')\n                } else {\n                    document.documentElement.classList.remove('is-clipped')\n                }\n                return\n            }\n\n            this.savedScrollTop = !this.savedScrollTop\n                ? document.documentElement.scrollTop\n                : this.savedScrollTop\n\n            if (this.isActive) {\n                document.body.classList.add('is-noscroll')\n            } else {\n                document.body.classList.remove('is-noscroll')\n            }\n\n            if (this.isActive) {\n                document.body.style.top = `-${this.savedScrollTop}px`\n                return\n            }\n\n            document.documentElement.scrollTop = this.savedScrollTop\n            document.body.style.top = null\n            this.savedScrollTop = null\n        },\n\n        /**\n        * Close the Modal if canCancel and call the onCancel prop (function).\n        */\n        cancel(method) {\n            if (this.cancelOptions.indexOf(method) < 0) return\n            this.$emit('cancel', arguments)\n            this.onCancel.apply(null, arguments)\n            this.close()\n        },\n\n        /**\n        * Call the onCancel prop (function).\n        * Emit events, and destroy modal if it's programmatic.\n        */\n        close() {\n            this.$emit('close')\n            this.$emit('update:active', false)\n\n            // Timeout for the animation complete before destroying\n            if (this.programmatic) {\n                this.isActive = false\n                setTimeout(() => {\n                    this.$destroy()\n                    removeElement(this.$el)\n                }, 150)\n            }\n        },\n\n        /**\n        * Keypress event that is bound to the document.\n        */\n        keyPress({ key }) {\n            if (this.isActive && (key === 'Escape' || key === 'Esc')) this.cancel('escape')\n        },\n\n        /**\n        * Transition after-enter hook\n        */\n        afterEnter() {\n            this.animating = false\n            this.$emit('after-enter')\n        },\n\n        /**\n        * Transition before-leave hook\n        */\n        beforeLeave() {\n            this.animating = true\n        },\n\n        /**\n        * Transition after-leave hook\n        */\n        afterLeave() {\n            if (this.destroyOnHide) {\n                this.destroyed = true\n            }\n            this.$emit('after-leave')\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeMount() {\n        // Insert the Modal component in body tag\n        // only if it's programmatic\n        this.programmatic && document.body.appendChild(this.$el)\n    },\n    mounted() {\n        if (this.programmatic) this.isActive = true\n        else if (this.isActive) this.handleScroll()\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('keyup', this.keyPress)\n            // reset scroll\n            document.documentElement.classList.remove('is-clipped')\n            const savedScrollTop = !this.savedScrollTop\n                ? document.documentElement.scrollTop\n                : this.savedScrollTop\n            document.body.classList.remove('is-noscroll')\n            document.documentElement.scrollTop = savedScrollTop\n            document.body.style.top = null\n        }\n    }\n}\n</script>\n",
      "path": "src/components/modal/Modal.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/icons.js",
      "content": "import config from '@/utils/config'\nimport { merge } from '@/utils/helpers'\n\nconst mdiIcons = {\n    sizes: {\n        'default': 'mdi-24px',\n        'is-small': null,\n        'is-medium': 'mdi-36px',\n        'is-large': 'mdi-48px'\n    },\n    iconPrefix: 'mdi-'\n}\n\nconst faIcons = () => {\n    const faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-'\n    return {\n        sizes: {\n            'default': null,\n            'is-small': null,\n            'is-medium': faIconPrefix + 'lg',\n            'is-large': faIconPrefix + '2x'\n        },\n        iconPrefix: faIconPrefix,\n        internalIcons: {\n            'information': 'info-circle',\n            'alert': 'exclamation-triangle',\n            'alert-circle': 'exclamation-circle',\n            'chevron-right': 'angle-right',\n            'chevron-left': 'angle-left',\n            'chevron-down': 'angle-down',\n            'eye-off': 'eye-slash',\n            'menu-down': 'caret-down',\n            'menu-up': 'caret-up',\n            'close-circle': 'times-circle'\n        }\n    }\n}\n\nconst getIcons = () => {\n    let icons = {\n        mdi: mdiIcons,\n        fa: faIcons(),\n        fas: faIcons(),\n        far: faIcons(),\n        fad: faIcons(),\n        fab: faIcons(),\n        fal: faIcons(),\n        'fa-solid': faIcons(),\n        'fa-regular': faIcons(),\n        'fa-light': faIcons(),\n        'fa-thin': faIcons(),\n        'fa-duotone': faIcons(),\n        'fa-brands': faIcons()\n    }\n\n    if (config && config.customIconPacks) {\n        icons = merge(icons, config.customIconPacks, true)\n    }\n\n    return icons\n}\n\nexport default getIcons\n",
      "path": "src/utils/icons.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/plugins.js",
      "content": "\nexport const use = (plugin) => {\n    if (typeof window !== 'undefined' && window.Vue) {\n        window.Vue.use(plugin)\n    }\n}\n\nexport const registerComponent = (Vue, component) => {\n    Vue.component(component.name, component)\n}\n\nexport const registerComponentProgrammatic = (Vue, property, component) => {\n    if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {}\n    Vue.prototype.$buefy[property] = component\n}\n",
      "path": "src/utils/plugins.js"
    }
  ]
}
