{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "datepicker/DatepickerTable",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerTable.vue",
      "content": "<template>\n    <section class=\"datepicker-table\">\n        <header class=\"datepicker-header\">\n            <div\n                v-for=\"(day, index) in visibleDayNames\"\n                :key=\"index\"\n                class=\"datepicker-cell\">\n                <span>{{ day }}</span>\n            </div>\n        </header>\n        <div class=\"datepicker-body\" :class=\"{'has-events':hasEvents}\">\n            <b-datepicker-table-row\n                v-for=\"(week, index) in weeksInThisMonth\"\n                :key=\"index\"\n                :selected-date=\"value\"\n                :day=\"focused.day\"\n                :week=\"week\"\n                :month=\"focused.month\"\n                :min-date=\"minDate\"\n                :max-date=\"maxDate\"\n                :disabled=\"disabled\"\n                :unselectable-dates=\"unselectableDates\"\n                :unselectable-days-of-week=\"unselectableDaysOfWeek\"\n                :selectable-dates=\"selectableDates\"\n                :events=\"eventsInThisWeek(week)\"\n                :indicators=\"indicators\"\n                :date-creator=\"dateCreator\"\n                :nearby-month-days=\"nearbyMonthDays\"\n                :nearby-selectable-month-days=\"nearbySelectableMonthDays\"\n                :show-week-number=\"showWeekNumber\"\n                :week-number-clickable=\"weekNumberClickable\"\n                :first-day-of-week=\"firstDayOfWeek\"\n                :rules-for-first-week=\"rulesForFirstWeek\"\n                :range=\"range\"\n                :hovered-date-range=\"hoveredDateRange\"\n                @select=\"updateSelectedDate\"\n                @rangeHoverEndDate=\"setRangeHoverEndDate\"\n                :multiple=\"multiple\"\n                @change-focus=\"changeFocus\"/>\n        </div>\n    </section>\n</template>\n\n<script>\nimport DatepickerTableRow from '@/components/datepicker/DatepickerTableRow'\nimport { isDefined } from '@/utils/helpers'\n\nexport default {\n    name: 'BDatepickerTable',\n    components: {\n        [DatepickerTableRow.name]: DatepickerTableRow\n    },\n    props: {\n        value: {\n            type: [Date, Array]\n        },\n        dayNames: Array,\n        monthNames: Array,\n        firstDayOfWeek: Number,\n        events: Array,\n        indicators: String,\n        minDate: Date,\n        maxDate: Date,\n        focused: Object,\n        disabled: Boolean,\n        dateCreator: Function,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        nearbyMonthDays: Boolean,\n        nearbySelectableMonthDays: Boolean,\n        showWeekNumber: Boolean,\n        weekNumberClickable: Boolean,\n        rulesForFirstWeek: Number,\n        range: Boolean,\n        multiple: Boolean\n    },\n    data() {\n        return {\n            selectedBeginDate: undefined,\n            selectedEndDate: undefined,\n            hoveredEndDate: undefined\n        }\n    },\n    computed: {\n        multipleSelectedDates: {\n            get() {\n                return this.multiple && this.value ? this.value : []\n            },\n            set(value) {\n                this.$emit('input', value)\n            }\n        },\n        visibleDayNames() {\n            const visibleDayNames = []\n            let index = this.firstDayOfWeek\n            while (visibleDayNames.length < this.dayNames.length) {\n                const currentDayName = this.dayNames[(index % this.dayNames.length)]\n                visibleDayNames.push(currentDayName)\n                index++\n            }\n            if (this.showWeekNumber) visibleDayNames.unshift('')\n            return visibleDayNames\n        },\n\n        hasEvents() {\n            return this.events && this.events.length\n        },\n\n        /*\n        * Return array of all events in the specified month\n        */\n        eventsInThisMonth() {\n            if (!this.events) return []\n\n            const monthEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                let event = this.events[i]\n\n                if (!event.hasOwnProperty('date')) {\n                    event = { date: event }\n                }\n                if (!event.hasOwnProperty('type')) {\n                    event.type = 'is-primary'\n                }\n                if (\n                    event.date.getMonth() === this.focused.month &&\n                    event.date.getFullYear() === this.focused.year\n                ) {\n                    monthEvents.push(event)\n                }\n            }\n\n            return monthEvents\n        },\n        /*\n        * Return array of all weeks in the specified month\n        */\n        weeksInThisMonth() {\n            this.validateFocusedDay()\n            const month = this.focused.month\n            const year = this.focused.year\n            const weeksInThisMonth = []\n\n            let startingDay = 1\n\n            while (weeksInThisMonth.length < 6) {\n                const newWeek = this.weekBuilder(startingDay, month, year)\n                weeksInThisMonth.push(newWeek)\n                startingDay += 7\n            }\n\n            return weeksInThisMonth\n        },\n        hoveredDateRange() {\n            if (!this.range) {\n                return []\n            }\n            if (!isNaN(this.selectedEndDate)) {\n                return []\n            }\n            if (this.hoveredEndDate < this.selectedBeginDate) {\n                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)\n            }\n            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)\n        }\n    },\n    methods: {\n        /*\n        * Emit input event with selected date as payload for v-model in parent\n        */\n        updateSelectedDate(date) {\n            if (!this.range && !this.multiple) {\n                this.$emit('input', date)\n            } else if (this.range) {\n                this.handleSelectRangeDate(date)\n            } else if (this.multiple) {\n                this.handleSelectMultipleDates(date)\n            }\n        },\n\n        /*\n        * If both begin and end dates are set, reset the end date and set the begin date.\n        * If only begin date is selected, emit an array of the begin date and the new date.\n        * If not set, only set the begin date.\n        */\n        handleSelectRangeDate(date) {\n            if (this.selectedBeginDate && this.selectedEndDate) {\n                this.selectedBeginDate = date\n                this.selectedEndDate = undefined\n                this.$emit('range-start', date)\n            } else if (this.selectedBeginDate && !this.selectedEndDate) {\n                if (this.selectedBeginDate > date) {\n                    this.selectedEndDate = this.selectedBeginDate\n                    this.selectedBeginDate = date\n                } else {\n                    this.selectedEndDate = date\n                }\n                this.$emit('range-end', date)\n                this.$emit('input', [this.selectedBeginDate, this.selectedEndDate])\n            } else {\n                this.selectedBeginDate = date\n                this.$emit('range-start', date)\n            }\n        },\n\n        /*\n        * If selected date already exists list of selected dates, remove it from the list\n        * Otherwise, add date to list of selected dates\n        */\n        handleSelectMultipleDates(date) {\n            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>\n                selectedDate.getDate() === date.getDate() &&\n                selectedDate.getFullYear() === date.getFullYear() &&\n                selectedDate.getMonth() === date.getMonth()\n            )\n            if (multipleSelect.length) {\n                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>\n                    selectedDate.getDate() !== date.getDate() ||\n                    selectedDate.getFullYear() !== date.getFullYear() ||\n                    selectedDate.getMonth() !== date.getMonth()\n                )\n            } else {\n                this.multipleSelectedDates = [...this.multipleSelectedDates, date]\n            }\n        },\n\n        /*\n         * Return array of all days in the week that the startingDate is within\n         */\n        weekBuilder(startingDate, month, year) {\n            const thisMonth = new Date(year, month)\n\n            const thisWeek = []\n\n            const dayOfWeek = new Date(year, month, startingDate).getDay()\n\n            const end = dayOfWeek >= this.firstDayOfWeek\n                ? (dayOfWeek - this.firstDayOfWeek)\n                : ((7 - this.firstDayOfWeek) + dayOfWeek)\n\n            let daysAgo = 1\n            for (let i = 0; i < end; i++) {\n                thisWeek.unshift(new Date(\n                    thisMonth.getFullYear(),\n                    thisMonth.getMonth(),\n                    startingDate - daysAgo)\n                )\n                daysAgo++\n            }\n\n            thisWeek.push(new Date(year, month, startingDate))\n\n            let daysForward = 1\n            while (thisWeek.length < 7) {\n                thisWeek.push(new Date(year, month, startingDate + daysForward))\n                daysForward++\n            }\n\n            return thisWeek\n        },\n\n        validateFocusedDay() {\n            const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day)\n            if (this.selectableDate(focusedDate)) return\n\n            let day = 0\n            // Number of days in the current month\n            const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate()\n            let firstFocusable = null\n            while (!firstFocusable && ++day < monthDays) {\n                const date = new Date(this.focused.year, this.focused.month, day)\n                if (this.selectableDate(date)) {\n                    firstFocusable = focusedDate\n\n                    const focused = {\n                        day: date.getDate(),\n                        month: date.getMonth(),\n                        year: date.getFullYear()\n                    }\n                    this.$emit('update:focused', focused)\n                }\n            }\n        },\n\n        /*\n         * Check that selected day is within earliest/latest params and\n         * is within this month\n         */\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {\n                validity.push(day.getMonth() === this.focused.month)\n            }\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getDate() === enabledDate.getDate() &&\n                            day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getDate() !== disabledDate.getDate() ||\n                                day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n\n        eventsInThisWeek(week) {\n            return this.eventsInThisMonth.filter((event) => {\n                const stripped = new Date(Date.parse(event.date))\n                stripped.setHours(0, 0, 0, 0)\n                const timed = stripped.getTime()\n\n                return week.some((weekDate) => weekDate.getTime() === timed)\n            })\n        },\n\n        setRangeHoverEndDate(day) {\n            this.hoveredEndDate = day\n        },\n\n        changeFocus(day) {\n            const focused = {\n                day: day.getDate(),\n                month: day.getMonth(),\n                year: day.getFullYear()\n            }\n            this.$emit('update:focused', focused)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerTable.vue"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerTableRow.vue",
      "content": "<template>\n    <div class=\"datepicker-row\">\n        <a\n            class=\"datepicker-cell is-week-number\"\n            :class=\"{'is-clickable': weekNumberClickable }\"\n            v-if=\"showWeekNumber\"\n            @click.prevent=\"clickWeekNumber(getWeekNumber(week[6]))\">\n            <span>{{ getWeekNumber(week[6]).week }}</span>\n        </a>\n        <template v-for=\"(weekDay, index) in week\">\n            <a\n                :ref=\"`day-${weekDay.getMonth()}-${weekDay.getDate()}`\"\n                v-if=\"selectableDate(weekDay) && !disabled\"\n                :key=\"index\"\n                :class=\"classObject(weekDay)\"\n                class=\"datepicker-cell\"\n                role=\"button\"\n                href=\"#\"\n                :disabled=\"disabled\"\n                @click.prevent=\"emitChosenDate(weekDay)\"\n                @mouseenter=\"setRangeHoverEndDate(weekDay)\"\n                @keydown=\"manageKeydown($event, weekDay)\"\n                :tabindex=\"day === weekDay.getDate() && month === weekDay.getMonth() ? null : -1\">\n                <span>{{ weekDay.getDate() }}</span>\n                <div class=\"events\" v-if=\"eventsDateMatch(weekDay)\">\n                    <div\n                        class=\"event\"\n                        :class=\"event.type\"\n                        v-for=\"(event, index) in eventsDateMatch(weekDay)\"\n                        :key=\"index\"/>\n                </div>\n            </a>\n            <div\n                v-else\n                :key=\"index\"\n                :class=\"classObject(weekDay)\"\n                class=\"datepicker-cell\">\n                <span>{{ weekDay.getDate() }}</span>\n                <div class=\"events\" v-if=\"eventsDateMatch(weekDay)\">\n                    <div\n                        class=\"event\"\n                        :class=\"event.type\"\n                        v-for=\"(event, index) in eventsDateMatch(weekDay)\"\n                        :key=\"index\"/>\n                </div>\n            </div>\n        </template>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'BDatepickerTableRow',\n    inject: {\n        $datepicker: { name: '$datepicker', default: false }\n    },\n    props: {\n        selectedDate: {\n            type: [Date, Array]\n        },\n        hoveredDateRange: Array,\n        day: {\n            type: Number\n        },\n        week: {\n            type: Array,\n            required: true\n        },\n        month: {\n            type: Number,\n            required: true\n        },\n        minDate: Date,\n        maxDate: Date,\n        disabled: Boolean,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        events: Array,\n        indicators: String,\n        dateCreator: Function,\n        nearbyMonthDays: Boolean,\n        nearbySelectableMonthDays: Boolean,\n        showWeekNumber: Boolean,\n        weekNumberClickable: Boolean,\n        range: Boolean,\n        multiple: Boolean,\n        rulesForFirstWeek: Number,\n        firstDayOfWeek: Number\n    },\n    watch: {\n        day(day) {\n            const refName = `day-${this.month}-${day}`\n            this.$nextTick(() => {\n                if (this.$refs[refName] && this.$refs[refName].length > 0) {\n                    if (this.$refs[refName][0]) {\n                        this.$refs[refName][0].focus()\n                    }\n                }\n            }) // $nextTick needed when month is changed\n        }\n    },\n    methods: {\n        firstWeekOffset(year, dow, doy) {\n            // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            const fwd = 7 + dow - doy\n            // first-week day local weekday -- which local weekday is fwd\n            const firstJanuary = new Date(year, 0, fwd)\n            const fwdlw = (7 + firstJanuary.getDay() - dow) % 7\n            return -fwdlw + fwd - 1\n        },\n        daysInYear(year) {\n            return this.isLeapYear(year) ? 366 : 365\n        },\n        isLeapYear(year) {\n            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\n        },\n        getSetDayOfYear(input) {\n            return Math.round((input - new Date(input.getFullYear(), 0, 1)) / 864e5) + 1\n        },\n        weeksInYear(year, dow, doy) {\n            const weekOffset = this.firstWeekOffset(year, dow, doy)\n            const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy)\n            return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7\n        },\n        getWeekNumber(mom) {\n            const dow = this.firstDayOfWeek // first day of week\n            // Rules for the first week : 1 for the 1st January, 4 for the 4th January\n            const doy = this.rulesForFirstWeek\n            const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy)\n            const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1\n            let resWeek\n            let resYear\n            if (week < 1) {\n                resYear = mom.getFullYear() - 1\n                resWeek = week + this.weeksInYear(resYear, dow, doy)\n            } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {\n                resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy)\n                resYear = mom.getFullYear() + 1\n            } else {\n                resYear = mom.getFullYear()\n                resWeek = week\n            }\n            return {week: resWeek, year: resYear}\n        },\n        clickWeekNumber(weekData) {\n            if (this.weekNumberClickable) {\n                this.$datepicker.$emit('week-number-click', weekData.week, weekData.year)\n            }\n        },\n        /*\n         * Check that selected day is within earliest/latest params and\n         * is within this month\n         */\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {\n                validity.push(day.getMonth() === this.month)\n            }\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getDate() === enabledDate.getDate() &&\n                            day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getDate() !== disabledDate.getDate() ||\n                                day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n\n        /*\n        * Emit select event with chosen date as payload\n        */\n        emitChosenDate(day) {\n            if (this.disabled) return\n\n            if (this.selectableDate(day)) {\n                this.$emit('select', day)\n            }\n        },\n\n        eventsDateMatch(day) {\n            if (!this.events || !this.events.length) return false\n\n            const dayEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                if (this.events[i].date.getDay() === day.getDay()) {\n                    dayEvents.push(this.events[i])\n                }\n            }\n\n            if (!dayEvents.length) {\n                return false\n            }\n\n            return dayEvents\n        },\n\n        /*\n        * Build classObject for cell using validations\n        */\n        classObject(day) {\n            function dateMatch(dateOne, dateTwo, multiple) {\n                // if either date is null or undefined, return false\n                // if using multiple flag, return false\n                if (!dateOne || !dateTwo || multiple) {\n                    return false\n                }\n\n                if (Array.isArray(dateTwo)) {\n                    return dateTwo.some((date) => (\n                        dateOne.getDate() === date.getDate() &&\n                        dateOne.getFullYear() === date.getFullYear() &&\n                        dateOne.getMonth() === date.getMonth()\n                    ))\n                }\n                return (dateOne.getDate() === dateTwo.getDate() &&\n                    dateOne.getFullYear() === dateTwo.getFullYear() &&\n                    dateOne.getMonth() === dateTwo.getMonth())\n            }\n\n            function dateWithin(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || multiple) { return false }\n\n                return dateOne > dates[0] && dateOne < dates[1]\n            }\n\n            return {\n                'is-selected': dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple),\n                'is-first-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.selectedDate) && this.selectedDate[0],\n                        this.multiple\n                    ),\n                'is-within-selected':\n                    dateWithin(day, this.selectedDate, this.multiple),\n                'is-last-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.selectedDate) && this.selectedDate[1],\n                        this.multiple\n                    ),\n                'is-within-hovered-range':\n                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&\n                    (dateMatch(day, this.hoveredDateRange) ||\n                        dateWithin(day, this.hoveredDateRange)),\n                'is-first-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]\n                ),\n                'is-within-hovered':\n                    dateWithin(day, this.hoveredDateRange),\n                'is-last-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]\n                ),\n                'is-today': dateMatch(day, this.dateCreator()),\n                'is-selectable': this.selectableDate(day) && !this.disabled,\n                'is-unselectable': !this.selectableDate(day) || this.disabled,\n                'is-invisible': !this.nearbyMonthDays && day.getMonth() !== this.month,\n                'is-nearby': this.nearbySelectableMonthDays && day.getMonth() !== this.month,\n                'has-event': this.eventsDateMatch(day),\n                [this.indicators]: this.eventsDateMatch(day)\n            }\n        },\n        setRangeHoverEndDate(day) {\n            if (this.range) {\n                this.$emit('rangeHoverEndDate', day)\n            }\n        },\n\n        manageKeydown(event, weekDay) {\n            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys\n            const { key } = event\n            let preventDefault = true\n            switch (key) {\n                case 'Tab': {\n                    preventDefault = false\n                    break\n                }\n\n                case ' ':\n                case 'Space':\n                case 'Spacebar':\n                case 'Enter': {\n                    this.emitChosenDate(weekDay)\n                    break\n                }\n\n                case 'ArrowLeft':\n                case 'Left': {\n                    this.changeFocus(weekDay, -1)\n                    break\n                }\n                case 'ArrowRight':\n                case 'Right': {\n                    this.changeFocus(weekDay, 1)\n                    break\n                }\n                case 'ArrowUp':\n                case 'Up': {\n                    this.changeFocus(weekDay, -7)\n                    break\n                }\n                case 'ArrowDown':\n                case 'Down': {\n                    this.changeFocus(weekDay, 7)\n                    break\n                }\n            }\n\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        },\n\n        changeFocus(day, inc) {\n            const nextDay = new Date(day.getTime())\n            nextDay.setDate(day.getDate() + inc)\n            while (\n                (!this.minDate || nextDay > this.minDate) &&\n                (!this.maxDate || nextDay < this.maxDate) &&\n                !this.selectableDate(nextDay)\n            ) {\n                nextDay.setDate(nextDay.getDate() + Math.sign(inc))\n            }\n            this.setRangeHoverEndDate(nextDay)\n            this.$emit('change-focus', nextDay)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerTableRow.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    }
  ]
}
