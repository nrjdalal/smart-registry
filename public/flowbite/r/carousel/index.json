{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "carousel/index",
  "type": "registry:component",
  "dependencies": [
    "@popperjs/core"
  ],
  "files": [
    {
      "type": "registry:file",
      "target": "dom/instances.ts",
      "content": "import { AccordionInterface } from '@/components/accordion/interface';\nimport { CarouselInterface } from '@/components/carousel/interface';\nimport { CollapseInterface } from '@/components/collapse/interface';\nimport { DialInterface } from '@/components/dial/interface';\nimport { DismissInterface } from '@/components/dismiss/interface';\nimport { DrawerInterface } from '@/components/drawer/interface';\nimport { DropdownInterface } from '@/components/dropdown/interface';\nimport { ModalInterface } from '@/components/modal/interface';\nimport { PopoverInterface } from '@/components/popover/interface';\nimport { TabsInterface } from '@/components/tabs/interface';\nimport { TooltipInterface } from '@/components/tooltip/interface';\nimport { InputCounterInterface } from '@/components/input-counter/interface';\nimport { CopyClipboardInterface } from '@/components/clipboard/interface';\nimport { DatepickerInterface } from '@/components/datepicker/interface';\n\nclass Instances {\n    private _instances: {\n        Accordion: { [id: string]: AccordionInterface };\n        Carousel: { [id: string]: CarouselInterface };\n        Collapse: { [id: string]: CollapseInterface };\n        Dial: { [id: string]: DialInterface };\n        Dismiss: { [id: string]: DismissInterface };\n        Drawer: { [id: string]: DrawerInterface };\n        Dropdown: { [id: string]: DropdownInterface };\n        Modal: { [id: string]: ModalInterface };\n        Popover: { [id: string]: PopoverInterface };\n        Tabs: { [id: string]: TabsInterface };\n        Tooltip: { [id: string]: TooltipInterface };\n        InputCounter: { [id: string]: InputCounterInterface };\n        CopyClipboard: { [id: string]: CopyClipboardInterface };\n        Datepicker: { [id: string]: DatepickerInterface };\n    };\n\n    constructor() {\n        this._instances = {\n            Accordion: {},\n            Carousel: {},\n            Collapse: {},\n            Dial: {},\n            Dismiss: {},\n            Drawer: {},\n            Dropdown: {},\n            Modal: {},\n            Popover: {},\n            Tabs: {},\n            Tooltip: {},\n            InputCounter: {},\n            CopyClipboard: {},\n            Datepicker: {},\n        };\n    }\n\n    addInstance(\n        component: keyof Instances['_instances'],\n        instance: any,\n        id?: string,\n        override = false\n    ) {\n        if (!this._instances[component]) {\n            console.warn(`Flowbite: Component ${component} does not exist.`);\n            return false;\n        }\n\n        if (this._instances[component][id] && !override) {\n            console.warn(`Flowbite: Instance with ID ${id} already exists.`);\n            return;\n        }\n\n        if (override && this._instances[component][id]) {\n            this._instances[component][id].destroyAndRemoveInstance();\n        }\n\n        this._instances[component][id ? id : this._generateRandomId()] =\n            instance;\n    }\n\n    getAllInstances() {\n        return this._instances;\n    }\n\n    getInstances(component: keyof Instances['_instances']) {\n        if (!this._instances[component]) {\n            console.warn(`Flowbite: Component ${component} does not exist.`);\n            return false;\n        }\n        return this._instances[component];\n    }\n\n    getInstance(component: keyof Instances['_instances'], id: string) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n\n        if (!this._instances[component][id]) {\n            console.warn(`Flowbite: Instance with ID ${id} does not exist.`);\n            return;\n        }\n        return this._instances[component][id] as any;\n    }\n\n    destroyAndRemoveInstance(\n        component: keyof Instances['_instances'],\n        id: string\n    ) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        this.destroyInstanceObject(component, id);\n        this.removeInstance(component, id);\n    }\n\n    removeInstance(component: keyof Instances['_instances'], id: string) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        delete this._instances[component][id];\n    }\n\n    destroyInstanceObject(\n        component: keyof Instances['_instances'],\n        id: string\n    ) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        this._instances[component][id].destroy();\n    }\n\n    instanceExists(component: keyof Instances['_instances'], id: string) {\n        if (!this._instances[component]) {\n            return false;\n        }\n\n        if (!this._instances[component][id]) {\n            return false;\n        }\n\n        return true;\n    }\n\n    _generateRandomId() {\n        return Math.random().toString(36).substr(2, 9);\n    }\n\n    private _componentAndInstanceCheck(\n        component: keyof Instances['_instances'],\n        id: string\n    ) {\n        if (!this._instances[component]) {\n            console.warn(`Flowbite: Component ${component} does not exist.`);\n            return false;\n        }\n\n        if (!this._instances[component][id]) {\n            console.warn(`Flowbite: Instance with ID ${id} does not exist.`);\n            return false;\n        }\n\n        return true;\n    }\n}\n\nconst instances = new Instances();\n\nexport default instances;\n\nif (typeof window !== 'undefined') {\n    window.FlowbiteInstances = instances;\n}\n",
      "path": "src/dom/instances.ts"
    },
    {
      "type": "registry:file",
      "target": "dom/types.ts",
      "content": "export declare type InstanceOptions = {\n    id?: string;\n    override?: boolean;\n};\n\nexport declare type EventListenerInstance = {\n    element: HTMLElement;\n    type: string;\n    handler: EventListenerOrEventListenerObject;\n};\n",
      "path": "src/dom/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/accordion/interface.ts",
      "content": "// Import the AccordionItem and AccordionOptions interfaces\nimport { AccordionItem, AccordionOptions } from '@/components/accordion/types';\n\n// Define the Accordion interface\nexport declare interface AccordionInterface {\n    _items: AccordionItem[];\n    _options: AccordionOptions;\n\n    getItem(id: string): AccordionItem | undefined;\n    open(id: string): void;\n    toggle(id: string): void;\n    close(id: string): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/accordion/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/accordion/types.ts",
      "content": "import { AccordionInterface } from '@/components/accordion/interface';\n\nexport declare type AccordionItem = {\n    id: string;\n    triggerEl: HTMLElement;\n    targetEl: HTMLElement;\n    iconEl?: HTMLElement | null;\n    active?: boolean;\n    clickHandler?: EventListenerOrEventListenerObject;\n};\n\nexport declare type AccordionOptions = {\n    alwaysOpen?: boolean;\n    activeClasses?: string;\n    inactiveClasses?: string;\n    onOpen?: (accordion: AccordionInterface, item: AccordionItem) => void;\n    onClose?: (accordion: AccordionInterface, item: AccordionItem) => void;\n    onToggle?: (accordion: AccordionInterface, item: AccordionItem) => void;\n};\n",
      "path": "src/components/accordion/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/carousel/index.ts",
      "content": "/* eslint-disable @typescript-eslint/no-empty-function */\nimport type {\n    CarouselOptions,\n    CarouselItem,\n    IndicatorItem,\n    RotationItems,\n} from '@/components/carousel/types';\nimport type { InstanceOptions } from '@/dom/types';\nimport { CarouselInterface } from '@/components/carousel/interface';\nimport instances from '@/dom/instances';\n\nconst Default: CarouselOptions = {\n    defaultPosition: 0,\n    indicators: {\n        items: [],\n        activeClasses: 'bg-white dark:bg-gray-800',\n        inactiveClasses:\n            'bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800',\n    },\n    interval: 3000,\n    onNext: () => {},\n    onPrev: () => {},\n    onChange: () => {},\n};\n\nconst DefaultInstanceOptions: InstanceOptions = {\n    id: null,\n    override: true,\n};\n\nclass Carousel implements CarouselInterface {\n    _instanceId: string;\n    _carouselEl: HTMLElement;\n    _items: CarouselItem[];\n    _indicators: IndicatorItem[];\n    _activeItem: CarouselItem;\n    _intervalDuration: number;\n    _intervalInstance: number;\n    _options: CarouselOptions;\n    _initialized: boolean;\n\n    constructor(\n        carouselEl: HTMLElement | null = null,\n        items: CarouselItem[] = [],\n        options: CarouselOptions = Default,\n        instanceOptions: InstanceOptions = DefaultInstanceOptions\n    ) {\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : carouselEl.id;\n        this._carouselEl = carouselEl;\n        this._items = items;\n        this._options = {\n            ...Default,\n            ...options,\n            indicators: { ...Default.indicators, ...options.indicators },\n        };\n        this._activeItem = this.getItem(this._options.defaultPosition);\n        this._indicators = this._options.indicators.items;\n        this._intervalDuration = this._options.interval;\n        this._intervalInstance = null;\n        this._initialized = false;\n        this.init();\n        instances.addInstance(\n            'Carousel',\n            this,\n            this._instanceId,\n            instanceOptions.override\n        );\n    }\n\n    /**\n     * initialize carousel and items based on active one\n     */\n    init() {\n        if (this._items.length && !this._initialized) {\n            this._items.map((item: CarouselItem) => {\n                item.el.classList.add(\n                    'absolute',\n                    'inset-0',\n                    'transition-transform',\n                    'transform'\n                );\n            });\n\n            // if no active item is set then first position is default\n            if (this.getActiveItem()) {\n                this.slideTo(this.getActiveItem().position);\n            } else {\n                this.slideTo(0);\n            }\n\n            this._indicators.map((indicator, position) => {\n                indicator.el.addEventListener('click', () => {\n                    this.slideTo(position);\n                });\n            });\n\n            this._initialized = true;\n        }\n    }\n\n    destroy() {\n        if (this._initialized) {\n            this._initialized = false;\n        }\n    }\n\n    removeInstance() {\n        instances.removeInstance('Carousel', this._instanceId);\n    }\n\n    destroyAndRemoveInstance() {\n        this.destroy();\n        this.removeInstance();\n    }\n\n    getItem(position: number) {\n        return this._items[position];\n    }\n\n    /**\n     * Slide to the element based on id\n     * @param {*} position\n     */\n    slideTo(position: number) {\n        const nextItem: CarouselItem = this._items[position];\n        const rotationItems: RotationItems = {\n            left:\n                nextItem.position === 0\n                    ? this._items[this._items.length - 1]\n                    : this._items[nextItem.position - 1],\n            middle: nextItem,\n            right:\n                nextItem.position === this._items.length - 1\n                    ? this._items[0]\n                    : this._items[nextItem.position + 1],\n        };\n        this._rotate(rotationItems);\n        this._setActiveItem(nextItem);\n        if (this._intervalInstance) {\n            this.pause();\n            this.cycle();\n        }\n\n        this._options.onChange(this);\n    }\n\n    /**\n     * Based on the currently active item it will go to the next position\n     */\n    next() {\n        const activeItem = this.getActiveItem();\n        let nextItem = null;\n\n        // check if last item\n        if (activeItem.position === this._items.length - 1) {\n            nextItem = this._items[0];\n        } else {\n            nextItem = this._items[activeItem.position + 1];\n        }\n\n        this.slideTo(nextItem.position);\n\n        // callback function\n        this._options.onNext(this);\n    }\n\n    /**\n     * Based on the currently active item it will go to the previous position\n     */\n    prev() {\n        const activeItem = this.getActiveItem();\n        let prevItem = null;\n\n        // check if first item\n        if (activeItem.position === 0) {\n            prevItem = this._items[this._items.length - 1];\n        } else {\n            prevItem = this._items[activeItem.position - 1];\n        }\n\n        this.slideTo(prevItem.position);\n\n        // callback function\n        this._options.onPrev(this);\n    }\n\n    /**\n     * This method applies the transform classes based on the left, middle, and right rotation carousel items\n     * @param {*} rotationItems\n     */\n    _rotate(rotationItems: RotationItems) {\n        // reset\n        this._items.map((item: CarouselItem) => {\n            item.el.classList.add('hidden');\n        });\n\n        // Handling the case when there is only one item\n        if (this._items.length === 1) {\n            rotationItems.middle.el.classList.remove(\n                '-translate-x-full',\n                'translate-x-full',\n                'translate-x-0',\n                'hidden',\n                'z-10'\n            );\n            rotationItems.middle.el.classList.add('translate-x-0', 'z-20');\n            return;\n        }\n\n        // left item (previously active)\n        rotationItems.left.el.classList.remove(\n            '-translate-x-full',\n            'translate-x-full',\n            'translate-x-0',\n            'hidden',\n            'z-20'\n        );\n\n        rotationItems.left.el.classList.add('-translate-x-full', 'z-10');\n\n        // currently active item\n        rotationItems.middle.el.classList.remove(\n            '-translate-x-full',\n            'translate-x-full',\n            'translate-x-0',\n            'hidden',\n            'z-10'\n        );\n        rotationItems.middle.el.classList.add('translate-x-0', 'z-30');\n\n        // right item (upcoming active)\n        rotationItems.right.el.classList.remove(\n            '-translate-x-full',\n            'translate-x-full',\n            'translate-x-0',\n            'hidden',\n            'z-30'\n        );\n        rotationItems.right.el.classList.add('translate-x-full', 'z-20');\n    }\n\n    /**\n     * Set an interval to cycle through the carousel items\n     */\n    cycle() {\n        if (typeof window !== 'undefined') {\n            this._intervalInstance = window.setInterval(() => {\n                this.next();\n            }, this._intervalDuration);\n        }\n    }\n\n    /**\n     * Clears the cycling interval\n     */\n    pause() {\n        clearInterval(this._intervalInstance);\n    }\n\n    /**\n     * Get the currently active item\n     */\n    getActiveItem() {\n        return this._activeItem;\n    }\n\n    /**\n     * Set the currently active item and data attribute\n     * @param {*} position\n     */\n    _setActiveItem(item: CarouselItem) {\n        this._activeItem = item;\n        const position = item.position;\n\n        // update the indicators if available\n        if (this._indicators.length) {\n            this._indicators.map((indicator) => {\n                indicator.el.setAttribute('aria-current', 'false');\n                indicator.el.classList.remove(\n                    ...this._options.indicators.activeClasses.split(' ')\n                );\n                indicator.el.classList.add(\n                    ...this._options.indicators.inactiveClasses.split(' ')\n                );\n            });\n            this._indicators[position].el.classList.add(\n                ...this._options.indicators.activeClasses.split(' ')\n            );\n            this._indicators[position].el.classList.remove(\n                ...this._options.indicators.inactiveClasses.split(' ')\n            );\n            this._indicators[position].el.setAttribute('aria-current', 'true');\n        }\n    }\n\n    updateOnNext(callback: () => void) {\n        this._options.onNext = callback;\n    }\n\n    updateOnPrev(callback: () => void) {\n        this._options.onPrev = callback;\n    }\n\n    updateOnChange(callback: () => void) {\n        this._options.onChange = callback;\n    }\n}\n\nexport function initCarousels() {\n    document.querySelectorAll('[data-carousel]').forEach(($carouselEl) => {\n        const interval = $carouselEl.getAttribute('data-carousel-interval');\n        const slide =\n            $carouselEl.getAttribute('data-carousel') === 'slide'\n                ? true\n                : false;\n\n        const items: CarouselItem[] = [];\n        let defaultPosition = 0;\n        if ($carouselEl.querySelectorAll('[data-carousel-item]').length) {\n            Array.from(\n                $carouselEl.querySelectorAll('[data-carousel-item]')\n            ).map(($carouselItemEl: HTMLElement, position: number) => {\n                items.push({\n                    position: position,\n                    el: $carouselItemEl,\n                });\n\n                if (\n                    $carouselItemEl.getAttribute('data-carousel-item') ===\n                    'active'\n                ) {\n                    defaultPosition = position;\n                }\n            });\n        }\n\n        const indicators: IndicatorItem[] = [];\n        if ($carouselEl.querySelectorAll('[data-carousel-slide-to]').length) {\n            Array.from(\n                $carouselEl.querySelectorAll('[data-carousel-slide-to]')\n            ).map(($indicatorEl: HTMLElement) => {\n                indicators.push({\n                    position: parseInt(\n                        $indicatorEl.getAttribute('data-carousel-slide-to')\n                    ),\n                    el: $indicatorEl,\n                });\n            });\n        }\n\n        const carousel = new Carousel($carouselEl as HTMLElement, items, {\n            defaultPosition: defaultPosition,\n            indicators: {\n                items: indicators,\n            },\n            interval: interval ? interval : Default.interval,\n        } as CarouselOptions);\n\n        if (slide) {\n            carousel.cycle();\n        }\n\n        // check for controls\n        const carouselNextEl = $carouselEl.querySelector(\n            '[data-carousel-next]'\n        );\n        const carouselPrevEl = $carouselEl.querySelector(\n            '[data-carousel-prev]'\n        );\n\n        if (carouselNextEl) {\n            carouselNextEl.addEventListener('click', () => {\n                carousel.next();\n            });\n        }\n\n        if (carouselPrevEl) {\n            carouselPrevEl.addEventListener('click', () => {\n                carousel.prev();\n            });\n        }\n    });\n}\n\nif (typeof window !== 'undefined') {\n    window.Carousel = Carousel;\n    window.initCarousels = initCarousels;\n}\n\nexport default Carousel;\n",
      "path": "src/components/carousel/index.ts"
    },
    {
      "type": "registry:component",
      "target": "components/carousel/interface.ts",
      "content": "import {\n    CarouselOptions,\n    CarouselItem,\n    IndicatorItem,\n    RotationItems,\n} from '@/components/carousel/types';\n\nexport declare interface CarouselInterface {\n    _items: CarouselItem[];\n    _indicators: IndicatorItem[];\n    _activeItem: CarouselItem;\n    _intervalDuration: number;\n    _intervalInstance: number;\n    _options: CarouselOptions;\n\n    init(): void;\n\n    getItem(position: number): CarouselItem;\n    getActiveItem(): CarouselItem;\n\n    _setActiveItem(item: CarouselItem): void;\n\n    slideTo(position: number): void;\n\n    next(): void;\n    prev(): void;\n\n    _rotate(rotationItems: RotationItems): void;\n    cycle(): void;\n    pause(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/carousel/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/carousel/types.ts",
      "content": "import { CarouselInterface } from '@/components/carousel/interface';\n\nexport declare type CarouselItem = {\n    position: number;\n    el: HTMLElement;\n};\n\nexport declare type IndicatorItem = {\n    position: number;\n    el: HTMLElement;\n};\n\nexport declare type RotationItems = {\n    left: CarouselItem;\n    middle: CarouselItem;\n    right: CarouselItem;\n};\n\nexport declare type CarouselOptions = {\n    defaultPosition?: number;\n    indicators?: {\n        items?: IndicatorItem[];\n        activeClasses?: string;\n        inactiveClasses?: string;\n    };\n    interval?: number;\n    onNext?: (carousel: CarouselInterface) => void;\n    onPrev?: (carousel: CarouselInterface) => void;\n    onChange?: (carousel: CarouselInterface) => void;\n};\n",
      "path": "src/components/carousel/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/clipboard/interface.ts",
      "content": "import { CopyClipboardOptions } from '@/components/clipboard/types';\n\nexport declare interface CopyClipboardInterface {\n    _triggerEl: HTMLElement | null;\n    _targetEl: HTMLElement | HTMLInputElement | null;\n    _options: CopyClipboardOptions;\n\n    init(): void;\n    copy(): string;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/clipboard/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/clipboard/types.ts",
      "content": "import { CopyClipboardInterface } from '@/components/clipboard/interface';\n\nexport declare type CopyClipboardOptions = {\n    htmlEntities: boolean;\n    contentType?: string;\n    onCopy?: (clipboard: CopyClipboardInterface) => void;\n};\n",
      "path": "src/components/clipboard/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/collapse/interface.ts",
      "content": "import { CollapseOptions } from '@/components/collapse/types';\n\nexport declare interface CollapseInterface {\n    _targetEl: HTMLElement | null;\n    _triggerEl: HTMLElement | null;\n    _options: CollapseOptions;\n    _visible: boolean;\n\n    init(): void;\n    collapse(): void;\n    expand(): void;\n    toggle(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/collapse/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/collapse/types.ts",
      "content": "import { CollapseInterface } from '@/components/collapse/interface';\n\nexport declare type CollapseOptions = {\n    onCollapse?: (collapse: CollapseInterface) => void;\n    onExpand?: (collapse: CollapseInterface) => void;\n    onToggle?: (collapse: CollapseInterface) => void;\n};\n",
      "path": "src/components/collapse/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/interface.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { DatepickerOptions } from '@/components/datepicker/types';\n\nexport declare interface DatepickerInterface {\n    _datepickerEl: HTMLElement;\n    _datepickerInstance: any | null;\n    _options: DatepickerOptions;\n\n    init(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/datepicker/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/datepicker/types.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { DatepickerInterface } from '@/components/datepicker/interface';\n\nexport interface DatepickerOptions {\n    defaultDatepickerId?: string | null;\n    autohide?: boolean;\n    format?: string;\n    maxDate?: string | null;\n    minDate?: string | null;\n    orientation?: string;\n    buttons?: boolean;\n    autoSelectToday?: number;\n    title?: string | null;\n    language?: string;\n    locales?: { [key: string]: any };\n    rangePicker?: boolean | false;\n    onShow?: (Datepicker: DatepickerInterface) => void;\n    onHide?: (Datepicker: DatepickerInterface) => void;\n}\n",
      "path": "src/components/datepicker/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dial/interface.ts",
      "content": "import { DialOptions, DialTriggerEventTypes, DialTriggerType } from '@/components/dial/types';\n\nexport declare interface DialInterface {\n    _parentEl: HTMLElement;\n    _triggerEl: HTMLElement;\n    _targetEl: HTMLElement;\n    _options: DialOptions;\n    _visible: boolean;\n\n    init(): void;\n    isVisible(): boolean;\n    isHidden(): boolean;\n    hide(): void;\n    show(): void;\n    toggle(): void;\n    _getTriggerEventTypes(triggerType: DialTriggerType): DialTriggerEventTypes;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/dial/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dial/types.ts",
      "content": "import { DialInterface } from '@/components/dial/interface';\n\nexport declare type DialTriggerType = 'click' | 'hover' | 'none';\n\nexport declare type DialTriggerEventTypes = {\n    showEvents: string[];\n    hideEvents: string[];\n};\n\nexport declare type DialOptions = {\n    triggerType?: DialTriggerType;\n    onShow?: (dial: DialInterface) => void;\n    onHide?: (dial: DialInterface) => void;\n    onToggle?: (dial: DialInterface) => void;\n};\n",
      "path": "src/components/dial/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dismiss/interface.ts",
      "content": "import { DismissOptions } from '@/components/dismiss/types';\n\nexport declare interface DismissInterface {\n    _targetEl: HTMLElement | null;\n    _triggerEl: HTMLElement | null;\n    _options: DismissOptions;\n\n    init(): void;\n    hide(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/dismiss/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dismiss/types.ts",
      "content": "import { DismissInterface } from '@/components/dismiss/interface';\n\nexport declare type DismissOptions = {\n    transition?: string;\n    duration?: number;\n    timing?: string;\n    onHide?: (dismiss: DismissInterface, targetEl: HTMLElement) => void;\n};\n",
      "path": "src/components/dismiss/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/drawer/interface.ts",
      "content": "import { DrawerOptions, PlacementClasses } from '@/components/drawer/types';\n\nexport declare interface DrawerInterface {\n    // properties\n    _targetEl: HTMLElement;\n    _triggerEl: HTMLElement;\n    _options: DrawerOptions;\n    _visible: boolean;\n\n    // methods\n    init(): void;\n    isVisible(): boolean;\n    isHidden(): boolean;\n    hide(): void;\n    show(): void;\n    toggle(): void;\n    _createBackdrop(): void;\n    _destroyBackdropEl(): void;\n    _getPlacementClasses(placement: string): PlacementClasses;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n\n    addEventListenerInstance(\n        element: HTMLElement,\n        type: string,\n        handler: EventListenerOrEventListenerObject\n    ): void;\n    removeAllEventListenerInstances(): void;\n    getAllEventListenerInstances(): void;\n}\n",
      "path": "src/components/drawer/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/drawer/types.ts",
      "content": "import { DrawerInterface } from '@/components/drawer/interface';\n\nexport declare type DrawerOptions = {\n    placement?: string;\n    bodyScrolling?: boolean;\n    backdrop?: boolean;\n    edge?: boolean;\n    edgeOffset?: string;\n    backdropClasses?: string;\n    onShow?: (drawer: DrawerInterface) => void;\n    onHide?: (drawer: DrawerInterface) => void;\n    onToggle?: (drawer: DrawerInterface) => void;\n};\n\nexport declare type PlacementClasses = {\n    base: string[];\n    active: string[];\n    inactive: string[];\n};\n",
      "path": "src/components/drawer/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/interface.ts",
      "content": "import {\n    DropdownOptions,\n    DropdownTriggerType,\n    DropdownTriggerEventTypes,\n} from '@/components/dropdown/types';\nimport type { Instance as PopperInstance } from '@popperjs/core';\n\nexport declare interface DropdownInterface {\n    _targetEl: HTMLElement;\n    _triggerEl: HTMLElement;\n    _options: DropdownOptions;\n    _visible: boolean;\n    _popperInstance: PopperInstance;\n    _initialized: boolean;\n    _clickOutsideEventListener: EventListenerOrEventListenerObject;\n\n    init(): void;\n    _createPopperInstance(): PopperInstance;\n    _setupEventListeners(): void;\n    _setupClickOutsideListener(): void;\n    _removeClickOutsideListener(): void;\n    _handleClickOutside(ev: Event, targetEl: HTMLElement): void;\n    _getTriggerEvents(\n        triggerType: DropdownTriggerType\n    ): DropdownTriggerEventTypes;\n    isVisible(): boolean;\n    toggle(): void;\n    show(): void;\n    hide(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/dropdown/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/types.ts",
      "content": "import { DropdownInterface } from '@/components/dropdown/interface';\nimport type { Placement } from '@popperjs/core';\n\nexport declare type DropdownTriggerType = 'click' | 'hover' | 'none';\n\nexport declare type DropdownTriggerEventTypes = {\n    showEvents: string[];\n    hideEvents: string[];\n};\n\nexport declare type DropdownOptions = {\n    placement?: Placement;\n    triggerType?: DropdownTriggerType;\n    offsetSkidding?: number;\n    offsetDistance?: number;\n    ignoreClickOutsideClass?: string | boolean;\n    delay?: number;\n    onShow?: (tooltip: DropdownInterface) => void;\n    onHide?: (tooltip: DropdownInterface) => void;\n    onToggle?: (tooltip: DropdownInterface) => void;\n};\n",
      "path": "src/components/dropdown/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/input-counter/interface.ts",
      "content": "import { InputCounterOptions } from '@/components/input-counter/types';\n\nexport declare interface InputCounterInterface {\n    _targetEl: HTMLElement | null;\n    _incrementEl: HTMLElement | null;\n    _decrementEl: HTMLElement | null;\n    _options: InputCounterOptions;\n\n    init(): void;\n    increment(): void;\n    decrement(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/input-counter/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/input-counter/types.ts",
      "content": "import { InputCounterInterface } from '@/components/input-counter/interface';\n\nexport declare type InputCounterOptions = {\n    minValue?: number | null;\n    maxValue?: number | null;\n    onIncrement?: (InputCounter: InputCounterInterface) => void;\n    onDecrement?: (InputCounter: InputCounterInterface) => void;\n};\n",
      "path": "src/components/input-counter/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/modal/interface.ts",
      "content": "import { ModalOptions } from '@/components/modal/types';\n\nexport declare interface ModalInterface {\n    // The HTMLElement that will be used as the modal container\n    _targetEl: HTMLElement | null;\n\n    // An object that defines the options for the modal, such as its placement and backdrop\n    _options: ModalOptions;\n\n    // A boolean that indicates whether the modal is currently hidden\n    _isHidden: boolean;\n\n    // The HTMLElement that will be used as the modal's backdrop\n    _backdropEl: HTMLElement | null;\n\n    _clickOutsideEventListener: EventListenerOrEventListenerObject;\n\n    _keydownEventListener: EventListenerOrEventListenerObject;\n\n    // Initializes the modal and sets up its event listeners\n    init(): void;\n\n    // Creates the modal's backdrop element and adds it to the DOM\n    _createBackdrop(): void;\n\n    // Removes the modal's backdrop element from the DOM\n    _destroyBackdropEl(): void;\n\n    // Sets up event listeners for the modal to allow it to be closed when clicked outside or the Escape key is pressed\n    _setupModalCloseEventListeners(): void;\n\n    // Handles clicks outside the modal and hides it if necessary\n    _handleOutsideClick(target: EventTarget): void;\n\n    // Returns an array of CSS classes that should be applied to the modal based on its placement option\n    _getPlacementClasses(): string[];\n\n    // Toggles the visibility of the modal and calls the onToggle callback function\n    toggle(): void;\n\n    // Shows the modal and calls the onShow callback function\n    show(): void;\n\n    // Hides the modal and calls the onHide callback function\n    hide(): void;\n\n    // return true if modal is hidden\n    isHidden(): boolean;\n\n    // return true if modal is visible\n    isVisible(): boolean;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n    addEventListenerInstance(\n        element: HTMLElement,\n        type: string,\n        handler: EventListenerOrEventListenerObject\n    ): void;\n    removeAllEventListenerInstances(): void;\n    getAllEventListenerInstances(): void;\n}\n",
      "path": "src/components/modal/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/modal/types.ts",
      "content": "import { ModalInterface } from '@/components/modal/interface';\n\nexport declare type modalBackdrop = 'static' | 'dynamic';\nexport declare type modalPlacement =\n    | 'top-left'\n    | 'top-center'\n    | 'top-right'\n    | 'center-left'\n    | 'center'\n    | 'center-right'\n    | 'bottom-left'\n    | 'bottom-center'\n    | 'bottom-right';\n\nexport declare type ModalOptions = {\n    placement?: modalPlacement;\n    backdropClasses?: string;\n    backdrop?: modalBackdrop;\n    closable?: boolean;\n    onShow?: (modal: ModalInterface) => void;\n    onHide?: (modal: ModalInterface) => void;\n    onToggle?: (modal: ModalInterface) => void;\n};\n",
      "path": "src/components/modal/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/popover/interface.ts",
      "content": "import {\n    PopoverOptions,\n    PopoverTriggerType,\n    PopoverTriggerEventTypes,\n} from '@/components/popover/types';\nimport type { Instance as PopperInstance } from '@popperjs/core';\n\nexport declare interface PopoverInterface {\n    _targetEl: HTMLElement | null;\n    _triggerEl: HTMLElement | null;\n    _options: PopoverOptions;\n    _popperInstance: PopperInstance;\n    _clickOutsideEventListener: EventListenerOrEventListenerObject;\n    _keydownEventListener: EventListenerOrEventListenerObject;\n\n    init(): void;\n    _setupEventListeners(): void;\n    _setupClickOutsideListener(): void;\n    _removeClickOutsideListener(): void;\n    _setupKeydownListener(): void;\n    _removeKeydownListener(): void;\n    _handleClickOutside(ev: Event, targetEl: HTMLElement): void;\n    _getTriggerEvents(\n        triggerType: PopoverTriggerType\n    ): PopoverTriggerEventTypes;\n    isVisible(): boolean;\n    show(): void;\n    hide(): void;\n    toggle(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/popover/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/popover/types.ts",
      "content": "import { PopoverInterface } from '@/components/popover/interface';\nimport type { Placement } from '@popperjs/core';\n\nexport declare type PopoverTriggerType = 'click' | 'hover' | 'none';\n\nexport declare type PopoverTriggerEventTypes = {\n    showEvents: string[];\n    hideEvents: string[];\n};\n\nexport declare type PopoverOptions = {\n    placement?: Placement;\n    offset?: number;\n    triggerType?: PopoverTriggerType;\n    onShow?: (tooltip: PopoverInterface) => void;\n    onHide?: (tooltip: PopoverInterface) => void;\n    onToggle?: (tooltip: PopoverInterface) => void;\n};\n",
      "path": "src/components/popover/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/tabs/interface.ts",
      "content": "import { TabItem, TabsOptions } from '@/components/tabs/types';\n\nexport declare interface TabsInterface {\n    _tabsEl: HTMLElement;\n    _items: TabItem[];\n    _activeTab: TabItem;\n    _options: TabsOptions;\n\n    init(): void;\n    setActiveTab(tab: TabItem): void;\n    getActiveTab(): TabItem;\n    getTab(id: string): TabItem;\n    show(id: string, forceShow?: boolean): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/tabs/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/tabs/types.ts",
      "content": "import { TabsInterface } from '@/components/tabs/interface';\n\nexport declare type TabsOptions = {\n    defaultTabId?: string;\n    activeClasses?: string;\n    inactiveClasses?: string;\n    onShow?: (tabs: TabsInterface, tab: TabItem) => void;\n};\n\nexport declare type TabItem = {\n    id: string;\n    triggerEl: HTMLElement;\n    targetEl: HTMLElement;\n};\n",
      "path": "src/components/tabs/types.ts"
    },
    {
      "type": "registry:component",
      "target": "components/tooltip/interface.ts",
      "content": "import {\n    TooltipOptions,\n    TooltipTriggerType,\n    TooltipTriggerEventTypes,\n} from '@/components/tooltip/types';\nimport type { Instance as PopperInstance } from '@popperjs/core';\n\nexport declare interface TooltipInterface {\n    _targetEl: HTMLElement | null;\n    _triggerEl: HTMLElement | null;\n    _options: TooltipOptions;\n    _popperInstance: PopperInstance;\n    _clickOutsideEventListener: EventListenerOrEventListenerObject;\n    _keydownEventListener: EventListenerOrEventListenerObject;\n\n    init(): void;\n    _setupEventListeners(): void;\n    _setupClickOutsideListener(): void;\n    _removeClickOutsideListener(): void;\n    _setupKeydownListener(): void;\n    _removeKeydownListener(): void;\n    _handleClickOutside(ev: Event, targetEl: HTMLElement): void;\n    _getTriggerEvents(\n        triggerType: TooltipTriggerType\n    ): TooltipTriggerEventTypes;\n    isVisible(): boolean;\n    show(): void;\n    hide(): void;\n    toggle(): void;\n\n    destroy(): void;\n    removeInstance(): void;\n    destroyAndRemoveInstance(): void;\n}\n",
      "path": "src/components/tooltip/interface.ts"
    },
    {
      "type": "registry:component",
      "target": "components/tooltip/types.ts",
      "content": "import { TooltipInterface } from '@/components/tooltip/interface';\nimport type { Placement } from '@popperjs/core';\n\nexport declare type TooltipTriggerType = 'click' | 'hover' | 'none';\n\nexport declare type TooltipTriggerEventTypes = {\n    showEvents: string[];\n    hideEvents: string[];\n};\n\nexport declare type TooltipOptions = {\n    placement?: Placement;\n    triggerType?: TooltipTriggerType;\n    onShow?: (tooltip: TooltipInterface) => void;\n    onHide?: (tooltip: TooltipInterface) => void;\n    onToggle?: (tooltip: TooltipInterface) => void;\n};\n",
      "path": "src/components/tooltip/types.ts"
    }
  ]
}
