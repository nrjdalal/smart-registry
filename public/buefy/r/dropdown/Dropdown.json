{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dropdown/Dropdown",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:file",
      "target": "directives/trapFocus.js",
      "content": "const findFocusable = (element, programmatic = false) => {\n    if (!element) {\n        return null\n    }\n    if (programmatic) {\n        return element.querySelectorAll(`*[tabindex=\"-1\"]`)\n    }\n    return element.querySelectorAll(`a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]`)\n}\n\nlet onKeyDown\n\nconst bind = (el, { value = true }) => {\n    if (value) {\n        let focusable = findFocusable(el)\n        let focusableProg = findFocusable(el, true)\n\n        if (focusable && focusable.length > 0) {\n            onKeyDown = (event) => {\n                // Need to get focusable each time since it can change between key events\n                // ex. changing month in a datepicker\n                focusable = findFocusable(el)\n                focusableProg = findFocusable(el, true)\n                const firstFocusable = focusable[0]\n                const lastFocusable = focusable[focusable.length - 1]\n\n                if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    lastFocusable.focus()\n                } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {\n                    event.preventDefault()\n                    firstFocusable.focus()\n                }\n            }\n            el.addEventListener('keydown', onKeyDown)\n        }\n    }\n}\n\nconst unbind = (el) => {\n    el.removeEventListener('keydown', onKeyDown)\n}\n\nconst directive = {\n    bind,\n    unbind\n}\n\nexport default directive\n",
      "path": "src/directives/trapFocus.js"
    },
    {
      "type": "registry:component",
      "target": "components/dropdown/Dropdown.vue",
      "content": "<template>\n    <div\n        class=\"dropdown dropdown-menu-animation\"\n        ref=\"dropdown\"\n        :class=\"rootClasses\"\n        @mouseleave=\"isHoverable = false\"\n    >\n        <div\n            v-if=\"!inline\"\n            :tabindex=\"disabled ? false : triggerTabindex\"\n            ref=\"trigger\"\n            class=\"dropdown-trigger\"\n            @click=\"onClick\"\n            @contextmenu.prevent=\"onContextMenu\"\n            @mouseenter=\"onHover\"\n            @focus.capture=\"onFocus\"\n            @touchstart=\"onTouchStart\"\n            @touchmove=\"onTouchMove\"\n            @touchend=\"onTouchEnd\"\n            aria-haspopup=\"true\">\n            <slot name=\"trigger\" :active=\"isActive\"/>\n        </div>\n\n        <transition :name=\"animation\">\n            <div\n                v-if=\"isMobileModal\"\n                v-show=\"isActive\"\n                class=\"background\"\n                :aria-hidden=\"!isActive\"\n            />\n        </transition>\n        <transition :name=\"animation\">\n            <div\n                v-show=\"(!disabled && (isActive || isHoverable)) || inline\"\n                ref=\"dropdownMenu\"\n                class=\"dropdown-menu\"\n                :style=\"style\"\n                :aria-hidden=\"!isActive\"\n                v-trap-focus=\"trapFocus\">\n                <div\n                    class=\"dropdown-content\"\n                    :role=\"ariaRole\"\n                    :aria-modal=\"!inline\"\n                    :style=\"contentStyle\">\n                    <slot/>\n                </div>\n            </div>\n        </transition>\n    </div>\n</template>\n\n<script>\nimport trapFocus from '@/directives/trapFocus'\nimport config from '@/utils/config'\nimport { removeElement, createAbsoluteElement, isCustomElement, toCssWidth } from '@/utils/helpers'\nimport ProviderParentMixin from '@/utils/ProviderParentMixin'\n\nconst DEFAULT_CLOSE_OPTIONS = ['escape', 'outside']\n\nexport default {\n    name: 'BDropdown',\n    directives: {\n        trapFocus\n    },\n    mixins: [ProviderParentMixin('dropdown')],\n    props: {\n        value: {\n            type: [String, Number, Boolean, Object, Array, Function],\n            default: null\n        },\n        disabled: Boolean,\n        inline: Boolean,\n        scrollable: Boolean,\n        maxHeight: {\n            type: [String, Number],\n            default: 200\n        },\n        position: {\n            type: String,\n            validator(value) {\n                return [\n                    'is-top-right',\n                    'is-top-left',\n                    'is-bottom-left',\n                    'is-bottom-right'\n                ].indexOf(value) > -1\n            }\n        },\n        triggers: {\n            type: Array,\n            default: () => ['click']\n        },\n        mobileModal: {\n            type: Boolean,\n            default: () => {\n                return config.defaultDropdownMobileModal\n            }\n        },\n        ariaRole: {\n            type: String,\n            validator(value) {\n                return [\n                    'menu',\n                    'list',\n                    'dialog'\n                ].indexOf(value) > -1\n            },\n            default: null\n        },\n        animation: {\n            type: String,\n            default: 'fade'\n        },\n        multiple: Boolean,\n        trapFocus: {\n            type: Boolean,\n            default: () => {\n                return config.defaultTrapFocus\n            }\n        },\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        canClose: {\n            type: [Array, Boolean],\n            default: true\n        },\n        expanded: Boolean,\n        appendToBody: Boolean,\n        appendToBodyCopyParent: Boolean,\n        triggerTabindex: {\n            type: Number,\n            default: 0\n        }\n    },\n    data() {\n        return {\n            selected: this.value,\n            style: {},\n            isActive: false,\n            isHoverable: false,\n            maybeTap: false,\n            isTouchEnabled: false,\n            _bodyEl: undefined, // Used to append to body\n            timeOutID: null,\n            timeOutID2: null\n        }\n    },\n    computed: {\n        rootClasses() {\n            return [this.position, {\n                'is-disabled': this.disabled,\n                'is-hoverable': this.hoverable,\n                'is-inline': this.inline,\n                'is-active': this.isActive || this.inline,\n                'is-mobile-modal': this.isMobileModal,\n                'is-expanded': this.expanded,\n                'is-touch-enabled': this.isTouchEnabled\n            }]\n        },\n        isMobileModal() {\n            return this.mobileModal && !this.inline\n        },\n        cancelOptions() {\n            return typeof this.canClose === 'boolean'\n                ? this.canClose\n                    ? DEFAULT_CLOSE_OPTIONS\n                    : []\n                : this.canClose\n        },\n        contentStyle() {\n            return {\n                maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,\n                overflow: this.scrollable ? 'auto' : null\n            }\n        },\n        hoverable() {\n            return this.triggers.indexOf('hover') >= 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed set the new selected item.\n        */\n        value(value) {\n            this.selected = value\n        },\n\n        /**\n        * Emit event when isActive value is changed.\n        *\n        * Also resets `isTouchEnabled` when it turns inactive.\n        */\n        isActive(value) {\n            this.$emit('active-change', value)\n            if (!value) {\n                // delays to reset the touch enabled flag until the dropdown\n                // menu disappears to avoid glitches\n                // also takes care of chattering, e.g., repeated quick taps,\n                // otherwise the flag may become inconsistent with the actual\n                // state of the dropdown menu\n                this.timeOutID = setTimeout(() => {\n                    if (!this.isActive) {\n                        this.isTouchEnabled = false\n                    }\n                }, 250)\n            }\n            this.handleScroll()\n            if (this.appendToBody) {\n                this.$nextTick(() => {\n                    this.updateAppendToBody()\n                })\n            }\n        },\n\n        isHoverable(value) {\n            if (this.hoverable) {\n                this.$emit('active-change', value)\n            }\n        }\n    },\n    methods: {\n        handleScroll() {\n            if (typeof window === 'undefined') return\n\n            if (this.isMobileModal) {\n                if (this.isActive) {\n                    document.documentElement.classList.add('is-clipped-touch')\n                } else {\n                    document.documentElement.classList.remove('is-clipped-touch')\n                }\n            }\n        },\n\n        /**\n         * Click listener from DropdownItem.\n         *   1. Set new selected item.\n         *   2. Emit input event to update the user v-model.\n         *   3. Close the dropdown.\n         */\n        selectItem(value) {\n            if (this.multiple) {\n                if (this.selected) {\n                    if (this.selected.indexOf(value) === -1) {\n                        // Add value\n                        this.selected = [...this.selected, value]\n                    } else {\n                        // Remove value\n                        this.selected = this.selected.filter((val) => val !== value)\n                    }\n                } else {\n                    this.selected = [value]\n                }\n                this.$emit('change', this.selected)\n            } else {\n                if (this.selected !== value) {\n                    this.selected = value\n                    this.$emit('change', this.selected)\n                }\n            }\n            this.$emit('input', this.selected)\n            if (!this.multiple) {\n                this.isActive = !this.closeOnClick\n                if (this.hoverable && this.closeOnClick) {\n                    this.isHoverable = false\n                }\n            }\n        },\n\n        /**\n        * White-listed items to not close when clicked.\n        */\n        isInWhiteList(el) {\n            if (el === this.$refs.dropdownMenu) return true\n            if (el === this.$refs.trigger) return true\n            // All chidren from dropdown\n            if (this.$refs.dropdownMenu !== undefined) {\n                const children = this.$refs.dropdownMenu.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            // All children from trigger\n            if (this.$refs.trigger !== undefined) {\n                const children = this.$refs.trigger.querySelectorAll('*')\n                for (const child of children) {\n                    if (el === child) {\n                        return true\n                    }\n                }\n            }\n            return false\n        },\n\n        /**\n        * Close dropdown if clicked outside.\n        */\n        clickedOutside(event) {\n            if (this.cancelOptions.indexOf('outside') < 0) return\n            if (this.inline) return\n\n            const target = isCustomElement(this) ? event.composedPath()[0] : event.target\n            if (!this.isInWhiteList(target)) this.isActive = false\n        },\n\n        /**\n         * Keypress event that is bound to the document\n         */\n        keyPress({ key }) {\n            if (this.isActive && (key === 'Escape' || key === 'Esc')) {\n                if (this.cancelOptions.indexOf('escape') < 0) return\n                this.isActive = false\n            }\n        },\n\n        onClick() {\n            // hover precedes\n            if (this.triggers.indexOf('hover') !== -1) return\n            if (this.triggers.indexOf('click') < 0) return\n            this.toggle()\n        },\n        onContextMenu() {\n            if (this.triggers.indexOf('contextmenu') < 0) return\n            this.toggle()\n        },\n        onHover() {\n            if (this.triggers.indexOf('hover') < 0) return\n            // touch precedes\n            if (this.isTouchEnabled) return\n            this.isHoverable = true\n        },\n        // takes care of touch-enabled devices\n        // - does nothing if hover trigger is disabled\n        // - suppresses hover trigger by setting isTouchEnabled\n        // - handles only a tap; i.e., touchstart on the trigger immediately\n        //   folowed by touchend\n        onTouchStart() {\n            this.maybeTap = true\n        },\n        onTouchMove() {\n            this.maybeTap = false\n        },\n        onTouchEnd(e) {\n            if (this.triggers.indexOf('hover') === -1) return\n            if (!this.maybeTap) return\n            // tap on dropdown contents may happen without preventDefault\n            e.preventDefault()\n            this.maybeTap = false\n            this.isTouchEnabled = true\n            this.toggle()\n        },\n        onFocus() {\n            if (this.triggers.indexOf('focus') < 0) return\n            this.toggle()\n        },\n\n        /**\n        * Toggle dropdown if it's not disabled.\n        */\n        toggle() {\n            if (this.disabled) return\n\n            if (!this.isActive) {\n                // if not active, toggle after clickOutside event\n                // this fixes toggling programmatic\n                this.$nextTick(() => {\n                    const value = !this.isActive\n                    this.isActive = value\n                    // Vue 2.6.x ???\n                    this.timeOutID2 = setTimeout(() => (this.isActive = value))\n                })\n            } else {\n                this.isActive = !this.isActive\n            }\n        },\n\n        updateAppendToBody() {\n            const dropdown = this.$refs.dropdown\n            const dropdownMenu = this.$refs.dropdownMenu\n            const trigger = this.$refs.trigger\n            if (dropdownMenu && trigger) {\n                // update wrapper dropdown\n                const dropdownWrapper = this.$data._bodyEl.children[0]\n                dropdownWrapper.classList.forEach((item) => dropdownWrapper.classList.remove(item))\n                dropdownWrapper.classList.add('dropdown')\n                dropdownWrapper.classList.add('dropdown-menu-animation')\n                if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {\n                    dropdownWrapper.classList.add(this.$vnode.data.staticClass)\n                }\n                this.rootClasses.forEach((item) => {\n                    // skip position prop\n                    if (item && typeof item === 'object') {\n                        for (let key in item) {\n                            if (item[key]) {\n                                dropdownWrapper.classList.add(key)\n                            }\n                        }\n                    }\n                })\n                if (this.appendToBodyCopyParent) {\n                    const parentNode = this.$refs.dropdown.parentNode\n                    const parent = this.$data._bodyEl\n                    parent.classList.forEach((item) => parent.classList.remove(item))\n                    parentNode.classList.forEach((item) => {\n                        parent.classList.add(item)\n                    })\n                }\n                const rect = trigger.getBoundingClientRect()\n                let top = rect.top + window.scrollY\n                let left = rect.left + window.scrollX\n                if (!this.position || this.position.indexOf('bottom') >= 0) {\n                    top += trigger.clientHeight\n                } else {\n                    top -= dropdownMenu.clientHeight\n                }\n                if (this.position && this.position.indexOf('left') >= 0) {\n                    left -= (dropdownMenu.clientWidth - trigger.clientWidth)\n                }\n                this.style = {\n                    position: 'absolute',\n                    top: `${top}px`,\n                    left: `${left}px`,\n                    zIndex: '99',\n                    width: this.expanded ? `${dropdown.offsetWidth}px` : undefined\n                }\n            }\n        }\n    },\n    mounted() {\n        if (this.appendToBody) {\n            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu)\n            this.updateAppendToBody()\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('click', this.clickedOutside)\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('click', this.clickedOutside)\n            document.removeEventListener('keyup', this.keyPress)\n        }\n        if (this.appendToBody) {\n            removeElement(this.$data._bodyEl)\n        }\n        clearTimeout(this.timeOutID)\n        clearTimeout(this.timeOutID2)\n    }\n}\n</script>\n",
      "path": "src/components/dropdown/Dropdown.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/ProviderParentMixin.js",
      "content": "import {hasFlag} from '@/utils/helpers'\n\nconst items = 1\nconst sorted = 3\n\nexport const Items = items\nexport const Sorted = sorted\n\nexport default (itemName, flags = 0) => {\n    const mixin = {\n        provide() {\n            return {\n                ['b' + itemName]: this\n            }\n        }\n    }\n\n    if (hasFlag(flags, items)) {\n        mixin.data = function () {\n            return {\n                childItems: []\n            }\n        }\n        mixin.methods = {\n            _registerItem(item) {\n                this.childItems.push(item)\n            },\n            _unregisterItem(item) {\n                this.childItems = this.childItems.filter((i) => i !== item)\n            }\n        }\n\n        if (hasFlag(flags, sorted)) {\n            mixin.watch = {\n                /**\n                 * When items are added/removed deep search in the elements default's slot\n                 * And mark the items with their index\n                 */\n                childItems(items) {\n                    if (items.length > 0 && this.$scopedSlots.default) {\n                        let tag = items[0].$vnode.tag\n                        let index = 0\n\n                        const deepSearch = (children) => {\n                            for (let child of children) {\n                                if (child.tag === tag) {\n                                    // An item with the same tag will for sure be found\n                                    const it = items.find((i) => i.$vnode === child)\n                                    if (it) {\n                                        it.index = index++\n                                    }\n                                } else if (child.tag) {\n                                    const sub = child.componentInstance\n                                        ? (child.componentInstance.$scopedSlots.default\n                                            ? child.componentInstance.$scopedSlots.default()\n                                            : child.componentInstance.$children)\n                                        : child.children\n                                    if (Array.isArray(sub) && sub.length > 0) {\n                                        deepSearch(sub.map((e) => e.$vnode))\n                                    }\n                                }\n                            }\n                            return false\n                        }\n\n                        deepSearch(this.$scopedSlots.default())\n                    }\n                }\n            }\n            mixin.computed = {\n                /**\n                 * When items are added/removed sort them according to their position\n                 */\n                sortedItems() {\n                    return this.childItems.slice().sort((i1, i2) => {\n                        return i1.index - i2.index\n                    })\n                }\n            }\n        }\n    }\n    return mixin\n}\n",
      "path": "src/utils/ProviderParentMixin.js"
    }
  ]
}
