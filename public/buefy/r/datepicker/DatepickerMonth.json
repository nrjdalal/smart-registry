{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "datepicker/DatepickerMonth",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/datepicker/DatepickerMonth.vue",
      "content": "<template>\n    <section class=\"datepicker-table\">\n        <div class=\"datepicker-body\" :class=\"{'has-events':hasEvents}\">\n            <div class=\"datepicker-months\">\n                <template v-for=\"(date, index) in monthDates\">\n                    <a\n                        :ref=\"`month-${date.getMonth()}`\"\n                        v-if=\"selectableDate(date) && !disabled\"\n                        :key=\"index\"\n                        :class=\"[\n                            classObject(date),\n                            {'has-event': eventsDateMatch(date)},\n                            indicators\n                        ]\"\n                        class=\"datepicker-cell\"\n                        role=\"button\"\n                        href=\"#\"\n                        :disabled=\"disabled\"\n                        @click.prevent=\"updateSelectedDate(date)\"\n                        @mouseenter=\"setRangeHoverEndDate(date)\"\n                        @keydown.prevent=\"manageKeydown($event, date)\"\n                        :tabindex=\"focused.month === date.getMonth() ? null : -1\">\n                        {{ monthNames[date.getMonth()] }}\n                        <div class=\"events\" v-if=\"eventsDateMatch(date)\">\n                            <div\n                                class=\"event\"\n                                :class=\"event.type\"\n                                v-for=\"(event, index) in eventsDateMatch(date)\"\n                                :key=\"index\"/>\n                        </div>\n                    </a>\n                    <div\n                        v-else\n                        :key=\"index\"\n                        :class=\"classObject(date)\"\n                        class=\"datepicker-cell\">\n                        {{ monthNames[date.getMonth()] }}\n                    </div>\n                </template>\n            </div>\n        </div>\n    </section>\n</template>\n\n<script>\nimport { isDefined } from '@/utils/helpers'\n\nexport default {\n    name: 'BDatepickerMonth',\n    props: {\n        value: {\n            type: [Date, Array]\n        },\n        monthNames: Array,\n        events: Array,\n        indicators: String,\n        minDate: Date,\n        maxDate: Date,\n        focused: Object,\n        disabled: Boolean,\n        dateCreator: Function,\n        unselectableDates: [Array, Function],\n        unselectableDaysOfWeek: Array,\n        selectableDates: [Array, Function],\n        range: Boolean,\n        multiple: Boolean\n    },\n    data() {\n        return {\n            selectedBeginDate: undefined,\n            selectedEndDate: undefined,\n            hoveredEndDate: undefined,\n            multipleSelectedDates: this.multiple && this.value ? this.value : []\n        }\n    },\n    computed: {\n        hasEvents() {\n            return this.events && this.events.length\n        },\n\n        /*\n        * Return array of all events in the specified month\n        */\n        eventsInThisYear() {\n            if (!this.events) return []\n\n            const yearEvents = []\n\n            for (let i = 0; i < this.events.length; i++) {\n                let event = this.events[i]\n\n                if (!event.hasOwnProperty('date')) {\n                    event = { date: event }\n                }\n                if (!event.hasOwnProperty('type')) {\n                    event.type = 'is-primary'\n                }\n                if (\n                    event.date.getFullYear() === this.focused.year\n                ) {\n                    yearEvents.push(event)\n                }\n            }\n\n            return yearEvents\n        },\n        monthDates() {\n            const year = this.focused.year\n            const months = []\n            for (let i = 0; i < 12; i++) {\n                const d = new Date(year, i, 1)\n                d.setHours(0, 0, 0, 0)\n                months.push(d)\n            }\n            return months\n        },\n\n        focusedMonth() {\n            return this.focused.month\n        },\n\n        hoveredDateRange() {\n            if (!this.range) {\n                return []\n            }\n            if (!isNaN(this.selectedEndDate)) {\n                return []\n            }\n            if (this.hoveredEndDate < this.selectedBeginDate) {\n                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)\n            }\n            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)\n        }\n    },\n    watch: {\n        focusedMonth(month) {\n            const refName = `month-${month}`\n            if (this.$refs[refName] && this.$refs[refName].length > 0) {\n                this.$nextTick(() => {\n                    if (this.$refs[refName][0]) {\n                        this.$refs[refName][0].focus()\n                    }\n                }) // $nextTick needed when year is changed\n            }\n        }\n    },\n    methods: {\n        selectMultipleDates(date) {\n            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>\n                selectedDate.getDate() === date.getDate() &&\n                selectedDate.getFullYear() === date.getFullYear() &&\n                selectedDate.getMonth() === date.getMonth()\n            )\n            if (multipleSelect.length) {\n                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>\n                    selectedDate.getDate() !== date.getDate() ||\n                    selectedDate.getFullYear() !== date.getFullYear() ||\n                    selectedDate.getMonth() !== date.getMonth()\n                )\n            } else {\n                this.multipleSelectedDates.push(date)\n            }\n            this.$emit('input', this.multipleSelectedDates)\n        },\n\n        selectableDate(day) {\n            const validity = []\n\n            if (this.minDate) {\n                validity.push(day >= this.minDate)\n            }\n\n            if (this.maxDate) {\n                validity.push(day <= this.maxDate)\n            }\n\n            validity.push(day.getFullYear() === this.focused.year)\n\n            if (this.selectableDates) {\n                if (typeof this.selectableDates === 'function') {\n                    if (this.selectableDates(day)) {\n                        return true\n                    } else {\n                        validity.push(false)\n                    }\n                } else {\n                    for (let i = 0; i < this.selectableDates.length; i++) {\n                        const enabledDate = this.selectableDates[i]\n                        if (day.getFullYear() === enabledDate.getFullYear() &&\n                            day.getMonth() === enabledDate.getMonth()) {\n                            return true\n                        } else {\n                            validity.push(false)\n                        }\n                    }\n                }\n            }\n\n            if (this.unselectableDates) {\n                if (typeof this.unselectableDates === 'function') {\n                    validity.push(!this.unselectableDates(day))\n                } else {\n                    for (let i = 0; i < this.unselectableDates.length; i++) {\n                        const disabledDate = this.unselectableDates[i]\n                        validity.push(\n                            day.getFullYear() !== disabledDate.getFullYear() ||\n                                day.getMonth() !== disabledDate.getMonth()\n                        )\n                    }\n                }\n            }\n\n            if (this.unselectableDaysOfWeek) {\n                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {\n                    const dayOfWeek = this.unselectableDaysOfWeek[i]\n                    validity.push(day.getDay() !== dayOfWeek)\n                }\n            }\n\n            return validity.indexOf(false) < 0\n        },\n        eventsDateMatch(day) {\n            if (!this.eventsInThisYear.length) return false\n\n            const monthEvents = []\n\n            for (let i = 0; i < this.eventsInThisYear.length; i++) {\n                if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {\n                    monthEvents.push(this.events[i])\n                }\n            }\n\n            if (!monthEvents.length) {\n                return false\n            }\n\n            return monthEvents\n        },\n        /*\n        * Build classObject for cell using validations\n        */\n        classObject(day) {\n            function dateMatch(dateOne, dateTwo, multiple) {\n                // if either date is null or undefined, return false\n                if (!dateOne || !dateTwo || multiple) {\n                    return false\n                }\n                if (Array.isArray(dateTwo)) {\n                    return dateTwo.some((date) => (\n                        dateOne.getFullYear() === date.getFullYear() &&\n                        dateOne.getMonth() === date.getMonth()\n                    ))\n                }\n                return (dateOne.getFullYear() === dateTwo.getFullYear() &&\n                    dateOne.getMonth() === dateTwo.getMonth())\n            }\n            function dateWithin(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || multiple) { return false }\n\n                return dateOne > dates[0] && dateOne < dates[1]\n            }\n            function dateMultipleSelected(dateOne, dates, multiple) {\n                if (!Array.isArray(dates) || !multiple) { return false }\n                return dates.some((date) => (\n                    dateOne.getDate() === date.getDate() &&\n                    dateOne.getFullYear() === date.getFullYear() &&\n                    dateOne.getMonth() === date.getMonth()\n                ))\n            }\n\n            return {\n                'is-selected': dateMatch(day, this.value, this.multiple) ||\n                               dateWithin(day, this.value, this.multiple) ||\n                               dateMultipleSelected(day, this.multipleSelectedDates, this.multiple),\n                'is-first-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.value) && this.value[0],\n                        this.multiple\n                    ),\n                'is-within-selected':\n                    dateWithin(day, this.value, this.multiple),\n                'is-last-selected':\n                    dateMatch(\n                        day,\n                        Array.isArray(this.value) && this.value[1],\n                        this.multiple\n                    ),\n                'is-within-hovered-range':\n                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&\n                    (dateMatch(day, this.hoveredDateRange) ||\n                        dateWithin(day, this.hoveredDateRange)),\n                'is-first-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]\n                ),\n                'is-within-hovered':\n                    dateWithin(day, this.hoveredDateRange),\n                'is-last-hovered': dateMatch(\n                    day,\n                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]\n                ),\n                'is-today': dateMatch(day, this.dateCreator()),\n                'is-selectable': this.selectableDate(day) && !this.disabled,\n                'is-unselectable': !this.selectableDate(day) || this.disabled\n            }\n        },\n\n        manageKeydown({ key }, date) {\n            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys\n            switch (key) {\n                case ' ':\n                case 'Space':\n                case 'Spacebar':\n                case 'Enter': {\n                    this.updateSelectedDate(date)\n                    break\n                }\n\n                case 'ArrowLeft':\n                case 'Left': {\n                    this.changeFocus(date, -1)\n                    break\n                }\n                case 'ArrowRight':\n                case 'Right': {\n                    this.changeFocus(date, 1)\n                    break\n                }\n                case 'ArrowUp':\n                case 'Up': {\n                    this.changeFocus(date, -3)\n                    break\n                }\n                case 'ArrowDown':\n                case 'Down': {\n                    this.changeFocus(date, 3)\n                    break\n                }\n            }\n        },\n\n        /*\n        * Emit input event with selected date as payload for v-model in parent\n        */\n        updateSelectedDate(date) {\n            if (!this.range && !this.multiple) {\n                this.emitChosenDate(date)\n            } else if (this.range) {\n                this.handleSelectRangeDate(date)\n            } else if (this.multiple) {\n                this.selectMultipleDates(date)\n            }\n        },\n\n        /*\n         * Emit select event with chosen date as payload\n         */\n        emitChosenDate(day) {\n            if (this.disabled) return\n\n            if (!this.multiple) {\n                if (this.selectableDate(day)) {\n                    this.$emit('input', day)\n                }\n            } else {\n                this.selectMultipleDates(day)\n            }\n        },\n\n        /*\n        * If both begin and end dates are set, reset the end date and set the begin date.\n        * If only begin date is selected, emit an array of the begin date and the new date.\n        * If not set, only set the begin date.\n        */\n        handleSelectRangeDate(date) {\n            if (this.disabled) return\n            if (this.selectedBeginDate && this.selectedEndDate) {\n                this.selectedBeginDate = date\n                this.selectedEndDate = undefined\n                this.$emit('range-start', date)\n            } else if (this.selectedBeginDate && !this.selectedEndDate) {\n                if (this.selectedBeginDate > date) {\n                    this.selectedEndDate = this.selectedBeginDate\n                    this.selectedBeginDate = date\n                } else {\n                    this.selectedEndDate = date\n                }\n                this.$emit('range-end', date)\n                this.$emit('input', [this.selectedBeginDate, this.selectedEndDate])\n            } else {\n                this.selectedBeginDate = date\n                this.$emit('range-start', date)\n            }\n        },\n\n        setRangeHoverEndDate(day) {\n            if (this.range) {\n                this.hoveredEndDate = day\n            }\n        },\n\n        changeFocus(month, inc) {\n            const nextMonth = month\n            nextMonth.setMonth(month.getMonth() + inc)\n            this.$emit('change-focus', nextMonth)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/datepicker/DatepickerMonth.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    }
  ]
}
