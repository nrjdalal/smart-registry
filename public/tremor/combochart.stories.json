{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "combochart.stories",
  "type": "registry:component",
  "dependencies": [
    "@radix-ui/react-label",
    "@radix-ui/react-switch",
    "@remixicon/react",
    "@storybook/react",
    "clsx",
    "react",
    "recharts",
    "tailwind-merge",
    "tailwind-variants"
  ],
  "files": [
    {
      "type": "registry:component",
      "target": "components/ComboChart/combochart.stories.tsx",
      "content": "import React from \"react\"\nimport type { Meta, StoryObj } from \"@storybook/react\"\n\nimport { Label } from \"@/components/Label/Label\"\nimport { Switch } from \"@/components/Switch/Switch\"\nimport { ComboChart, TooltipProps } from \"@/components/ComboChart/ComboChart\"\n\nconst chartdata = [\n  {\n    date: \"Jan 23\",\n    SolarCells: 2890,\n    Glass: 2338,\n    Encapsulant: 1450,\n    BackSheet: 1900,\n    Frame: 1600,\n    JunctionBox: 1800,\n    Adhesive: 1700,\n    Small: 50,\n  },\n  {\n    date: \"Feb 23\",\n    SolarCells: 2756,\n    Glass: 2103,\n    Encapsulant: 1200,\n    BackSheet: 1850,\n    Frame: 1700,\n    JunctionBox: 1750,\n    Adhesive: 1650,\n    Small: 51,\n  },\n  {\n    date: \"Mar 23\",\n    SolarCells: 3322,\n    Glass: 2194,\n    Encapsulant: 1300,\n    BackSheet: 2200,\n    Frame: 1400,\n    JunctionBox: 2000,\n    Adhesive: 800,\n    Small: 55,\n  },\n  {\n    date: \"Apr 23\",\n    SolarCells: 3470,\n    Glass: 2108,\n    Encapsulant: 1400,\n    BackSheet: 1600,\n    Frame: 1800,\n    JunctionBox: 1900,\n    Adhesive: -1950,\n    Small: 30,\n  },\n  {\n    date: \"May 23\",\n    SolarCells: 3475,\n    Glass: 1812,\n    Encapsulant: 1550,\n    BackSheet: 2300,\n    Frame: 1450,\n    JunctionBox: 2200,\n    Adhesive: -1600,\n    Small: 60,\n  },\n  {\n    date: \"Jun 23\",\n    SolarCells: 3129,\n    Glass: 1726,\n    Encapsulant: 1350,\n    BackSheet: 2100,\n    Frame: 1750,\n    JunctionBox: 2050,\n    Adhesive: -1700,\n    Small: 50,\n  },\n  {\n    date: \"Jul 23\",\n    SolarCells: 3490,\n    Glass: 1982,\n    Encapsulant: 1450,\n    BackSheet: 1950,\n    Frame: 1500,\n    JunctionBox: 2300,\n    Adhesive: -1800,\n    Small: 57,\n  },\n  {\n    date: \"Aug 23\",\n    SolarCells: 2903,\n    Glass: 2012,\n    Encapsulant: 1250,\n    BackSheet: 1700,\n    Frame: 1850,\n    JunctionBox: 2150,\n    Adhesive: -1900,\n    Small: 55,\n  },\n  {\n    date: \"Sep 23\",\n    SolarCells: 2643,\n    Glass: 2342,\n    Encapsulant: 1400,\n    BackSheet: 1600,\n    Frame: 1500,\n    JunctionBox: 2000,\n    Adhesive: -3750,\n    Small: 14,\n  },\n  {\n    date: \"Oct 23\",\n    SolarCells: 2837,\n    Glass: 2473,\n    Encapsulant: 1350,\n    BackSheet: 1850,\n    Frame: 1900,\n    JunctionBox: 2100,\n    Adhesive: -2600,\n    Small: 21,\n  },\n  {\n    date: \"Nov 23\",\n    SolarCells: 2954,\n    Glass: 3848,\n    Encapsulant: 1200,\n    BackSheet: 2000,\n    Frame: 1750,\n    JunctionBox: 2400,\n    Adhesive: -2950,\n    Small: 29,\n  },\n  {\n    date: \"Dec 23\",\n    SolarCells: 3239,\n    Glass: 3736,\n    Encapsulant: 1550,\n    BackSheet: 1700,\n    Frame: 1600,\n    JunctionBox: 2250,\n    Adhesive: -3800,\n    Small: 40,\n  },\n]\n\nconst meta: Meta<typeof ComboChart> = {\n  title: \"visualization/ComboChart\",\n  component: ComboChart,\n  args: {\n    data: chartdata,\n    index: \"date\",\n  },\n}\n\nexport default meta\ntype Story = StoryObj<typeof ComboChart>\n\nexport const Default: Story = {\n  render: () => (\n    <ComboChart\n      data-testid=\"combo-chart\"\n      data={chartdata}\n      index=\"date\"\n      barSeries={{\n        categories: [\"SolarCells\"],\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        colors: [\"amber\"],\n      }}\n    />\n  ),\n}\n\nexport const Biaxial: Story = {\n  render: () => (\n    <ComboChart\n      data-testid=\"combo-chart-biaxial\"\n      data={chartdata}\n      index=\"date\"\n      enableBiaxial={true}\n      barSeries={{\n        categories: [\"SolarCells\"],\n        yAxisLabel: \"BarSeries\",\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        showYAxis: true,\n        yAxisLabel: \"LineSeries\",\n        colors: [\"amber\"],\n        yAxisWidth: 70,\n      }}\n    />\n  ),\n}\n\nexport const BiaxialDoubleBars: Story = {\n  render: () => (\n    <ComboChart\n      data-testid=\"combo-chart-biaxial\"\n      data={chartdata}\n      index=\"date\"\n      enableBiaxial={true}\n      barSeries={{\n        categories: [\"SolarCells\", \"Encapsulant\"],\n        yAxisLabel: \"BarSeries\",\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        showYAxis: true,\n        yAxisLabel: \"LineSeries\",\n        colors: [\"amber\"],\n        yAxisWidth: 70,\n      }}\n    />\n  ),\n}\n\nexport const BiaxialDoubleBarsStacked: Story = {\n  render: () => (\n    <ComboChart\n      data={chartdata}\n      index=\"date\"\n      enableBiaxial={true}\n      barSeries={{\n        categories: [\"SolarCells\", \"Encapsulant\"],\n        yAxisLabel: \"BarSeries\",\n        type: \"stacked\",\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        showYAxis: true,\n        yAxisLabel: \"LineSeries\",\n        colors: [\"amber\"],\n        yAxisWidth: 70,\n      }}\n    />\n  ),\n}\n\nexport const DoubleBars: Story = {\n  render: () => (\n    <ComboChart\n      data={chartdata}\n      index=\"date\"\n      barSeries={{\n        categories: [\"SolarCells\", \"Encapsulant\"],\n        yAxisLabel: \"BarSeries\",\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        showYAxis: true,\n        yAxisLabel: \"LineSeries\",\n        colors: [\"amber\"],\n        yAxisWidth: 70,\n      }}\n    />\n  ),\n}\n\nexport const DoubleBarsStacked: Story = {\n  render: () => (\n    <ComboChart\n      data={chartdata}\n      index=\"date\"\n      barSeries={{\n        categories: [\"SolarCells\", \"Encapsulant\"],\n        yAxisLabel: \"BarSeries\",\n        type: \"stacked\",\n      }}\n      lineSeries={{\n        categories: [\"Frame\"],\n        showYAxis: true,\n        yAxisLabel: \"LineSeries\",\n        colors: [\"amber\"],\n        yAxisWidth: 70,\n      }}\n    />\n  ),\n}\n\nexport const DefaultNegative: Story = {\n  args: {\n    barSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    lineSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n  },\n}\n\nexport const WithValueFormatterBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Adhesive\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n    },\n  },\n}\n\nexport const WithAxisLabelsBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Adhesive\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n      yAxisLabel: \"BarSeries\",\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n      yAxisLabel: \"BarSeries\",\n    },\n  },\n}\n\nexport const WithAutoMinValueBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n      autoMinValue: true,\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      autoMinValue: true,\n    },\n  },\n}\n\nexport const WithMinAndMaxValueBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n      minValue: 800,\n      maxValue: 5000,\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      minValue: 2500,\n      maxValue: 3500,\n    },\n  },\n}\n\nexport const AllColorsBarsBiaxial: Story = {\n  args: {\n    barSeries: {\n      categories: [\n        \"SolarCells\",\n        \"Glass\",\n        \"Encapsulant\",\n        \"BackSheet\",\n        \"Frame\",\n        \"JunctionBox\",\n        \"Adhesive\",\n      ],\n    },\n  },\n}\n\nexport const AllColorsLinesBiaxial: Story = {\n  args: {\n    lineSeries: {\n      categories: [\n        \"SolarCells\",\n        \"Glass\",\n        \"Encapsulant\",\n        \"BackSheet\",\n        \"Frame\",\n        \"JunctionBox\",\n        \"Adhesive\",\n      ],\n    },\n  },\n}\n\nexport const WithLegendLeftBiaxial: Story = {\n  args: {\n    barSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    lineSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    enableBiaxial: true,\n    legendPosition: \"left\",\n  },\n}\n\nexport const WithLegendCenterBiaxial: Story = {\n  args: {\n    barSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    lineSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    enableBiaxial: true,\n    legendPosition: \"center\",\n  },\n}\n\nexport const WithLegendSliderBiaxial: Story = {\n  args: {\n    className: \"max-w-md\",\n    barSeries: {\n      categories: [\n        \"SolarCells\",\n        \"Glass\",\n        \"Encapsulant\",\n        \"BackSheet\",\n        \"Frame\",\n        \"JunctionBox\",\n        \"Adhesive\",\n      ],\n    },\n    lineSeries: { categories: [\"Adhesive\", \"SolarCells\"] },\n    enableLegendSlider: true,\n    onValueChange: (v) => console.log(v),\n  },\n}\n\nexport const WithConnectNullsFalseBiaxial: Story = {\n  args: {\n    data: chartdata.map((item, index) => ({\n      date: item.date,\n      Adhesive: item.Adhesive,\n      SolarCells: index > 5 && index < 8 ? null : item.SolarCells,\n    })),\n    barSeries: {\n      categories: [\"Adhesive\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      connectNulls: false,\n    },\n  },\n}\n\nexport const WithStartEndOnlyBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n    },\n    startEndOnly: true,\n  },\n}\n\nexport const WithoutYAxisBiaxial: Story = {\n  args: {\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n      showYAxis: false,\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      showYAxis: false,\n    },\n  },\n}\n\nexport const WithNoGridlinesBiaxial: Story = {\n  args: {\n    showGridLines: false,\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n    },\n  },\n}\n\nexport const WithNoLegendBiaxial: Story = {\n  args: {\n    showLegend: false,\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n    },\n  },\n}\n\nexport const WithNoTooltipBiaxial: Story = {\n  args: {\n    showTooltip: false,\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n    },\n  },\n}\n\nexport const WithOnValueChangeBiaxial: Story = {\n  args: {\n    onValueChange: (v) => console.log(v),\n    enableBiaxial: true,\n    barSeries: {\n      categories: [\"Glass\"],\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n    },\n  },\n}\n\nexport const CustomTooltip: Story = {\n  args: {\n    enableBiaxial: true,\n\n    customTooltip: (props: TooltipProps) => {\n      const { payload, active, label } = props\n      if (!active || !payload || payload.length === 0) return null\n\n      const data = payload[0].payload\n\n      const categoriesToShow = [\"Adhesive\", \"SolarCells\"]\n\n      return (\n        <div className=\"w-56 rounded-md border bg-white p-3 text-sm shadow-sm\">\n          <p className=\"mb-2 font-medium text-gray-900\">{label}</p>\n          <div className=\"flex flex-col space-y-2\">\n            {categoriesToShow.map((category) => (\n              <div key={category} className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  <div\n                    className={`h-5 w-1 rounded-full ${\n                      category === \"Adhesive\" ? \"bg-blue-500\" : \"bg-amber-500\"\n                    }`}\n                  />\n                  <p className=\"text-gray-700\">{category}</p>\n                </div>\n                <p className=\"font-medium text-gray-900\">{data[category]}</p>\n              </div>\n            ))}\n          </div>\n        </div>\n      )\n    },\n    barSeries: {\n      categories: [\"Adhesive\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n    },\n    lineSeries: {\n      colors: [\"amber\"],\n      categories: [\"SolarCells\"],\n      valueFormatter: (v) => `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n    },\n  },\n}\n\nexport const WithTooltipCallback: Story = {\n  render: () => {\n    const [callback, setCallBack] = React.useState<TooltipProps | null>(null)\n    const [checked, setChecked] = React.useState(true)\n    return (\n      <>\n        <div className=\"flex items-center gap-3\">\n          <Label htmlFor=\"a\">showTooltip</Label>\n          <Switch id=\"a\" checked={checked} onCheckedChange={setChecked} />\n        </div>\n\n        <ComboChart\n          data={chartdata}\n          index=\"date\"\n          barSeries={{\n            categories: [\"Adhesive\"],\n            valueFormatter: (v) =>\n              `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n          }}\n          lineSeries={{\n            colors: [\"amber\"],\n            categories: [\"SolarCells\"],\n            valueFormatter: (v) =>\n              `$${Intl.NumberFormat(\"us\").format(v).toString()}`,\n          }}\n          tooltipCallback={(cooltipContent) => setCallBack(cooltipContent)}\n          showTooltip={checked}\n        />\n        <pre className=\"text-xs\">{JSON.stringify(callback, null, 2)}</pre>\n      </>\n    )\n  },\n}\n",
      "path": "src/components/ComboChart/combochart.stories.tsx"
    },
    {
      "type": "registry:component",
      "target": "components/ComboChart/ComboChart.tsx",
      "content": "// Tremor ComboChart [v0.0.0]\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\"use client\"\n\nimport React from \"react\"\nimport { RiArrowLeftSLine, RiArrowRightSLine } from \"@remixicon/react\"\nimport {\n  Bar,\n  CartesianGrid,\n  Dot,\n  Label,\n  Line,\n  ComposedChart as RechartsComposedChart,\n  Legend as RechartsLegend,\n  ResponsiveContainer,\n  Tooltip,\n  XAxis,\n  YAxis,\n} from \"recharts\"\nimport { AxisDomain } from \"recharts/types/util/types\"\n\nimport { useOnWindowResize } from \"@/hooks/useOnWindowResize\"\nimport {\n  AvailableChartColors,\n  AvailableChartColorsKeys,\n  constructCategoryColors,\n  getColorClassName,\n} from \"@/utils/chartColors\"\nimport { cx } from \"@/utils/cx\"\nimport { getYAxisDomain } from \"@/utils/getYAxisDomain\"\nimport { hasOnlyOneValueForKey } from \"@/utils/hasOnlyOneValueForKey\"\n\n//#region Shape\nfunction deepEqual<T>(obj1: T, obj2: T): boolean {\n  if (obj1 === obj2) return true\n\n  if (\n    typeof obj1 !== \"object\" ||\n    typeof obj2 !== \"object\" ||\n    obj1 === null ||\n    obj2 === null\n  ) {\n    return false\n  }\n\n  const keys1 = Object.keys(obj1) as Array<keyof T>\n  const keys2 = Object.keys(obj2) as Array<keyof T>\n\n  if (keys1.length !== keys2.length) return false\n\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) return false\n  }\n\n  return true\n}\n\nconst renderShape = (\n  props: any,\n  activeBar: any | undefined,\n  activeLegend: string | undefined,\n) => {\n  const { fillOpacity, name, payload, value, width, x } = props\n  let { y, height } = props\n\n  if (height < 0) {\n    y += height\n    height = Math.abs(height) // height must be a positive number\n  }\n\n  return (\n    <rect\n      x={x}\n      y={y}\n      width={width}\n      height={height}\n      opacity={\n        activeBar || (activeLegend && activeLegend !== name)\n          ? deepEqual(activeBar, { ...payload, value })\n            ? fillOpacity\n            : 0.3\n          : fillOpacity\n      }\n    />\n  )\n}\n\n//#region Legend\n\ninterface LegendItemProps {\n  name: string\n  color: AvailableChartColorsKeys\n  onClick?: (name: string, color: AvailableChartColorsKeys) => void\n  activeLegend?: string\n  chartType: \"bar\" | \"line\"\n}\n\nconst LegendItem = ({\n  name,\n  color,\n  onClick,\n  activeLegend,\n  chartType,\n}: LegendItemProps) => {\n  const hasOnValueChange = !!onClick\n  const colorClass = getColorClassName(color, \"bg\")\n\n  return (\n    <li\n      className={cx(\n        // base\n        \"group inline-flex flex-nowrap items-center gap-1.5 whitespace-nowrap rounded px-2 py-1 transition\",\n        hasOnValueChange\n          ? \"cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800\"\n          : \"cursor-default\",\n      )}\n      onClick={(e) => {\n        e.stopPropagation()\n        onClick?.(name, color)\n      }}\n    >\n      <span\n        className={cx(\n          { \"size-2 rounded-sm\": chartType === \"bar\" },\n          {\n            \"h-[3px] w-3.5 shrink-0 rounded-full\": chartType === \"line\",\n          },\n          \"shrink-0\",\n          colorClass,\n          activeLegend && activeLegend !== name ? \"opacity-40\" : \"opacity-100\",\n        )}\n        aria-hidden={true}\n      />\n      <p\n        className={cx(\n          // base\n          \"truncate whitespace-nowrap text-xs\",\n          // text color\n          \"text-gray-700 dark:text-gray-300\",\n          hasOnValueChange &&\n            \"group-hover:text-gray-900 dark:group-hover:text-gray-50\",\n          activeLegend && activeLegend !== name ? \"opacity-40\" : \"opacity-100\",\n        )}\n      >\n        {name}\n      </p>\n    </li>\n  )\n}\n\ninterface ScrollButtonProps {\n  icon: React.ElementType\n  onClick?: () => void\n  disabled?: boolean\n}\n\nconst ScrollButton = ({ icon, onClick, disabled }: ScrollButtonProps) => {\n  const Icon = icon\n  const [isPressed, setIsPressed] = React.useState(false)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n\n  React.useEffect(() => {\n    if (isPressed) {\n      intervalRef.current = setInterval(() => {\n        onClick?.()\n      }, 300)\n    } else {\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n    }\n    return () => clearInterval(intervalRef.current as NodeJS.Timeout)\n  }, [isPressed, onClick])\n\n  React.useEffect(() => {\n    if (disabled) {\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n      setIsPressed(false)\n    }\n  }, [disabled])\n\n  return (\n    <button\n      type=\"button\"\n      className={cx(\n        // base\n        \"group inline-flex size-5 items-center truncate rounded transition\",\n        disabled\n          ? \"cursor-not-allowed text-gray-400 dark:text-gray-600\"\n          : \"cursor-pointer text-gray-700 hover:bg-gray-100 hover:text-gray-900 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-gray-50\",\n      )}\n      disabled={disabled}\n      onClick={(e) => {\n        e.stopPropagation()\n        onClick?.()\n      }}\n      onMouseDown={(e) => {\n        e.stopPropagation()\n        setIsPressed(true)\n      }}\n      onMouseUp={(e) => {\n        e.stopPropagation()\n        setIsPressed(false)\n      }}\n    >\n      <Icon className=\"size-full\" aria-hidden=\"true\" />\n    </button>\n  )\n}\n\ninterface LegendProps extends React.OlHTMLAttributes<HTMLOListElement> {\n  categories: { name: string; chartType: \"bar\" | \"line\" }[]\n  barCategoryColors: Map<string, AvailableChartColorsKeys>\n  lineCategoryColors: Map<string, AvailableChartColorsKeys>\n  onClickLegendItem?: (\n    category: string,\n    color: AvailableChartColorsKeys,\n  ) => void\n  activeLegend?: string\n  enableLegendSlider?: boolean\n}\n\ntype HasScrollProps = {\n  left: boolean\n  right: boolean\n}\n\nconst Legend = React.forwardRef<HTMLOListElement, LegendProps>((props, ref) => {\n  const {\n    categories,\n    barCategoryColors,\n    lineCategoryColors,\n    onClickLegendItem,\n    activeLegend,\n    enableLegendSlider = false,\n    className,\n    ...other\n  } = props\n  const scrollableRef = React.useRef<HTMLInputElement>(null)\n  const [hasScroll, setHasScroll] = React.useState<HasScrollProps | null>(null)\n  const [isKeyDowned, setIsKeyDowned] = React.useState<string | null>(null)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n\n  const checkScroll = React.useCallback(() => {\n    const scrollable = scrollableRef?.current\n    if (!scrollable) return\n\n    const hasLeftScroll = scrollable.scrollLeft > 0\n    const hasRightScroll =\n      scrollable.scrollWidth - scrollable.clientWidth > scrollable.scrollLeft\n\n    setHasScroll({ left: hasLeftScroll, right: hasRightScroll })\n  }, [setHasScroll])\n\n  const scrollToTest = React.useCallback(\n    (direction: \"left\" | \"right\") => {\n      const element = scrollableRef?.current\n      const width = element?.clientWidth ?? 0\n\n      if (element && enableLegendSlider) {\n        element.scrollTo({\n          left:\n            direction === \"left\"\n              ? element.scrollLeft - width\n              : element.scrollLeft + width,\n          behavior: \"smooth\",\n        })\n        setTimeout(() => {\n          checkScroll()\n        }, 400)\n      }\n    },\n    [enableLegendSlider, checkScroll],\n  )\n\n  React.useEffect(() => {\n    const keyDownHandler = (key: string) => {\n      if (key === \"ArrowLeft\") {\n        scrollToTest(\"left\")\n      } else if (key === \"ArrowRight\") {\n        scrollToTest(\"right\")\n      }\n    }\n    if (isKeyDowned) {\n      keyDownHandler(isKeyDowned)\n      intervalRef.current = setInterval(() => {\n        keyDownHandler(isKeyDowned)\n      }, 300)\n    } else {\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n    }\n    return () => clearInterval(intervalRef.current as NodeJS.Timeout)\n  }, [isKeyDowned, scrollToTest])\n\n  const keyDown = (e: KeyboardEvent) => {\n    e.stopPropagation()\n    if (e.key === \"ArrowLeft\" || e.key === \"ArrowRight\") {\n      e.preventDefault()\n      setIsKeyDowned(e.key)\n    }\n  }\n  const keyUp = (e: KeyboardEvent) => {\n    e.stopPropagation()\n    setIsKeyDowned(null)\n  }\n\n  React.useEffect(() => {\n    const scrollable = scrollableRef?.current\n    if (enableLegendSlider) {\n      checkScroll()\n      scrollable?.addEventListener(\"keydown\", keyDown)\n      scrollable?.addEventListener(\"keyup\", keyUp)\n    }\n\n    return () => {\n      scrollable?.removeEventListener(\"keydown\", keyDown)\n      scrollable?.removeEventListener(\"keyup\", keyUp)\n    }\n  }, [checkScroll, enableLegendSlider])\n\n  return (\n    <ol\n      ref={ref}\n      className={cx(\"relative overflow-hidden\", className)}\n      {...other}\n    >\n      <div\n        ref={scrollableRef}\n        className={cx(\n          \"flex h-full\",\n          enableLegendSlider\n            ? hasScroll?.right || hasScroll?.left\n              ? \"snap-mandatory items-center overflow-auto pl-4 pr-12 [scrollbar-width:none] [&::-webkit-scrollbar]:hidden\"\n              : \"\"\n            : \"flex-wrap\",\n        )}\n      >\n        {categories.map((category, index) => {\n          const barColor = barCategoryColors.get(category.name)\n          const lineColor = lineCategoryColors.get(category.name)\n          return (\n            <LegendItem\n              key={`item-${index}`}\n              name={category.name}\n              chartType={category.chartType}\n              onClick={onClickLegendItem}\n              activeLegend={activeLegend}\n              color={category.chartType === \"bar\" ? barColor! : lineColor!}\n            />\n          )\n        })}\n      </div>\n      {enableLegendSlider && (hasScroll?.right || hasScroll?.left) ? (\n        <>\n          <div\n            className={cx(\n              // base\n              \"absolute bottom-0 right-0 top-0 flex h-full items-center justify-center pr-1\",\n              // background color\n              \"bg-white dark:bg-gray-950\",\n            )}\n          >\n            <ScrollButton\n              icon={RiArrowLeftSLine}\n              onClick={() => {\n                setIsKeyDowned(null)\n                scrollToTest(\"left\")\n              }}\n              disabled={!hasScroll?.left}\n            />\n            <ScrollButton\n              icon={RiArrowRightSLine}\n              onClick={() => {\n                setIsKeyDowned(null)\n                scrollToTest(\"right\")\n              }}\n              disabled={!hasScroll?.right}\n            />\n          </div>\n        </>\n      ) : null}\n    </ol>\n  )\n})\n\nLegend.displayName = \"Legend\"\n\nconst ChartLegend = (\n  { payload }: any,\n  barCategoryColors: Map<string, AvailableChartColorsKeys>,\n  lineCategoryColors: Map<string, AvailableChartColorsKeys>,\n  setLegendHeight: React.Dispatch<React.SetStateAction<number>>,\n  activeLegend: string | undefined,\n  onClick?: (category: string, color: AvailableChartColorsKeys) => void,\n  enableLegendSlider?: boolean,\n  legendPosition?: \"left\" | \"center\" | \"right\",\n  barYAxisWidth?: number,\n  lineYAxisWidth?: number,\n) => {\n  const legendRef = React.useRef<HTMLDivElement>(null)\n\n  useOnWindowResize(() => {\n    const calculateHeight = (height: number | undefined) =>\n      height ? Number(height) + 15 : 60\n    setLegendHeight(calculateHeight(legendRef.current?.clientHeight))\n  })\n\n  const filteredPayload = payload.filter((item: any) => item.type !== \"none\")\n\n  const paddingLeft =\n    legendPosition === \"left\" && barYAxisWidth ? barYAxisWidth - 8 : 0\n  const paddingRight =\n    (legendPosition === \"right\" || legendPosition === undefined) &&\n    lineYAxisWidth\n      ? lineYAxisWidth - 8\n      : 52\n\n  return (\n    <div\n      style={{ paddingLeft: paddingLeft, paddingRight: paddingRight }}\n      ref={legendRef}\n      className={cx(\n        \"flex items-center\",\n        { \"justify-center\": legendPosition === \"center\" },\n        {\n          \"justify-start\": legendPosition === \"left\",\n        },\n        { \"justify-end\": legendPosition === \"right\" },\n      )}\n    >\n      <Legend\n        categories={filteredPayload.map((entry: any) => ({\n          name: entry.value,\n          chartType: entry.type === \"rect\" ? \"bar\" : entry.type,\n        }))}\n        barCategoryColors={barCategoryColors}\n        lineCategoryColors={lineCategoryColors}\n        onClickLegendItem={onClick}\n        activeLegend={activeLegend}\n        enableLegendSlider={enableLegendSlider}\n      />\n    </div>\n  )\n}\n\n//#region Tooltip\n\ntype TooltipProps = Pick<ChartTooltipProps, \"active\" | \"payload\" | \"label\">\n\ntype PayloadItem = {\n  category: string\n  value: number\n  index: string\n  barColor: AvailableChartColorsKeys\n  lineColor: AvailableChartColorsKeys\n  chartType: \"bar\" | \"line\"\n  type: string\n  payload: any\n}\n\ninterface ChartTooltipProps {\n  active: boolean | undefined\n  payload: PayloadItem[]\n  label: string\n  barValueFormatter?: (value: number) => string\n  lineValueFormatter?: (value: number) => string\n}\n\nconst ChartTooltip = ({\n  active,\n  payload,\n  label,\n  barValueFormatter = (value: number): string => value.toString(),\n  lineValueFormatter = (value: number): string => value.toString(),\n}: ChartTooltipProps) => {\n  if (active && payload && payload.length) {\n    const filteredPayload = payload.filter((item: any) => item.type !== \"none\")\n    return (\n      <div\n        className={cx(\n          // base\n          \"rounded-md border text-sm shadow-md\",\n          // border color\n          \"border-gray-200 dark:border-gray-800\",\n          // background color\n          \"bg-white dark:bg-gray-950\",\n        )}\n      >\n        <div className={cx(\"border-b border-inherit px-4 py-2\")}>\n          <p\n            className={cx(\n              // base\n              \"font-medium\",\n              // text color\n              \"text-gray-900 dark:text-gray-50\",\n            )}\n          >\n            {label}\n          </p>\n        </div>\n        <div className={cx(\"space-y-1 px-4 py-2\")}>\n          {filteredPayload.map(\n            ({ value, category, barColor, lineColor, chartType }, index) => (\n              <div\n                key={`id-${index}`}\n                className=\"flex items-center justify-between space-x-8\"\n              >\n                <div className=\"flex items-center space-x-2\">\n                  <div className=\"flex w-5 items-center justify-center\">\n                    <span\n                      aria-hidden=\"true\"\n                      className={cx(\n                        { \"size-2 rounded-sm\": chartType === \"bar\" },\n                        {\n                          \"h-[3px] w-3.5 shrink-0 rounded-full\":\n                            chartType === \"line\",\n                        },\n                        \"shrink-0\",\n                        getColorClassName(\n                          chartType === \"bar\" ? barColor : lineColor,\n                          \"bg\",\n                        ),\n                      )}\n                    />\n                  </div>\n                  <p\n                    className={cx(\n                      // base\n                      \"whitespace-nowrap text-right\",\n                      // text color\n                      \"text-gray-700 dark:text-gray-300\",\n                    )}\n                  >\n                    {category}\n                  </p>\n                </div>\n                <p\n                  className={cx(\n                    // base\n                    \"whitespace-nowrap text-right font-medium tabular-nums\",\n                    // text color\n                    \"text-gray-900 dark:text-gray-50\",\n                  )}\n                >\n                  {chartType === \"bar\"\n                    ? barValueFormatter(value)\n                    : lineValueFormatter(value)}\n                </p>\n              </div>\n            ),\n          )}\n        </div>\n      </div>\n    )\n  }\n  return null\n}\n\ninterface ActiveDot {\n  index?: number\n  dataKey?: string\n}\n\ntype BaseEventProps = {\n  eventType: \"category\" | \"bar\" | \"dot\"\n  categoryClicked: string\n  [key: string]: number | string\n}\n\ntype ComboChartEventProps = BaseEventProps | null | undefined\n\ntype ChartSeries = {\n  categories: string[]\n  colors?: AvailableChartColorsKeys[]\n  valueFormatter?: (value: number) => string\n  showYAxis?: boolean\n  yAxisWidth?: number\n  allowDecimals?: boolean\n  yAxisLabel?: string\n  autoMinValue?: boolean\n  minValue?: number\n  maxValue?: number\n}\n\ninterface ComboChartProps extends React.HTMLAttributes<HTMLDivElement> {\n  data: Record<string, any>[]\n  index: string\n  startEndOnly?: boolean\n  showXAxis?: boolean\n  xAxisLabel?: string\n  showGridLines?: boolean\n  intervalType?: \"preserveStartEnd\" | \"equidistantPreserveStart\"\n  showLegend?: boolean\n  showTooltip?: boolean\n  onValueChange?: (value: ComboChartEventProps) => void\n  enableLegendSlider?: boolean\n  legendPosition?: \"left\" | \"center\" | \"right\"\n  tickGap?: number\n  enableBiaxial?: boolean\n  tooltipCallback?: (tooltipCallbackContent: TooltipProps) => void\n  customTooltip?: React.ComponentType<TooltipProps>\n  barSeries: ChartSeries & {\n    type?: \"default\" | \"stacked\"\n  }\n  lineSeries?: ChartSeries & {\n    connectNulls?: boolean\n  }\n}\n\nconst ComboChart = React.forwardRef<HTMLDivElement, ComboChartProps>(\n  (props, forwardedRef) => {\n    const defaultSeries = {\n      categories: [],\n      colors: AvailableChartColors,\n      valueFormatter: (value: number) => value.toString(),\n      showYAxis: true,\n      yAxisWidth: 56,\n      yAxisLabel: undefined,\n      allowDecimals: true,\n      type: \"default\",\n      autoMinValue: false,\n      minValue: undefined,\n      maxValue: undefined,\n    }\n\n    const defaultBarSeries = defaultSeries\n    const defaultLineSeries = {\n      ...defaultSeries,\n      connectNulls: false,\n    }\n\n    const {\n      data = [],\n      index,\n      startEndOnly = false,\n      showXAxis = true,\n      showGridLines = true,\n      intervalType = \"equidistantPreserveStart\",\n      showTooltip = true,\n      showLegend = true,\n      legendPosition = \"right\",\n      enableLegendSlider = false,\n      onValueChange,\n      tickGap = 5,\n      xAxisLabel,\n      enableBiaxial = false,\n\n      barSeries = defaultBarSeries,\n      lineSeries = defaultLineSeries,\n      tooltipCallback,\n      customTooltip,\n\n      className,\n      ...other\n    } = props\n    const mergedBarSeries = { ...defaultBarSeries, ...barSeries }\n    const mergedLineSeries = { ...defaultLineSeries, ...lineSeries }\n\n    const CustomTooltip = customTooltip\n\n    const paddingValue =\n      (!showXAxis &&\n        !mergedBarSeries.showYAxis &&\n        enableBiaxial &&\n        !mergedLineSeries.showYAxis) ||\n      (startEndOnly &&\n        !mergedBarSeries.showYAxis &&\n        enableBiaxial &&\n        !mergedLineSeries.showYAxis)\n        ? 0\n        : 20\n    const [legendHeight, setLegendHeight] = React.useState(60)\n    const [activeDot, setActiveDot] = React.useState<ActiveDot | undefined>(\n      undefined,\n    )\n    const [activeLegend, setActiveLegend] = React.useState<string | undefined>(\n      undefined,\n    )\n\n    const prevActiveRef = React.useRef<boolean | undefined>(undefined)\n    const prevLabelRef = React.useRef<string | undefined>(undefined)\n\n    const barCategoryColors = constructCategoryColors(\n      mergedBarSeries.categories,\n      mergedBarSeries.colors ?? AvailableChartColors,\n    )\n    const lineCategoryColors = constructCategoryColors(\n      mergedLineSeries.categories,\n      mergedLineSeries.colors ?? AvailableChartColors,\n    )\n    const [activeBar, setActiveBar] = React.useState<any | undefined>(undefined)\n    const barYAxisDomain = getYAxisDomain(\n      mergedBarSeries.autoMinValue ?? false,\n      mergedBarSeries.minValue,\n      mergedBarSeries.maxValue,\n    )\n    const lineYAxisDomain = getYAxisDomain(\n      mergedLineSeries.autoMinValue ?? false,\n      mergedLineSeries.minValue,\n      mergedLineSeries.maxValue,\n    )\n    const hasOnValueChange = !!onValueChange\n    const stacked = barSeries.type === \"stacked\"\n\n    function onBarClick(data: any, _: any, event: React.MouseEvent) {\n      event.stopPropagation()\n      if (!onValueChange) return\n      if (deepEqual(activeBar, { ...data.payload, value: data.value })) {\n        setActiveLegend(undefined)\n        setActiveBar(undefined)\n        onValueChange?.(null)\n      } else {\n        setActiveLegend(data.tooltipPayload?.[0]?.dataKey)\n        setActiveBar({\n          ...data.payload,\n          value: data.value,\n        })\n        onValueChange?.({\n          eventType: \"bar\",\n          categoryClicked: data.tooltipPayload?.[0]?.dataKey,\n          ...data.payload,\n        })\n      }\n    }\n\n    function onDotClick(itemData: any, event: React.MouseEvent) {\n      event.stopPropagation()\n\n      if (!hasOnValueChange) return\n      if (\n        (itemData.index === activeDot?.index &&\n          itemData.dataKey === activeDot?.dataKey) ||\n        (hasOnlyOneValueForKey(data, itemData.dataKey) &&\n          activeLegend &&\n          activeLegend === itemData.dataKey)\n      ) {\n        setActiveLegend(undefined)\n        setActiveDot(undefined)\n        onValueChange?.(null)\n      } else {\n        setActiveBar(undefined)\n        setActiveLegend(itemData.dataKey)\n        setActiveDot({\n          index: itemData.index,\n          dataKey: itemData.dataKey,\n        })\n        onValueChange?.({\n          eventType: \"dot\",\n          categoryClicked: itemData.dataKey,\n          ...itemData.payload,\n        })\n      }\n    }\n\n    function onCategoryClick(dataKey: string) {\n      if (!hasOnValueChange) return\n\n      if (dataKey === activeLegend && !activeBar && !activeDot) {\n        setActiveLegend(undefined)\n        onValueChange?.(null)\n      } else if (\n        activeBar &&\n        activeBar.tooltipPayload?.[0]?.dataKey === dataKey\n      ) {\n        setActiveLegend(dataKey)\n        onValueChange?.({\n          eventType: \"category\",\n          categoryClicked: dataKey,\n        })\n      } else {\n        setActiveLegend(dataKey)\n        setActiveBar(undefined)\n        setActiveDot(undefined)\n        onValueChange?.({\n          eventType: \"category\",\n          categoryClicked: dataKey,\n        })\n      }\n    }\n\n    return (\n      <div\n        ref={forwardedRef}\n        className={cx(\"h-80 w-full\", className)}\n        tremor-id=\"tremor-raw\"\n        {...other}\n      >\n        <ResponsiveContainer>\n          <RechartsComposedChart\n            data={data}\n            onClick={\n              hasOnValueChange && (activeLegend || activeBar || activeDot)\n                ? () => {\n                    setActiveBar(undefined)\n                    setActiveDot(undefined)\n                    setActiveLegend(undefined)\n                    onValueChange?.(null)\n                  }\n                : undefined\n            }\n            margin={{\n              bottom: xAxisLabel ? 30 : undefined,\n              left: mergedBarSeries.yAxisLabel ? 20 : undefined,\n              right: mergedLineSeries.yAxisLabel ? 20 : undefined,\n              top: 5,\n            }}\n          >\n            {showGridLines ? (\n              <CartesianGrid\n                className={cx(\"stroke-gray-200 stroke-1 dark:stroke-gray-800\")}\n                horizontal={true}\n                vertical={false}\n              />\n            ) : null}\n            <XAxis\n              hide={!showXAxis}\n              tick={{\n                transform: \"translate(0, 6)\",\n              }}\n              fill=\"\"\n              stroke=\"\"\n              className={cx(\n                // base\n                \"mt-4 text-xs\",\n                // text fill\n                \"fill-gray-500 dark:fill-gray-500\",\n              )}\n              tickLine={false}\n              axisLine={false}\n              minTickGap={tickGap}\n              padding={{\n                left: paddingValue,\n                right: paddingValue,\n              }}\n              dataKey={index}\n              interval={startEndOnly ? \"preserveStartEnd\" : intervalType}\n              ticks={\n                startEndOnly\n                  ? [data[0][index], data[data.length - 1][index]]\n                  : undefined\n              }\n            >\n              {xAxisLabel && (\n                <Label\n                  position=\"insideBottom\"\n                  offset={-20}\n                  className=\"fill-gray-800 text-sm font-medium dark:fill-gray-200\"\n                >\n                  {xAxisLabel}\n                </Label>\n              )}\n            </XAxis>\n            <YAxis\n              yAxisId={enableBiaxial ? \"left\" : undefined}\n              width={mergedBarSeries.yAxisWidth}\n              hide={!mergedBarSeries.showYAxis}\n              axisLine={false}\n              tickLine={false}\n              fill=\"\"\n              stroke=\"\"\n              className={cx(\n                // base\n                \"text-xs\",\n                // text fill\n                \"fill-gray-500 dark:fill-gray-500\",\n              )}\n              tick={{\n                transform: \"translate(-3, 0)\",\n              }}\n              type=\"number\"\n              domain={barYAxisDomain as AxisDomain}\n              tickFormatter={mergedBarSeries.valueFormatter}\n              allowDecimals={mergedBarSeries.allowDecimals}\n            >\n              {mergedBarSeries.yAxisLabel && (\n                <Label\n                  position=\"insideLeft\"\n                  style={{ textAnchor: \"middle\" }}\n                  angle={-90}\n                  offset={-15}\n                  className=\"fill-gray-800 text-sm font-medium dark:fill-gray-200\"\n                >\n                  {mergedBarSeries.yAxisLabel}\n                </Label>\n              )}\n            </YAxis>\n\n            {enableBiaxial ? (\n              <YAxis\n                yAxisId=\"right\"\n                orientation=\"right\"\n                width={mergedLineSeries.yAxisWidth}\n                hide={!mergedLineSeries.showYAxis}\n                axisLine={false}\n                tickLine={false}\n                fill=\"\"\n                stroke=\"\"\n                className={cx(\n                  // base\n                  \"text-xs\",\n                  // text fill\n                  \"fill-gray-500 dark:fill-gray-500\",\n                )}\n                tick={{\n                  transform: \"translate(3, 0)\",\n                }}\n                type=\"number\"\n                domain={lineYAxisDomain as AxisDomain}\n                tickFormatter={mergedLineSeries.valueFormatter}\n                allowDecimals={mergedLineSeries.allowDecimals}\n              >\n                {mergedLineSeries.yAxisLabel && (\n                  <Label\n                    position=\"insideRight\"\n                    style={{ textAnchor: \"middle\" }}\n                    angle={-90}\n                    offset={-15}\n                    className=\"fill-gray-800 text-sm font-medium dark:fill-gray-200\"\n                  >\n                    {mergedLineSeries.yAxisLabel}\n                  </Label>\n                )}\n              </YAxis>\n            ) : null}\n\n            <Tooltip\n              wrapperStyle={{ outline: \"none\" }}\n              isAnimationActive={true}\n              animationDuration={100}\n              cursor={{ stroke: \"#d1d5db\", strokeWidth: 1 }}\n              offset={20}\n              position={{\n                y: 0,\n              }}\n              content={({ active, payload, label }) => {\n                const cleanPayload: TooltipProps[\"payload\"] = payload\n                  ? payload.map((item: any) => ({\n                      category: item.dataKey,\n                      value: item.value,\n                      index: item.payload[index],\n                      barColor: barCategoryColors.get(\n                        item.dataKey,\n                      ) as AvailableChartColorsKeys,\n                      lineColor: lineCategoryColors.get(\n                        item.dataKey,\n                      ) as AvailableChartColorsKeys,\n                      chartType: barCategoryColors.get(item.dataKey)\n                        ? \"bar\"\n                        : (\"line\" as PayloadItem[\"chartType\"]),\n                      type: item.type,\n                      payload: item.payload,\n                    }))\n                  : []\n\n                if (\n                  tooltipCallback &&\n                  (active !== prevActiveRef.current ||\n                    label !== prevLabelRef.current)\n                ) {\n                  tooltipCallback({ active, payload: cleanPayload, label })\n                  prevActiveRef.current = active\n                  prevLabelRef.current = label\n                }\n\n                return showTooltip && active ? (\n                  CustomTooltip ? (\n                    <CustomTooltip\n                      active={active}\n                      payload={cleanPayload}\n                      label={label}\n                    />\n                  ) : (\n                    <ChartTooltip\n                      active={active}\n                      payload={cleanPayload}\n                      label={label}\n                      barValueFormatter={mergedBarSeries.valueFormatter}\n                      lineValueFormatter={mergedLineSeries.valueFormatter}\n                    />\n                  )\n                ) : null\n              }}\n            />\n            {showLegend ? (\n              <RechartsLegend\n                verticalAlign=\"top\"\n                height={legendHeight}\n                content={({ payload }) =>\n                  ChartLegend(\n                    { payload },\n                    barCategoryColors,\n                    lineCategoryColors,\n                    setLegendHeight,\n                    activeLegend,\n                    hasOnValueChange\n                      ? (clickedLegendItem: string) =>\n                          onCategoryClick(clickedLegendItem)\n                      : undefined,\n                    enableLegendSlider,\n                    legendPosition,\n                    mergedBarSeries.yAxisWidth,\n                    mergedLineSeries.yAxisWidth,\n                  )\n                }\n              />\n            ) : null}\n            {mergedBarSeries.categories.map((category) => (\n              <Bar\n                yAxisId={enableBiaxial ? \"left\" : undefined}\n                className={cx(\n                  getColorClassName(\n                    barCategoryColors.get(category) as AvailableChartColorsKeys,\n                    \"fill\",\n                  ),\n                  onValueChange ? \"cursor-pointer\" : \"\",\n                )}\n                key={category}\n                name={category}\n                type=\"linear\"\n                dataKey={category}\n                stackId={stacked ? \"stack\" : undefined}\n                isAnimationActive={false}\n                fill=\"\"\n                shape={(props: any) =>\n                  renderShape(props, activeBar, activeLegend)\n                }\n                onClick={onBarClick}\n              />\n            ))}\n            {/* hidden lines to increase clickable target area */}\n            {onValueChange\n              ? mergedLineSeries.categories.map((category) => (\n                  <Line\n                    yAxisId={enableBiaxial ? \"right\" : undefined}\n                    className={cx(\"cursor-pointer\")}\n                    strokeOpacity={0}\n                    key={category}\n                    name={category}\n                    type=\"linear\"\n                    dataKey={category}\n                    stroke=\"transparent\"\n                    fill=\"transparent\"\n                    legendType=\"none\"\n                    tooltipType=\"none\"\n                    strokeWidth={12}\n                    connectNulls={mergedLineSeries.connectNulls}\n                    onClick={(props: any, event) => {\n                      event.stopPropagation()\n                      const { name } = props\n                      onCategoryClick(name)\n                    }}\n                  />\n                ))\n              : null}\n            {mergedLineSeries.categories.map((category) => (\n              <Line\n                yAxisId={enableBiaxial ? \"right\" : undefined}\n                className={cx(\n                  getColorClassName(\n                    lineCategoryColors.get(\n                      category,\n                    ) as AvailableChartColorsKeys,\n                    \"stroke\",\n                  ),\n                  hasOnValueChange && \"cursor-pointer\",\n                )}\n                strokeOpacity={\n                  activeDot || (activeLegend && activeLegend !== category)\n                    ? 0.3\n                    : 1\n                }\n                activeDot={(props: any) => {\n                  const {\n                    cx: cxCoord,\n                    cy: cyCoord,\n                    stroke,\n                    strokeLinecap,\n                    strokeLinejoin,\n                    strokeWidth,\n                    dataKey,\n                  } = props\n                  return (\n                    <Dot\n                      className={cx(\n                        \"stroke-white dark:stroke-gray-950\",\n                        onValueChange ? \"cursor-pointer\" : \"\",\n                        getColorClassName(\n                          lineCategoryColors.get(\n                            dataKey,\n                          ) as AvailableChartColorsKeys,\n                          \"fill\",\n                        ),\n                      )}\n                      cx={cxCoord}\n                      cy={cyCoord}\n                      r={5}\n                      fill=\"\"\n                      stroke={stroke}\n                      strokeLinecap={strokeLinecap}\n                      strokeLinejoin={strokeLinejoin}\n                      strokeWidth={strokeWidth}\n                      onClick={(_, event) => onDotClick(props, event)}\n                    />\n                  )\n                }}\n                dot={(props: any) => {\n                  const {\n                    stroke,\n                    strokeLinecap,\n                    strokeLinejoin,\n                    strokeWidth,\n                    cx: cxCoord,\n                    cy: cyCoord,\n                    dataKey,\n                    index,\n                  } = props\n\n                  if (\n                    (hasOnlyOneValueForKey(data, category) &&\n                      !(\n                        activeDot ||\n                        (activeLegend && activeLegend !== category)\n                      )) ||\n                    (activeDot?.index === index &&\n                      activeDot?.dataKey === category)\n                  ) {\n                    return (\n                      <Dot\n                        key={index}\n                        cx={cxCoord}\n                        cy={cyCoord}\n                        r={5}\n                        stroke={stroke}\n                        fill=\"\"\n                        strokeLinecap={strokeLinecap}\n                        strokeLinejoin={strokeLinejoin}\n                        strokeWidth={strokeWidth}\n                        className={cx(\n                          \"stroke-white dark:stroke-gray-950\",\n                          onValueChange ? \"cursor-pointer\" : \"\",\n                          getColorClassName(\n                            lineCategoryColors.get(\n                              dataKey,\n                            ) as AvailableChartColorsKeys,\n                            \"fill\",\n                          ),\n                        )}\n                      />\n                    )\n                  }\n                  return <React.Fragment key={index}></React.Fragment>\n                }}\n                key={`${category}-line-id`}\n                name={category}\n                type=\"linear\"\n                dataKey={category}\n                stroke=\"\"\n                strokeWidth={2}\n                strokeLinejoin=\"round\"\n                strokeLinecap=\"round\"\n                isAnimationActive={false}\n                connectNulls={mergedLineSeries.connectNulls}\n                onClick={(props: any, event) => {\n                  event.stopPropagation()\n                  const { name } = props\n                  onCategoryClick(name)\n                }}\n              />\n            ))}\n          </RechartsComposedChart>\n        </ResponsiveContainer>\n      </div>\n    )\n  },\n)\n\nComboChart.displayName = \"ComboChart\"\n\nexport { ComboChart, type ComboChartEventProps, type TooltipProps }\n",
      "path": "src/components/ComboChart/ComboChart.tsx"
    },
    {
      "type": "registry:component",
      "target": "components/Label/Label.tsx",
      "content": "// Tremor Label [v0.0.2]\n\nimport React from \"react\"\nimport * as LabelPrimitives from \"@radix-ui/react-label\"\n\nimport { cx } from \"@/utils/cx\"\n\ninterface LabelProps\n  extends React.ComponentPropsWithoutRef<typeof LabelPrimitives.Root> {\n  disabled?: boolean\n}\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitives.Root>,\n  LabelProps\n>(({ className, disabled, ...props }, forwardedRef) => (\n  <LabelPrimitives.Root\n    ref={forwardedRef}\n    className={cx(\n      // base\n      \"text-sm leading-none\",\n      // text color\n      \"text-gray-900 dark:text-gray-50\",\n      // disabled\n      {\n        \"text-gray-400 dark:text-gray-600\": disabled,\n      },\n      className,\n    )}\n    aria-disabled={disabled}\n    tremor-id=\"tremor-raw\"\n    {...props}\n  />\n))\n\nLabel.displayName = \"Label\"\n\nexport { Label }\n",
      "path": "src/components/Label/Label.tsx"
    },
    {
      "type": "registry:component",
      "target": "components/Switch/Switch.tsx",
      "content": "// Tremor Switch [v0.0.1]\n\nimport React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\nimport { tv, VariantProps } from \"tailwind-variants\"\n\nimport { cx } from \"@/utils/cx\"\nimport { focusRing } from \"@/utils/focusRing\"\n\nconst switchVariants = tv({\n  slots: {\n    root: [\n      // base\n      \"group relative isolate inline-flex shrink-0 cursor-pointer items-center rounded-full p-0.5 shadow-inner outline-none ring-1 ring-inset transition-all\",\n      \"bg-gray-200 dark:bg-gray-950\",\n      // ring color\n      \"ring-black/5 dark:ring-gray-800\",\n      // checked\n      \"data-[state=checked]:bg-blue-500 data-[state=checked]:dark:bg-blue-500\",\n      // disabled\n      \"data-[disabled]:cursor-default\",\n      // disabled checked\n      \"data-[disabled]:data-[state=checked]:bg-blue-200\",\n      \"data-[disabled]:data-[state=checked]:ring-gray-300\",\n      // disabled checked dark\n      \"data-[disabled]:data-[state=checked]:dark:ring-gray-900\",\n      \"data-[disabled]:data-[state=checked]:dark:bg-blue-900\",\n      // disabled unchecked\n      \"data-[disabled]:data-[state=unchecked]:ring-gray-300\",\n      \"data-[disabled]:data-[state=unchecked]:bg-gray-100\",\n      // disabled unchecked dark\n      \"data-[disabled]:data-[state=unchecked]:dark:ring-gray-700\",\n      \"data-[disabled]:data-[state=unchecked]:dark:bg-gray-800\",\n      focusRing,\n    ],\n    thumb: [\n      // base\n      \"pointer-events-none relative inline-block transform appearance-none rounded-full border-none shadow-lg outline-none transition-all duration-150 ease-in-out focus:border-none focus:outline-none focus:outline-transparent\",\n      // background color\n      \"bg-white dark:bg-gray-50\",\n      // disabled\n      \"group-data-[disabled]:shadow-none\",\n      \"group-data-[disabled]:bg-gray-50 group-data-[disabled]:dark:bg-gray-500\",\n    ],\n  },\n  variants: {\n    size: {\n      default: {\n        root: \"h-5 w-9\",\n        thumb:\n          \"h-4 w-4 data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0\",\n      },\n      small: {\n        root: \"h-4 w-7\",\n        thumb:\n          \"h-3 w-3 data-[state=checked]:translate-x-3 data-[state=unchecked]:translate-x-0\",\n      },\n    },\n  },\n  defaultVariants: {\n    size: \"default\",\n  },\n})\n\ninterface SwitchProps\n  extends Omit<\n      React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>,\n      \"asChild\"\n    >,\n    VariantProps<typeof switchVariants> {}\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  SwitchProps\n>(({ className, size, ...props }: SwitchProps, forwardedRef) => {\n  const { root, thumb } = switchVariants({ size })\n  return (\n    <SwitchPrimitives.Root\n      ref={forwardedRef}\n      className={cx(root(), className)}\n      tremor-id=\"tremor-raw\"\n      {...props}\n    >\n      <SwitchPrimitives.Thumb className={cx(thumb())} />\n    </SwitchPrimitives.Root>\n  )\n})\n\nSwitch.displayName = \"Switch\"\n\nexport { Switch }\n",
      "path": "src/components/Switch/Switch.tsx"
    },
    {
      "type": "registry:lib",
      "target": "utils/chartColors.ts",
      "content": "// Tremor chartColors [v0.1.0]\n\nexport type ColorUtility = \"bg\" | \"stroke\" | \"fill\" | \"text\"\n\nexport const chartColors = {\n  blue: {\n    bg: \"bg-blue-500\",\n    stroke: \"stroke-blue-500\",\n    fill: \"fill-blue-500\",\n    text: \"text-blue-500\",\n  },\n  emerald: {\n    bg: \"bg-emerald-500\",\n    stroke: \"stroke-emerald-500\",\n    fill: \"fill-emerald-500\",\n    text: \"text-emerald-500\",\n  },\n  violet: {\n    bg: \"bg-violet-500\",\n    stroke: \"stroke-violet-500\",\n    fill: \"fill-violet-500\",\n    text: \"text-violet-500\",\n  },\n  amber: {\n    bg: \"bg-amber-500\",\n    stroke: \"stroke-amber-500\",\n    fill: \"fill-amber-500\",\n    text: \"text-amber-500\",\n  },\n  gray: {\n    bg: \"bg-gray-500\",\n    stroke: \"stroke-gray-500\",\n    fill: \"fill-gray-500\",\n    text: \"text-gray-500\",\n  },\n  cyan: {\n    bg: \"bg-cyan-500\",\n    stroke: \"stroke-cyan-500\",\n    fill: \"fill-cyan-500\",\n    text: \"text-cyan-500\",\n  },\n  pink: {\n    bg: \"bg-pink-500\",\n    stroke: \"stroke-pink-500\",\n    fill: \"fill-pink-500\",\n    text: \"text-pink-500\",\n  },\n  lime: {\n    bg: \"bg-lime-500\",\n    stroke: \"stroke-lime-500\",\n    fill: \"fill-lime-500\",\n    text: \"text-lime-500\",\n  },\n  fuchsia: {\n    bg: \"bg-fuchsia-500\",\n    stroke: \"stroke-fuchsia-500\",\n    fill: \"fill-fuchsia-500\",\n    text: \"text-fuchsia-500\",\n  },\n} as const satisfies {\n  [color: string]: {\n    [key in ColorUtility]: string\n  }\n}\n\nexport type AvailableChartColorsKeys = keyof typeof chartColors\n\nexport const AvailableChartColors: AvailableChartColorsKeys[] = Object.keys(\n  chartColors,\n) as Array<AvailableChartColorsKeys>\n\nexport const constructCategoryColors = (\n  categories: string[],\n  colors: AvailableChartColorsKeys[],\n): Map<string, AvailableChartColorsKeys> => {\n  const categoryColors = new Map<string, AvailableChartColorsKeys>()\n  categories.forEach((category, index) => {\n    categoryColors.set(category, colors[index % colors.length])\n  })\n  return categoryColors\n}\n\nexport const getColorClassName = (\n  color: AvailableChartColorsKeys,\n  type: ColorUtility,\n): string => {\n  const fallbackColor = {\n    bg: \"bg-gray-500\",\n    stroke: \"stroke-gray-500\",\n    fill: \"fill-gray-500\",\n    text: \"text-gray-500\",\n  }\n  return chartColors[color]?.[type] ?? fallbackColor[type]\n}\n",
      "path": "src/utils/chartColors.ts"
    },
    {
      "type": "registry:lib",
      "target": "utils/cx.ts",
      "content": "// Tremor cx [v0.0.0]\n\nimport clsx, { type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cx(...args: ClassValue[]) {\n  return twMerge(clsx(...args))\n}\n",
      "path": "src/utils/cx.ts"
    },
    {
      "type": "registry:lib",
      "target": "utils/focusRing.ts",
      "content": "// Tremor focusRing [v0.0.1]\n\nexport const focusRing = [\n  // base\n  \"outline outline-offset-2 outline-0 focus-visible:outline-2\",\n  // outline color\n  \"outline-blue-500 dark:outline-blue-500\",\n]\n",
      "path": "src/utils/focusRing.ts"
    },
    {
      "type": "registry:lib",
      "target": "utils/getYAxisDomain.ts",
      "content": "// Tremor getYAxisDomain [v0.0.0]\n\nexport const getYAxisDomain = (\n  autoMinValue: boolean,\n  minValue: number | undefined,\n  maxValue: number | undefined,\n) => {\n  const minDomain = autoMinValue ? \"auto\" : (minValue ?? 0)\n  const maxDomain = maxValue ?? \"auto\"\n  return [minDomain, maxDomain]\n}\n",
      "path": "src/utils/getYAxisDomain.ts"
    },
    {
      "type": "registry:lib",
      "target": "utils/hasOnlyOneValueForKey.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n// Tremor hasOnlyOneValueForKey [v0.1.0]\n\nexport function hasOnlyOneValueForKey(\n  array: any[],\n  keyToCheck: string,\n): boolean {\n  const val: any[] = []\n\n  for (const obj of array) {\n    if (Object.prototype.hasOwnProperty.call(obj, keyToCheck)) {\n      val.push(obj[keyToCheck])\n      if (val.length > 1) {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n",
      "path": "src/utils/hasOnlyOneValueForKey.ts"
    },
    {
      "type": "registry:hook",
      "target": "hooks/useOnWindowResize.ts",
      "content": "// Tremor useOnWindowResize [v0.0.0]\n\nimport * as React from \"react\"\n\nexport const useOnWindowResize = (handler: { (): void }) => {\n  React.useEffect(() => {\n    const handleResize = () => {\n      handler()\n    }\n    handleResize()\n    window.addEventListener(\"resize\", handleResize)\n\n    return () => window.removeEventListener(\"resize\", handleResize)\n  }, [handler])\n}\n",
      "path": "src/hooks/useOnWindowResize.ts"
    }
  ]
}
