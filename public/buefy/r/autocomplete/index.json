{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "autocomplete/index",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:component",
      "target": "components/autocomplete/Autocomplete.vue",
      "content": "<template>\n    <div class=\"autocomplete control\" :class=\"{ 'is-expanded': expanded }\">\n        <b-input\n            v-model=\"newValue\"\n            ref=\"input\"\n            :type=\"type\"\n            :size=\"size\"\n            :loading=\"loading\"\n            :rounded=\"rounded\"\n            :icon=\"icon\"\n            :icon-right=\"newIconRight\"\n            :icon-right-clickable=\"newIconRightClickable\"\n            :icon-pack=\"iconPack\"\n            :maxlength=\"maxlength\"\n            :autocomplete=\"newAutocomplete\"\n            :use-html5-validation=\"false\"\n            :aria-autocomplete=\"ariaAutocomplete\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @focus=\"focused\"\n            @blur=\"onBlur\"\n            @keydown.native=\"keydown\"\n            @keydown.native.up.prevent=\"keyArrows('up')\"\n            @keydown.native.down.prevent=\"keyArrows('down')\"\n            @icon-right-click=\"rightIconClick\"\n            @icon-click=\"(event) => $emit('icon-click', event)\"\n        />\n\n        <transition name=\"fade\">\n            <div\n                class=\"dropdown-menu\"\n                :class=\"{ 'is-opened-top': isOpenedTop && !appendToBody }\"\n                :style=\"style\"\n                v-show=\"isActive && (!isEmpty || hasEmptySlot || hasHeaderSlot || hasFooterSlot)\"\n                ref=\"dropdown\"\n            >\n                <div\n                    class=\"dropdown-content\"\n                    v-show=\"isActive\"\n                    :style=\"contentStyle\">\n                    <div\n                        v-if=\"hasHeaderSlot\"\n                        class=\"dropdown-item dropdown-header\"\n                        role=\"button\"\n                        tabindex=\"0\"\n                        :class=\"{ 'is-hovered': headerHovered }\"\n                        @click=\"selectHeaderOrFoterByClick($event, 'header')\"\n                    >\n                        <slot name=\"header\" />\n                    </div>\n                    <template v-for=\"(element, groupindex) in computedData\">\n                        <div\n                            v-if=\"element.group\"\n                            :key=\"groupindex + 'group'\"\n                            class=\"dropdown-item\">\n                            <slot\n                                v-if=\"hasGroupSlot\"\n                                name=\"group\"\n                                :group=\"element.group\"\n                                :index=\"groupindex\" />\n                            <span class=\"has-text-weight-bold\" v-else>\n                                {{ element.group }}\n                            </span>\n                        </div>\n                        <a\n                            v-for=\"(option, index) in element.items\"\n                            :key=\"groupindex + ':' + index\"\n                            class=\"dropdown-item\"\n                            role=\"button\"\n                            tabindex=\"0\"\n                            :class=\"{ 'is-hovered': option === hovered }\"\n                            @click.stop=\"setSelected(option, !keepOpen, $event)\"\n                        >\n                            <slot\n                                v-if=\"hasDefaultSlot\"\n                                :option=\"option\"\n                                :index=\"index\" />\n                            <span v-else>\n                                {{ getValue(option, true) }}\n                            </span>\n                        </a>\n                    </template>\n                    <div\n                        v-if=\"isEmpty && hasEmptySlot\"\n                        class=\"dropdown-item is-disabled\">\n                        <slot name=\"empty\" />\n                    </div>\n                    <div\n                        v-if=\"hasFooterSlot\"\n                        class=\"dropdown-item dropdown-footer\"\n                        role=\"button\"\n                        tabindex=\"0\"\n                        :class=\"{ 'is-hovered': footerHovered }\"\n                        @click=\"selectHeaderOrFoterByClick($event, 'footer')\"\n                    >\n                        <slot name=\"footer\" />\n                    </div>\n                </div>\n            </div>\n        </transition>\n    </div>\n</template>\n\n<script>\nimport {\n    getValueByPath,\n    removeElement,\n    createAbsoluteElement,\n    isCustomElement,\n    toCssWidth\n} from '@/utils/helpers'\nimport FormElementMixin from '@/utils/FormElementMixin'\nimport Input from '@/components/input/Input'\n\nexport default {\n    name: 'BAutocomplete',\n    components: {\n        [Input.name]: Input\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: [Number, String],\n        data: {\n            type: Array,\n            default: () => []\n        },\n        field: {\n            type: String,\n            default: 'value'\n        },\n        keepFirst: Boolean,\n        clearOnSelect: Boolean,\n        openOnFocus: Boolean,\n        customFormatter: Function,\n        checkInfiniteScroll: Boolean,\n        keepOpen: Boolean,\n        selectOnClickOutside: Boolean,\n        clearable: Boolean,\n        maxHeight: [String, Number],\n        dropdownPosition: {\n            type: String,\n            default: 'auto'\n        },\n        groupField: String,\n        groupOptions: String,\n        iconRight: String,\n        iconRightClickable: Boolean,\n        appendToBody: Boolean,\n        type: {\n            type: String,\n            default: 'text'\n        },\n        confirmKeys: {\n            type: Array,\n            default: () => ['Tab', 'Enter']\n        },\n        selectableHeader: Boolean,\n        selectableFooter: Boolean\n    },\n    data() {\n        return {\n            selected: null,\n            hovered: null,\n            headerHovered: null,\n            footerHovered: null,\n            isActive: false,\n            newValue: this.value,\n            newAutocomplete: this.autocomplete || 'off',\n            ariaAutocomplete: this.keepFirst ? 'both' : 'list',\n            isListInViewportVertically: true,\n            hasFocus: false,\n            style: {},\n            _isAutocomplete: true,\n            _elementRef: 'input',\n            _bodyEl: undefined, // Used to append to body\n            timeOutID: null\n        }\n    },\n    computed: {\n        computedData() {\n            if (this.groupField) {\n                if (this.groupOptions) {\n                    const newData = []\n                    this.data.forEach((option) => {\n                        const group = getValueByPath(option, this.groupField)\n                        const items = getValueByPath(option, this.groupOptions)\n                        newData.push({ group, items })\n                    })\n                    return newData\n                } else {\n                    const tmp = {}\n                    this.data.forEach((option) => {\n                        const group = getValueByPath(option, this.groupField)\n                        if (!tmp[group]) tmp[group] = []\n                        tmp[group].push(option)\n                    })\n                    const newData = []\n                    Object.keys(tmp).forEach((group) => {\n                        newData.push({ group, items: tmp[group] })\n                    })\n                    return newData\n                }\n            }\n            return [{ items: this.data }]\n        },\n        isEmpty() {\n            if (!this.computedData) return true\n            return !this.computedData.some((element) => element.items && element.items.length)\n        },\n        /**\n         * White-listed items to not close when clicked.\n         * Add input, dropdown and all children.\n         */\n        whiteList() {\n            const whiteList = []\n            whiteList.push(this.$refs.input.$el.querySelector('input'))\n            whiteList.push(this.$refs.dropdown)\n            // Add all children from dropdown\n            if (this.$refs.dropdown !== undefined) {\n                const children = this.$refs.dropdown.querySelectorAll('*')\n                for (const child of children) {\n                    whiteList.push(child)\n                }\n            }\n            if (this.$parent.$data._isTaginput) {\n                // Add taginput container\n                whiteList.push(this.$parent.$el)\n                // Add .tag and .delete\n                const tagInputChildren = this.$parent.$el.querySelectorAll('*')\n                for (const tagInputChild of tagInputChildren) {\n                    whiteList.push(tagInputChild)\n                }\n            }\n\n            return whiteList\n        },\n\n        /**\n         * Check if exists default slot\n         */\n        hasDefaultSlot() {\n            return !!this.$scopedSlots.default\n        },\n\n        /**\n         * Check if exists group slot\n         */\n        hasGroupSlot() {\n            return !!this.$scopedSlots.group\n        },\n\n        /**\n         * Check if exists \"empty\" slot\n         */\n        hasEmptySlot() {\n            return !!this.$slots.empty\n        },\n\n        /**\n         * Check if exists \"header\" slot\n         */\n        hasHeaderSlot() {\n            return !!this.$slots.header\n        },\n\n        /**\n         * Check if exists \"footer\" slot\n         */\n        hasFooterSlot() {\n            return !!this.$slots.footer\n        },\n\n        /**\n         * Apply dropdownPosition property\n         */\n        isOpenedTop() {\n            return (\n                this.dropdownPosition === 'top' ||\n                    (this.dropdownPosition === 'auto' && !this.isListInViewportVertically)\n            )\n        },\n\n        newIconRight() {\n            if (this.clearable && this.newValue) {\n                return 'close-circle'\n            }\n            return this.iconRight\n        },\n\n        newIconRightClickable() {\n            if (this.clearable) {\n                return true\n            }\n            return this.iconRightClickable\n        },\n\n        contentStyle() {\n            return {\n                maxHeight: toCssWidth(this.maxHeight)\n            }\n        }\n    },\n    watch: {\n        /**\n         * When dropdown is toggled, check the visibility to know when\n         * to open upwards.\n         */\n        isActive(active) {\n            if (this.dropdownPosition === 'auto') {\n                if (active) {\n                    this.calcDropdownInViewportVertical()\n                } else {\n                    // Timeout to wait for the animation to finish before recalculating\n                    this.timeOutID = setTimeout(() => {\n                        this.calcDropdownInViewportVertical()\n                    }, 100)\n                }\n            }\n\n            this.$nextTick(() => {\n                this.$emit('active', active)\n            })\n        },\n\n        /**\n         * When checkInfiniteScroll property changes scroll event should be removed or added\n         */\n        checkInfiniteScroll(checkInfiniteScroll) {\n            if ((this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')) === false) return\n\n            const list = this.$refs.dropdown.querySelector('.dropdown-content')\n\n            if (checkInfiniteScroll === true) {\n                list.addEventListener('scroll', this.checkIfReachedTheEndOfScroll)\n\n                return\n            }\n\n            list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll)\n        },\n\n        /**\n         * When updating input's value\n         *   1. Emit changes\n         *   2. If value isn't the same as selected, set null\n         *   3. Close dropdown if value is clear or else open it\n         */\n        newValue(value) {\n            this.$emit('input', value)\n            // Check if selected is invalid\n            const currentValue = this.getValue(this.selected)\n            if (currentValue && currentValue !== value) {\n                this.setSelected(null, false)\n            }\n            // Close dropdown if input is clear or else open it\n            if (this.hasFocus && (!this.openOnFocus || value)) {\n                this.isActive = !!value\n            }\n        },\n\n        /**\n         * When v-model is changed:\n         *   1. Update internal value.\n         *   2. If it's invalid, validate again.\n         */\n        value(value) {\n            this.newValue = value\n        },\n\n        /**\n         * Select first option if \"keep-first\n         */\n        data() {\n            // Keep first option always pre-selected\n            if (this.keepFirst) {\n                this.$nextTick(() => {\n                    if (this.isActive) {\n                        this.selectFirstOption(this.computedData)\n                    } else {\n                        this.setHovered(null)\n                    }\n                })\n            } else {\n                if (this.hovered) {\n                    // reset hovered if list doesn't contain it\n                    const hoveredValue = this.getValue(this.hovered)\n                    const data = this.computedData.map((d) => d.items)\n                        .reduce((a, b) => ([...a, ...b]), [])\n                    if (!data.some((d) => this.getValue(d) === hoveredValue)) {\n                        this.setHovered(null)\n                    }\n                }\n            }\n        }\n    },\n    methods: {\n        /**\n         * Set which option is currently hovered.\n         */\n        setHovered(option) {\n            if (option === undefined) return\n\n            this.hovered = option\n        },\n\n        /**\n         * Set which option is currently selected, update v-model,\n         * update input value and close dropdown.\n         */\n        setSelected(option, closeDropdown = true, event = undefined) {\n            if (option === undefined) return\n            this.selected = option\n            this.$emit('select', this.selected, event)\n            if (this.selected !== null) {\n                if (this.clearOnSelect) {\n                    const input = this.$refs.input\n                    input.newValue = ''\n                    input.$refs.input.value = ''\n                } else {\n                    this.newValue = this.getValue(this.selected)\n                }\n                this.setHovered(null)\n            }\n            closeDropdown && this.$nextTick(() => {\n                this.isActive = false\n            })\n            this.checkValidity()\n        },\n\n        /**\n         * Select first option\n         */\n        selectFirstOption(computedData) {\n            this.$nextTick(() => {\n                const nonEmptyElements = computedData.filter(\n                    (element) => element.items && element.items.length\n                )\n                if (nonEmptyElements.length) {\n                    const option = nonEmptyElements[0].items[0]\n                    this.setHovered(option)\n                } else {\n                    this.setHovered(null)\n                }\n            })\n        },\n\n        keydown(event) {\n            const { key } = event // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)\n            // prevent emit submit event\n            if (key === 'Enter') event.preventDefault()\n            // Close dropdown on Tab & no hovered\n            if (key === 'Escape' || key === 'Tab') {\n                this.isActive = false\n            }\n\n            if (this.confirmKeys.indexOf(key) >= 0) {\n                // If adding by comma, don't add the comma to the input\n                if (key === ',') event.preventDefault()\n                // Close dropdown on select by Tab\n                const closeDropdown = !this.keepOpen || key === 'Tab'\n                if (this.hovered === null) {\n                    // header and footer uses headerHovered && footerHovered. If header or footer\n                    // was selected then fire event otherwise just return so a value isn't selected\n                    this.checkIfHeaderOrFooterSelected(event, null, closeDropdown)\n                    return\n                }\n                this.setSelected(this.hovered, closeDropdown, event)\n            }\n        },\n\n        selectHeaderOrFoterByClick(event, origin) {\n            this.checkIfHeaderOrFooterSelected(event, {origin: origin})\n        },\n\n        /**\n         * Check if header or footer was selected.\n         */\n        checkIfHeaderOrFooterSelected(event, triggerClick, closeDropdown = true) {\n            if (this.selectableHeader && (this.headerHovered || (triggerClick && triggerClick.origin === 'header'))) {\n                this.$emit('select-header', event)\n                this.headerHovered = false\n                if (triggerClick) this.setHovered(null)\n                if (closeDropdown) this.isActive = false\n            }\n            if (this.selectableFooter && (this.footerHovered || (triggerClick && triggerClick.origin === 'footer'))) {\n                this.$emit('select-footer', event)\n                this.footerHovered = false\n                if (triggerClick) this.setHovered(null)\n                if (closeDropdown) this.isActive = false\n            }\n        },\n\n        /**\n         * Close dropdown if clicked outside.\n         */\n        clickedOutside(event) {\n            const target = isCustomElement(this) ? event.composedPath()[0] : event.target\n            if (!this.hasFocus && this.whiteList.indexOf(target) < 0) {\n                if (this.keepFirst && this.hovered && this.selectOnClickOutside) {\n                    this.setSelected(this.hovered, true)\n                } else {\n                    this.isActive = false\n                }\n            }\n        },\n\n        /**\n         * Return display text for the input.\n         * If object, get value from path, or else just the value.\n         */\n        getValue(option) {\n            if (option === null) return\n\n            if (typeof this.customFormatter !== 'undefined') {\n                return this.customFormatter(option)\n            }\n            return typeof option === 'object' ? getValueByPath(option, this.field) : option\n        },\n\n        /**\n         * Check if the scroll list inside the dropdown\n         * reached it's end.\n         */\n        checkIfReachedTheEndOfScroll() {\n            const list = this.$refs.dropdown.querySelector('.dropdown-content')\n            const footerHeight = this.hasFooterSlot ? list.querySelectorAll('div.dropdown-footer')[0].clientHeight : 0\n            if (list.clientHeight !== list.scrollHeight &&\n                list.scrollTop + list.parentElement.clientHeight + footerHeight >= list.scrollHeight\n            ) {\n                this.$emit('infinite-scroll')\n            }\n        },\n\n        /**\n         * Calculate if the dropdown is vertically visible when activated,\n         * otherwise it is openened upwards.\n         */\n        calcDropdownInViewportVertical() {\n            this.$nextTick(() => {\n                /**\n                 * this.$refs.dropdown may be undefined\n                 * when Autocomplete is conditional rendered\n                 */\n                if (this.$refs.dropdown === undefined) return\n\n                const rect = this.$refs.dropdown.getBoundingClientRect()\n\n                this.isListInViewportVertically = rect.top >= 0 &&\n                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)\n                if (this.appendToBody) {\n                    this.updateAppendToBody()\n                }\n            })\n        },\n\n        /**\n         * Arrows keys listener.\n         * If dropdown is active, set hovered option, or else just open.\n         */\n        keyArrows(direction) {\n            const sum = direction === 'down' ? 1 : -1\n            if (this.isActive) {\n                const data = this.computedData.map(\n                    (d) => d.items).reduce((a, b) => ([...a, ...b]), [])\n                if (this.hasHeaderSlot && this.selectableHeader) {\n                    data.unshift(undefined)\n                }\n                if (this.hasFooterSlot && this.selectableFooter) {\n                    data.push(undefined)\n                }\n\n                let index\n                if (this.headerHovered) {\n                    index = 0 + sum\n                } else if (this.footerHovered) {\n                    index = (data.length - 1) + sum\n                } else {\n                    index = data.indexOf(this.hovered) + sum\n                }\n\n                index = index > data.length - 1 ? data.length - 1 : index\n                index = index < 0 ? 0 : index\n\n                this.footerHovered = false\n                this.headerHovered = false\n                this.setHovered(data[index] !== undefined ? data[index] : null)\n                if (this.hasFooterSlot && this.selectableFooter && index === data.length - 1) {\n                    this.footerHovered = true\n                }\n                if (this.hasHeaderSlot && this.selectableHeader && index === 0) {\n                    this.headerHovered = true\n                }\n\n                const list = this.$refs.dropdown.querySelector('.dropdown-content')\n                let querySelectorText = 'a.dropdown-item:not(.is-disabled)'\n                if (this.hasHeaderSlot && this.selectableHeader) {\n                    querySelectorText += ',div.dropdown-header'\n                }\n                if (this.hasFooterSlot && this.selectableFooter) {\n                    querySelectorText += ',div.dropdown-footer'\n                }\n                const element = list.querySelectorAll(querySelectorText)[index]\n\n                if (!element) return\n\n                const visMin = list.scrollTop\n                const visMax = list.scrollTop + list.clientHeight - element.clientHeight\n\n                if (element.offsetTop < visMin) {\n                    list.scrollTop = element.offsetTop\n                } else if (element.offsetTop >= visMax) {\n                    list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight\n                }\n            } else {\n                this.isActive = true\n            }\n        },\n\n        /**\n         * Focus listener.\n         * If value is the same as selected, select all text.\n         */\n        focused(event) {\n            if (this.getValue(this.selected) === this.newValue) {\n                this.$el.querySelector('input').select()\n            }\n            if (this.openOnFocus) {\n                this.isActive = true\n                if (this.keepFirst) {\n                    // If open on focus, update the hovered\n                    this.selectFirstOption(this.computedData)\n                }\n            }\n            this.hasFocus = true\n            this.$emit('focus', event)\n        },\n\n        /**\n         * Blur listener.\n         */\n        onBlur(event) {\n            this.hasFocus = false\n            this.$emit('blur', event)\n        },\n        onInput() {\n            const currentValue = this.getValue(this.selected)\n            if (currentValue && currentValue === this.newValue) return\n            this.$emit('typing', this.newValue)\n            this.checkValidity()\n        },\n        rightIconClick(event) {\n            if (this.clearable) {\n                this.newValue = ''\n                this.setSelected(null, false)\n                if (this.openOnFocus) {\n                    this.$refs.input.$el.focus()\n                }\n            } else {\n                this.$emit('icon-right-click', event)\n            }\n        },\n        checkValidity() {\n            if (this.useHtml5Validation) {\n                this.$nextTick(() => {\n                    this.checkHtml5Validity()\n                })\n            }\n        },\n        updateAppendToBody() {\n            const dropdownMenu = this.$refs.dropdown\n            const trigger = this.$parent.$data._isTaginput ? this.$parent.$el : this.$refs.input.$el\n            if (dropdownMenu && trigger) {\n                // update wrapper dropdown\n                const root = this.$data._bodyEl\n                root.classList.forEach((item) => root.classList.remove(item))\n                root.classList.add('autocomplete')\n                root.classList.add('control')\n                if (this.expandend) {\n                    root.classList.add('is-expandend')\n                }\n                const rect = trigger.getBoundingClientRect()\n                let top = rect.top + window.scrollY\n                let left = rect.left + window.scrollX\n                if (!this.isOpenedTop) {\n                    top += trigger.clientHeight\n                } else {\n                    top -= dropdownMenu.clientHeight\n                }\n                this.style = {\n                    position: 'absolute',\n                    top: `${top}px`,\n                    left: `${left}px`,\n                    width: `${trigger.clientWidth}px`,\n                    maxWidth: `${trigger.clientWidth}px`,\n                    zIndex: '99'\n                }\n            }\n        }\n    },\n    created() {\n        if (typeof window !== 'undefined') {\n            document.addEventListener('click', this.clickedOutside)\n            if (this.dropdownPosition === 'auto') { window.addEventListener('resize', this.calcDropdownInViewportVertical) }\n        }\n    },\n    mounted() {\n        if (this.checkInfiniteScroll &&\n            this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')\n        ) {\n            const list = this.$refs.dropdown.querySelector('.dropdown-content')\n            list.addEventListener('scroll', this.checkIfReachedTheEndOfScroll)\n        }\n        if (this.appendToBody) {\n            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdown)\n            this.updateAppendToBody()\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            document.removeEventListener('click', this.clickedOutside)\n            if (this.dropdownPosition === 'auto') { window.removeEventListener('resize', this.calcDropdownInViewportVertical) }\n        }\n        if (this.checkInfiniteScroll &&\n            this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')\n        ) {\n            const list = this.$refs.dropdown.querySelector('.dropdown-content')\n            list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll)\n        }\n        if (this.appendToBody) {\n            removeElement(this.$data._bodyEl)\n        }\n        clearTimeout(this.timeOutID)\n    }\n}\n</script>\n",
      "path": "src/components/autocomplete/Autocomplete.vue"
    },
    {
      "type": "registry:component",
      "target": "components/autocomplete/index.js",
      "content": "import Autocomplete from '@/components/autocomplete/Autocomplete'\n\nimport { use, registerComponent } from '@/utils/plugins'\n\nconst Plugin = {\n    install(Vue) {\n        registerComponent(Vue, Autocomplete)\n    }\n}\n\nuse(Plugin)\n\nexport default Plugin\n\nexport {\n    Autocomplete as BAutocomplete\n}\n",
      "path": "src/components/autocomplete/index.js"
    },
    {
      "type": "registry:component",
      "target": "components/icon/Icon.vue",
      "content": "<template>\n    <span class=\"icon\" :class=\"[newType, size]\">\n        <i\n            v-if=\"!useIconComponent\"\n            :class=\"[newPack, newIcon, newCustomSize, customClass]\"/>\n\n        <component\n            v-else\n            :is=\"useIconComponent\"\n            :icon=\"[newPack, newIcon]\"\n            :size=\"newCustomSize\"\n            :class=\"[customClass]\"/>\n    </span>\n</template>\n\n<script>\nimport config from '@/utils/config'\nimport getIcons from '@/utils/icons'\n\nexport default {\n    name: 'BIcon',\n    props: {\n        type: [String, Object],\n        component: String,\n        pack: String,\n        icon: String,\n        size: String,\n        customSize: String,\n        customClass: String,\n        both: Boolean // This is used internally to show both MDI and FA icon\n    },\n    computed: {\n        iconConfig() {\n            let allIcons = getIcons()\n            return allIcons[this.newPack]\n        },\n        iconPrefix() {\n            if (this.iconConfig && this.iconConfig.iconPrefix) {\n                return this.iconConfig.iconPrefix\n            }\n            return ''\n        },\n        /**\n        * Internal icon name based on the pack.\n        * If pack is 'fa', gets the equivalent FA icon name of the MDI,\n        * internal icons are always MDI.\n        */\n        newIcon() {\n            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`\n        },\n        newPack() {\n            return this.pack || config.defaultIconPack\n        },\n        newType() {\n            if (!this.type) return\n\n            let splitType = []\n            if (typeof this.type === 'string') {\n                splitType = this.type.split('-')\n            } else {\n                for (let key in this.type) {\n                    if (this.type[key]) {\n                        splitType = key.split('-')\n                        break\n                    }\n                }\n            }\n            if (splitType.length <= 1) return\n\n            const [, ...type] = splitType\n            return `has-text-${type.join('-')}`\n        },\n        newCustomSize() {\n            return this.customSize || this.customSizeByPack\n        },\n        customSizeByPack() {\n            if (this.iconConfig && this.iconConfig.sizes) {\n                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {\n                    return this.iconConfig.sizes[this.size]\n                } else if (this.iconConfig.sizes.default) {\n                    return this.iconConfig.sizes.default\n                }\n            }\n            return null\n        },\n        useIconComponent() {\n            return this.component || config.defaultIconComponent\n        }\n    },\n    methods: {\n        /**\n        * Equivalent icon name of the MDI.\n        */\n        getEquivalentIconOf(value) {\n            // Only transform the class if the both prop is set to true\n            if (!this.both) {\n                return value\n            }\n\n            if (this.iconConfig &&\n                this.iconConfig.internalIcons &&\n                this.iconConfig.internalIcons[value]) {\n                return this.iconConfig.internalIcons[value]\n            }\n            return value\n        }\n    }\n}\n</script>\n",
      "path": "src/components/icon/Icon.vue"
    },
    {
      "type": "registry:component",
      "target": "components/input/Input.vue",
      "content": "<template>\n    <div\n        class=\"control\"\n        :class=\"rootClasses\"\n    >\n        <input\n            v-if=\"type !== 'textarea'\"\n            ref=\"input\"\n            class=\"input\"\n            :class=\"[inputClasses, customClass]\"\n            :type=\"newType\"\n            :autocomplete=\"newAutocomplete\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\">\n\n        <textarea\n            v-else\n            ref=\"textarea\"\n            class=\"textarea\"\n            :class=\"[inputClasses, customClass]\"\n            :maxlength=\"maxlength\"\n            :value=\"computedValue\"\n            v-bind=\"$attrs\"\n            @input=\"onInput\"\n            @change=\"onChange\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\"/>\n\n        <b-icon\n            v-if=\"icon\"\n            class=\"is-left\"\n            :class=\"{'is-clickable': iconClickable}\"\n            :icon=\"icon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            @click.native=\"iconClick('icon-click', $event)\"/>\n\n        <b-icon\n            v-if=\"!loading && hasIconRight\"\n            class=\"is-right\"\n            :class=\"{ 'is-clickable': passwordReveal || iconRightClickable }\"\n            :icon=\"rightIcon\"\n            :pack=\"iconPack\"\n            :size=\"iconSize\"\n            :type=\"rightIconType\"\n            both\n            @click.native=\"rightIconClick\"/>\n\n        <small\n            v-if=\"maxlength && hasCounter && type !== 'number'\"\n            class=\"help counter\"\n            :class=\"{ 'is-invisible': !isFocused }\">\n            {{ valueLength }} / {{ maxlength }}\n        </small>\n    </div>\n</template>\n\n<script>\nimport Icon from '@/components/icon/Icon'\nimport config from '@/utils/config'\nimport FormElementMixin from '@/utils/FormElementMixin'\n\nexport default {\n    name: 'BInput',\n    components: {\n        [Icon.name]: Icon\n    },\n    mixins: [FormElementMixin],\n    inheritAttrs: false,\n    props: {\n        value: [Number, String],\n        type: {\n            type: String,\n            default: 'text'\n        },\n        lazy: {\n            type: Boolean,\n            default: false\n        },\n        passwordReveal: Boolean,\n        iconClickable: Boolean,\n        hasCounter: {\n            type: Boolean,\n            default: () => config.defaultInputHasCounter\n        },\n        customClass: {\n            type: String,\n            default: ''\n        },\n        iconRight: String,\n        iconRightClickable: Boolean,\n        iconRightType: String\n    },\n    data() {\n        return {\n            newValue: this.value,\n            newType: this.type,\n            newAutocomplete: this.autocomplete || config.defaultInputAutocomplete,\n            isPasswordVisible: false,\n            _elementRef: this.type === 'textarea'\n                ? 'textarea'\n                : 'input'\n        }\n    },\n    computed: {\n        computedValue: {\n            get() {\n                return this.newValue\n            },\n            set(value) {\n                this.newValue = value\n                this.$emit('input', value)\n            }\n        },\n        rootClasses() {\n            return [\n                this.iconPosition,\n                this.size,\n                {\n                    'is-expanded': this.expanded,\n                    'is-loading': this.loading,\n                    'is-clearfix': !this.hasMessage\n                }\n            ]\n        },\n        inputClasses() {\n            return [\n                this.statusType,\n                this.size,\n                { 'is-rounded': this.rounded }\n            ]\n        },\n        hasIconRight() {\n            return this.passwordReveal ||\n                this.loading || (this.statusIcon && this.statusTypeIcon) || this.iconRight\n        },\n        rightIcon() {\n            if (this.passwordReveal) {\n                return this.passwordVisibleIcon\n            } else if (this.iconRight) {\n                return this.iconRight\n            }\n            return this.statusTypeIcon\n        },\n        rightIconType() {\n            if (this.passwordReveal) {\n                return 'is-primary'\n            } else if (this.iconRight) {\n                return this.iconRightType || null\n            }\n            return this.statusType\n        },\n\n        /**\n        * Position of the icon or if it's both sides.\n        */\n        iconPosition() {\n            let iconClasses = ''\n\n            if (this.icon) {\n                iconClasses += 'has-icons-left '\n            }\n\n            if (this.hasIconRight) {\n                iconClasses += 'has-icons-right'\n            }\n\n            return iconClasses\n        },\n\n        /**\n        * Icon name (MDI) based on the type.\n        */\n        statusTypeIcon() {\n            switch (this.statusType) {\n                case 'is-success': return 'check'\n                case 'is-danger': return 'alert-circle'\n                case 'is-info': return 'information'\n                case 'is-warning': return 'alert'\n            }\n        },\n\n        /**\n        * Check if have any message prop from parent if it's a Field.\n        */\n        hasMessage() {\n            return !!this.statusMessage\n        },\n\n        /**\n        * Current password-reveal icon name.\n        */\n        passwordVisibleIcon() {\n            return !this.isPasswordVisible ? 'eye' : 'eye-off'\n        },\n        /**\n        * Get value length\n        */\n        valueLength() {\n            if (typeof this.computedValue === 'string') {\n                return Array.from(this.computedValue).length\n            } else if (typeof this.computedValue === 'number') {\n                return this.computedValue.toString().length\n            }\n            return 0\n        }\n    },\n    watch: {\n        /**\n        * When v-model is changed:\n        *   1. Set internal value.\n        *   2. Validate it if the value came from outside;\n        *      i.e., not equal to computedValue\n        */\n        value(value) {\n            const fromOutside = this.computedValue != value // eslint-disable-line eqeqeq\n            this.newValue = value\n            if (fromOutside) {\n                // validation must wait for DOM updated\n                this.$nextTick(() => {\n                    !this.isValid && this.checkHtml5Validity()\n                })\n            }\n        },\n        type(type) {\n            this.newType = type\n        }\n    },\n    methods: {\n        /**\n        * Toggle the visibility of a password-reveal input\n        * by changing the type and focus the input right away.\n        */\n        togglePasswordVisibility() {\n            this.isPasswordVisible = !this.isPasswordVisible\n            this.newType = this.isPasswordVisible ? 'text' : 'password'\n\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        iconClick(emit, event) {\n            this.$emit(emit, event)\n            this.$nextTick(() => {\n                this.focus()\n            })\n        },\n\n        rightIconClick(event) {\n            if (this.passwordReveal) {\n                this.togglePasswordVisibility()\n            } else if (this.iconRightClickable) {\n                this.iconClick('icon-right-click', event)\n            }\n        },\n\n        onInput(event) {\n            if (!this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        onChange(event) {\n            if (this.lazy) {\n                const value = event.target.value\n                this.updateValue(value)\n            }\n        },\n\n        updateValue(value) {\n            this.computedValue = value\n            !this.isValid && this.checkHtml5Validity()\n        }\n    }\n}\n</script>\n",
      "path": "src/components/input/Input.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/config.js",
      "content": "let config = {\n    defaultContainerElement: null,\n    defaultIconPack: 'mdi',\n    defaultIconComponent: null,\n    defaultIconPrev: 'chevron-left',\n    defaultIconNext: 'chevron-right',\n    defaultLocale: undefined,\n    defaultDialogConfirmText: null,\n    defaultDialogCancelText: null,\n    defaultSnackbarDuration: 3500,\n    defaultSnackbarPosition: null,\n    defaultToastDuration: 2000,\n    defaultToastPosition: null,\n    defaultNotificationDuration: 2000,\n    defaultNotificationPosition: null,\n    defaultTooltipType: 'is-primary',\n    defaultTooltipDelay: null,\n    defaultTooltipCloseDelay: null,\n    defaultSidebarDelay: null,\n    defaultInputAutocomplete: 'on',\n    defaultDateFormatter: null,\n    defaultDateParser: null,\n    defaultDateCreator: null,\n    defaultTimeCreator: null,\n    defaultDayNames: null,\n    defaultMonthNames: null,\n    defaultFirstDayOfWeek: null,\n    defaultUnselectableDaysOfWeek: null,\n    defaultTimeFormatter: null,\n    defaultTimeParser: null,\n    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],\n    defaultModalScroll: null,\n    defaultDatepickerMobileNative: true,\n    defaultTimepickerMobileNative: true,\n    defaultTimepickerMobileModal: true,\n    defaultNoticeQueue: true,\n    defaultInputHasCounter: true,\n    defaultTaginputHasCounter: true,\n    defaultUseHtml5Validation: true,\n    defaultDropdownMobileModal: true,\n    defaultFieldLabelPosition: null,\n    defaultDatepickerYearsRange: [-100, 10],\n    defaultDatepickerNearbyMonthDays: true,\n    defaultDatepickerNearbySelectableMonthDays: false,\n    defaultDatepickerShowWeekNumber: false,\n    defaultDatepickerWeekNumberClickable: false,\n    defaultDatepickerMobileModal: true,\n    defaultTrapFocus: true,\n    defaultAutoFocus: true,\n    defaultButtonRounded: false,\n    defaultSwitchRounded: true,\n    defaultCarouselInterval: 3500,\n    defaultTabsExpanded: false,\n    defaultTabsAnimated: true,\n    defaultTabsType: null,\n    defaultStatusIcon: true,\n    defaultProgrammaticPromise: false,\n    defaultLinkTags: [\n        'a',\n        'button',\n        'input',\n        'router-link',\n        'nuxt-link',\n        'n-link',\n        'RouterLink',\n        'NuxtLink',\n        'NLink'\n    ],\n    defaultImageWebpFallback: null,\n    defaultImageLazy: true,\n    defaultImageResponsive: true,\n    defaultImageRatio: null,\n    defaultImageSrcsetFormatter: null,\n    defaultBreadcrumbTag: 'a',\n    defaultBreadcrumbAlign: 'is-left',\n    defaultBreadcrumbSeparator: '',\n    defaultBreadcrumbSize: 'is-medium',\n    customIconPacks: null\n}\n\nexport { config as default }\n\nexport const setOptions = (options) => { config = options }\n\nexport const setVueInstance = (Vue) => { VueInstance = Vue }\n\nexport let VueInstance\n",
      "path": "src/utils/config.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/FormElementMixin.js",
      "content": "import config from '@/utils/config'\nimport { isVueComponent } from '@/utils/helpers'\n\nexport default {\n    props: {\n        size: String,\n        expanded: Boolean,\n        loading: Boolean,\n        rounded: Boolean,\n        icon: String,\n        iconPack: String,\n        // Native options to use in HTML5 validation\n        autocomplete: String,\n        maxlength: [Number, String],\n        useHtml5Validation: {\n            type: Boolean,\n            default: () => config.defaultUseHtml5Validation\n        },\n        validationMessage: String,\n        locale: {\n            type: [String, Array],\n            default: () => {\n                return config.defaultLocale\n            }\n        },\n        statusIcon: {\n            type: Boolean,\n            default: () => {\n                return config.defaultStatusIcon\n            }\n        }\n    },\n    data() {\n        return {\n            isValid: true,\n            isFocused: false,\n            newIconPack: this.iconPack || config.defaultIconPack\n        }\n    },\n    computed: {\n        /**\n         * Find parent Field, max 3 levels deep.\n         */\n        parentField() {\n            let parent = this.$parent\n            for (let i = 0; i < 3; i++) {\n                if (parent && !parent.$data._isField) {\n                    parent = parent.$parent\n                }\n            }\n            return parent\n        },\n\n        /**\n         * Get the type prop from parent if it's a Field.\n         */\n        statusType() {\n            const { newType } = this.parentField || {}\n\n            if (!newType) return\n\n            if (typeof newType === 'string') {\n                return newType\n            } else {\n                for (const key in newType) {\n                    if (newType[key]) {\n                        return key\n                    }\n                }\n            }\n        },\n\n        /**\n         * Get the message prop from parent if it's a Field.\n         */\n        statusMessage() {\n            if (!this.parentField) return\n\n            return this.parentField.newMessage || this.parentField.$slots.message\n        },\n\n        /**\n         * Fix icon size for inputs, large was too big\n         */\n        iconSize() {\n            switch (this.size) {\n                case 'is-small': return this.size\n                case 'is-medium': return\n                case 'is-large': return this.newIconPack === 'mdi'\n                    ? 'is-medium'\n                    : ''\n            }\n        }\n    },\n    methods: {\n        /**\n         * Focus method that work dynamically depending on the component.\n         */\n        focus() {\n            const el = this.getElement()\n            if (el === undefined) return\n\n            this.$nextTick(() => {\n                if (el) el.focus()\n            })\n        },\n\n        onBlur($event) {\n            this.isFocused = false\n            this.$emit('blur', $event)\n            this.checkHtml5Validity()\n        },\n\n        onFocus($event) {\n            this.isFocused = true\n            this.$emit('focus', $event)\n        },\n\n        getElement() {\n            let el = this.$refs[this.$data._elementRef]\n            while (isVueComponent(el)) {\n                el = el.$refs[el.$data._elementRef]\n            }\n            return el\n        },\n\n        setInvalid() {\n            let type = 'is-danger'\n            let message = this.validationMessage || this.getElement().validationMessage\n            this.setValidity(type, message)\n        },\n\n        setValidity(type, message) {\n            this.$nextTick(() => {\n                if (this.parentField) {\n                    // Set type only if not defined\n                    if (!this.parentField.type) {\n                        this.parentField.newType = type\n                    }\n                    // Set message only if not defined\n                    if (!this.parentField.message) {\n                        this.parentField.newMessage = message\n                    }\n                }\n            })\n        },\n\n        /**\n         * Check HTML5 validation, set isValid property.\n         * If validation fail, send 'is-danger' type,\n         * and error message to parent if it's a Field.\n         */\n        checkHtml5Validity() {\n            if (!this.useHtml5Validation) return\n\n            const el = this.getElement()\n            if (el === undefined) return\n\n            if (!el.checkValidity()) {\n                this.setInvalid()\n                this.isValid = false\n            } else {\n                this.setValidity(null, null)\n                this.isValid = true\n            }\n\n            return this.isValid\n        }\n    }\n}\n",
      "path": "src/utils/FormElementMixin.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/helpers.js",
      "content": "/**\n * +/- function to native math sign\n */\nfunction signPoly(value) {\n    if (value < 0) return -1\n    return value > 0 ? 1 : 0\n}\nexport const sign = Math.sign || signPoly\n\n/**\n * Checks if the flag is set\n * @param val\n * @param flag\n * @returns {boolean}\n */\nfunction hasFlag(val, flag) {\n    return (val & flag) === flag\n}\n\n/**\n * Native modulo bug with negative numbers\n * @param n\n * @param mod\n * @returns {number}\n */\nfunction mod(n, mod) {\n    return ((n % mod) + mod) % mod\n}\n\n/**\n * Asserts a value is beetween min and max\n * @param val\n * @param min\n * @param max\n * @returns {number}\n */\nfunction bound(val, min, max) {\n    return Math.max(min, Math.min(max, val))\n}\n\nexport {mod, bound, hasFlag}\n\n/**\n * Get value of an object property/path even if it's nested\n */\nexport function getValueByPath(obj, path) {\n    return path.split('.').reduce((o, i) => o ? o[i] : null, obj)\n}\n\n/**\n * Extension of indexOf method by equality function if specified\n */\nexport function indexOf(array, obj, fn) {\n    if (!array) return -1\n\n    if (!fn || typeof fn !== 'function') return array.indexOf(obj)\n\n    for (let i = 0; i < array.length; i++) {\n        if (fn(array[i], obj)) {\n            return i\n        }\n    }\n\n    return -1\n}\n\n/**\n * Merge function to replace Object.assign with deep merging possibility\n */\nconst isObject = (item) => typeof item === 'object' && !Array.isArray(item)\nconst mergeFn = (target, source, deep = false) => {\n    if (deep || !Object.assign) {\n        const isDeep = (prop) =>\n            isObject(source[prop]) &&\n            target !== null &&\n            target.hasOwnProperty(prop) &&\n            isObject(target[prop])\n        const replaced = Object.getOwnPropertyNames(source)\n            .map((prop) => ({ [prop]: isDeep(prop)\n                ? mergeFn(target[prop], source[prop], deep)\n                : source[prop] }))\n            .reduce((a, b) => ({ ...a, ...b }), {})\n\n        return {\n            ...target,\n            ...replaced\n        }\n    } else {\n        return Object.assign(target, source)\n    }\n}\nexport const merge = mergeFn\n\n/**\n * Mobile detection\n * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript\n */\nexport const isMobile = {\n    Android: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Android/i)\n        )\n    },\n    BlackBerry: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/BlackBerry/i)\n        )\n    },\n    iOS: function () {\n        return (\n            typeof window !== 'undefined' &&\n            (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) ||\n                (window.navigator.platform === 'MacIntel' &&\n                    window.navigator.maxTouchPoints > 1))\n        )\n    },\n    Opera: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/Opera Mini/i)\n        )\n    },\n    Windows: function () {\n        return (\n            typeof window !== 'undefined' &&\n            window.navigator.userAgent.match(/IEMobile/i)\n        )\n    },\n    any: function () {\n        return (\n            isMobile.Android() ||\n            isMobile.BlackBerry() ||\n            isMobile.iOS() ||\n            isMobile.Opera() ||\n            isMobile.Windows()\n        )\n    }\n}\n\nexport function removeElement(el) {\n    if (typeof el.remove !== 'undefined') {\n        el.remove()\n    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {\n        el.parentNode.removeChild(el)\n    }\n}\n\nexport function createAbsoluteElement(el) {\n    const root = document.createElement('div')\n    root.style.position = 'absolute'\n    root.style.left = '0px'\n    root.style.top = '0px'\n    root.style.width = '100%'\n    const wrapper = document.createElement('div')\n    root.appendChild(wrapper)\n    wrapper.appendChild(el)\n    document.body.appendChild(root)\n    return root\n}\n\nexport function isVueComponent(c) {\n    return c && c._isVue\n}\n\n/**\n * Escape regex characters\n * http://stackoverflow.com/a/6969486\n */\nexport function escapeRegExpChars(value) {\n    if (!value) return value\n\n    // eslint-disable-next-line\n    return value.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n/**\n * Remove accents/diacritics in a string in JavaScript\n * https://stackoverflow.com/a/37511463\n */\nexport function removeDiacriticsFromString(value) {\n    if (!value) return value\n\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n}\n\nexport function multiColumnSort(inputArray, sortingPriority) {\n    // NOTE: this function is intended to be used by BTable\n    // clone it to prevent the any watchers from triggering every sorting iteration\n    let array = JSON.parse(JSON.stringify(inputArray))\n    const fieldSorter = (fields) => (a, b) => fields.map((o) => {\n        const { field, order, customSort } = o\n        if (typeof customSort === 'function') {\n            return customSort(a, b, order !== 'desc')\n        } else {\n            const aValue = getValueByPath(a, field)\n            const bValue = getValueByPath(b, field)\n            const ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0\n            return order === 'desc' ? -ord : ord\n        }\n    }).reduce((p, n) => p || n, 0)\n\n    return array.sort(fieldSorter(sortingPriority))\n}\n\nexport function createNewEvent(eventName) {\n    var event\n    if (typeof Event === 'function') {\n        event = new Event(eventName)\n    } else {\n        event = document.createEvent('Event')\n        event.initEvent(eventName, true, true)\n    }\n    return event\n}\n\nexport function toCssWidth(width) {\n    return width === undefined ? null : (isNaN(width) ? width : width + 'px')\n}\n\n/**\n * Return month names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)\n * @return {Array<String>} An array of month names\n */\nexport function getMonthNames(locale = undefined, format = 'long') {\n    const dates = []\n    for (let i = 0; i < 12; i++) {\n        dates.push(new Date(2000, i, 15))\n    }\n    const dtf = new Intl.DateTimeFormat(locale, {\n        month: format\n    })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Return weekday names according to a specified locale\n * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale\n * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)\n * @return {Array<String>} An array of weekday names\n */\nexport function getWeekdayNames(locale = undefined, format = 'narrow') {\n    const dates = []\n    for (let i = 0; i < 7; i++) {\n        const dt = new Date(2000, 0, i + 1)\n        dates[dt.getDay()] = dt\n    }\n    const dtf = new Intl.DateTimeFormat(locale, { weekday: format })\n    return dates.map((d) => dtf.format(d))\n}\n\n/**\n * Accept a regex with group names and return an object\n * ex. matchWithGroups(/((?!=<year>)\\d+)\\/((?!=<month>)\\d+)\\/((?!=<day>)\\d+)/, '2000/12/25')\n * will return { year: 2000, month: 12, day: 25 }\n * @param  {String} includes injections of (?!={groupname}) for each group\n * @param  {String} the string to run regex\n * @return {Object} an object with a property for each group having the group's match as the value\n */\nexport function matchWithGroups(pattern, str) {\n    const matches = str.match(pattern)\n    return pattern\n        // get the pattern as a string\n        .toString()\n        // suss out the groups\n        .match(/<(.+?)>/g)\n        // remove the braces\n        .map((group) => {\n            const groupMatches = group.match(/<(.+)>/)\n            if (!groupMatches || groupMatches.length <= 0) {\n                return null\n            }\n            return group.match(/<(.+)>/)[1]\n        })\n        // create an object with a property for each group having the group's match as the value\n        .reduce((acc, curr, index, arr) => {\n            if (matches && matches.length > index) {\n                acc[curr] = matches[index + 1]\n            } else {\n                acc[curr] = null\n            }\n            return acc\n        }, {})\n}\n\n/**\n * Based on\n * https://github.com/fregante/supports-webp\n */\nexport function isWebpSupported() {\n    return new Promise((resolve) => {\n        const image = new Image()\n        image.onerror = () => resolve(false)\n        image.onload = () => resolve(image.width === 1)\n        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='\n    }).catch(() => false)\n}\n\nexport function isCustomElement(vm) {\n    return 'shadowRoot' in vm.$root.$options\n}\n\nexport const isDefined = (d) => d !== undefined\n\n/**\n * Checks if a value is null or undefined.\n * Based on\n * https://github.com/lodash/lodash/blob/master/isNil.js\n */\nexport const isNil = (value) => value === null || value === undefined\n\n/**\n * Translates a touch event as a drag event.\n *\n * `event` must be a touch event.\n *\n * `options` must be an object with the following properties:\n * - `type`: new event type (required). must be one of the following:\n *     - `\"dragstart\"`\n *     - `\"dragend\"`\n *     - `\"drop\"`\n *     - `\"dragover\"`\n *     - `\"dragleave\"`\n * - `target`: new target element (optional). `clientX` and `clientY` will be\n *   translated if `target` is different from `event.target`.\n *\n * This function only works with single-touch events for now.\n */\nexport const translateTouchAsDragEvent = (event, options) => {\n    const { type, target } = options\n    let translateX = 0\n    let translateY = 0\n    if (target != null && target !== event.target) {\n        const baseRect = event.target.getBoundingClientRect()\n        const targetRect = target.getBoundingClientRect()\n        translateX = targetRect.left - baseRect.left\n        translateY = targetRect.top - baseRect.top\n    }\n    const touch = event.touches[0] || event.changedTouches[0]\n    return new DragEvent(type, {\n        dataTransfer: new DataTransfer(),\n        bubbles: true,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        clientX: touch.clientX + translateX,\n        clientY: touch.clientY + translateY,\n        ctrlKey: event.ctrlKey,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        metaKey: event.metaKey\n    })\n}\n",
      "path": "src/utils/helpers.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/icons.js",
      "content": "import config from '@/utils/config'\nimport { merge } from '@/utils/helpers'\n\nconst mdiIcons = {\n    sizes: {\n        'default': 'mdi-24px',\n        'is-small': null,\n        'is-medium': 'mdi-36px',\n        'is-large': 'mdi-48px'\n    },\n    iconPrefix: 'mdi-'\n}\n\nconst faIcons = () => {\n    const faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-'\n    return {\n        sizes: {\n            'default': null,\n            'is-small': null,\n            'is-medium': faIconPrefix + 'lg',\n            'is-large': faIconPrefix + '2x'\n        },\n        iconPrefix: faIconPrefix,\n        internalIcons: {\n            'information': 'info-circle',\n            'alert': 'exclamation-triangle',\n            'alert-circle': 'exclamation-circle',\n            'chevron-right': 'angle-right',\n            'chevron-left': 'angle-left',\n            'chevron-down': 'angle-down',\n            'eye-off': 'eye-slash',\n            'menu-down': 'caret-down',\n            'menu-up': 'caret-up',\n            'close-circle': 'times-circle'\n        }\n    }\n}\n\nconst getIcons = () => {\n    let icons = {\n        mdi: mdiIcons,\n        fa: faIcons(),\n        fas: faIcons(),\n        far: faIcons(),\n        fad: faIcons(),\n        fab: faIcons(),\n        fal: faIcons(),\n        'fa-solid': faIcons(),\n        'fa-regular': faIcons(),\n        'fa-light': faIcons(),\n        'fa-thin': faIcons(),\n        'fa-duotone': faIcons(),\n        'fa-brands': faIcons()\n    }\n\n    if (config && config.customIconPacks) {\n        icons = merge(icons, config.customIconPacks, true)\n    }\n\n    return icons\n}\n\nexport default getIcons\n",
      "path": "src/utils/icons.js"
    },
    {
      "type": "registry:lib",
      "target": "utils/plugins.js",
      "content": "\nexport const use = (plugin) => {\n    if (typeof window !== 'undefined' && window.Vue) {\n        window.Vue.use(plugin)\n    }\n}\n\nexport const registerComponent = (Vue, component) => {\n    Vue.component(component.name, component)\n}\n\nexport const registerComponentProgrammatic = (Vue, property, component) => {\n    if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {}\n    Vue.prototype.$buefy[property] = component\n}\n",
      "path": "src/utils/plugins.js"
    }
  ]
}
