{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "navbar/index",
  "type": "registry:component",
  "files": [
    {
      "type": "registry:file",
      "target": "directives/clickOutside.js",
      "content": "const isTouch =\n  typeof window !== 'undefined' && ('ontouchstart' in window || navigator.msMaxTouchPoints > 0)\nconst events = isTouch ? ['touchstart', 'click'] : ['click']\n\nconst instances = []\n\nfunction processArgs(bindingValue) {\n    const isFunction = typeof bindingValue === 'function'\n    if (!isFunction && typeof bindingValue !== 'object') {\n        throw new Error(`v-click-outside: Binding value should be a function or an object, ${typeof bindingValue} given`)\n    }\n\n    return {\n        handler: isFunction ? bindingValue : bindingValue.handler,\n        middleware: bindingValue.middleware || ((isClickOutside) => isClickOutside),\n        events: bindingValue.events || events\n    }\n}\n\nfunction onEvent({ el, event, handler, middleware }) {\n    const isClickOutside = event.target !== el && !el.contains(event.target)\n\n    if (!isClickOutside || !middleware(event, el)) {\n        return\n    }\n\n    handler(event, el)\n}\n\nfunction toggleEventListeners({ eventHandlers } = {}, action = 'add') {\n    eventHandlers.forEach(({ event, handler }) => {\n        document[`${action}EventListener`](event, handler)\n    })\n}\n\nfunction bind(el, { value }) {\n    const { handler, middleware, events } = processArgs(value)\n\n    const instance = {\n        el,\n        eventHandlers: events.map((eventName) => ({\n            event: eventName,\n            handler: (event) => onEvent({ event, el, handler, middleware })\n        }))\n    }\n\n    toggleEventListeners(instance, 'add')\n\n    instances.push(instance)\n}\n\nfunction update(el, { value }) {\n    const { handler, middleware, events } = processArgs(value)\n    // `filter` instead of `find` for compat with IE\n    const instance = instances.filter((instance) => instance.el === el)[0]\n\n    toggleEventListeners(instance, 'remove')\n\n    instance.eventHandlers = events.map((eventName) => ({\n        event: eventName,\n        handler: (event) => onEvent({ event, el, handler, middleware })\n    }))\n\n    toggleEventListeners(instance, 'add')\n}\n\nfunction unbind(el) {\n    // `filter` instead of `find` for compat with IE\n    const instance = instances.filter((instance) => instance.el === el)[0]\n\n    toggleEventListeners(instance, 'remove')\n}\n\nconst directive = {\n    bind,\n    update,\n    unbind,\n    instances\n}\n\nexport default directive\n",
      "path": "src/directives/clickOutside.js"
    },
    {
      "type": "registry:component",
      "target": "components/navbar/index.js",
      "content": "import Navbar from '@/components/navbar/Navbar'\nimport NavbarItem from '@/components/navbar/NavbarItem'\nimport NavbarDropdown from '@/components/navbar/NavbarDropdown'\n\nimport { use, registerComponent } from '@/utils/plugins'\n\nconst Plugin = {\n    install(Vue) {\n        registerComponent(Vue, Navbar)\n        registerComponent(Vue, NavbarItem)\n        registerComponent(Vue, NavbarDropdown)\n    }\n}\n\nuse(Plugin)\n\nexport default Plugin\n\nexport {\n    Navbar as BNavbar,\n    NavbarItem as BNavbarItem,\n    NavbarDropdown as BNavbarDropdown\n}\n",
      "path": "src/components/navbar/index.js"
    },
    {
      "type": "registry:component",
      "target": "components/navbar/Navbar.vue",
      "content": "<script>\nimport NavbarBurger from '@/components/navbar/NavbarBurger'\nimport clickOutside from '@/directives/clickOutside'\n\nconst FIXED_TOP_CLASS = 'is-fixed-top'\nconst BODY_FIXED_TOP_CLASS = 'has-navbar-fixed-top'\nconst BODY_SPACED_FIXED_TOP_CLASS = 'has-spaced-navbar-fixed-top'\nconst FIXED_BOTTOM_CLASS = 'is-fixed-bottom'\nconst BODY_FIXED_BOTTOM_CLASS = 'has-navbar-fixed-bottom'\nconst BODY_SPACED_FIXED_BOTTOM_CLASS = 'has-spaced-navbar-fixed-bottom'\nconst BODY_CENTERED_CLASS = 'has-navbar-centered'\n\nconst isFilled = (str) => !!str\n\nexport default {\n    name: 'BNavbar',\n    components: {\n        NavbarBurger\n    },\n    directives: {\n        clickOutside\n    },\n    // deprecated, to replace with default 'value' in the next breaking change\n    model: {\n        prop: 'active',\n        event: 'update:active'\n    },\n    props: {\n        type: [String, Object],\n        transparent: {\n            type: Boolean,\n            default: false\n        },\n        fixedTop: {\n            type: Boolean,\n            default: false\n        },\n        fixedBottom: {\n            type: Boolean,\n            default: false\n        },\n        active: {\n            type: Boolean,\n            default: false\n        },\n        centered: {\n            type: Boolean,\n            default: false\n        },\n        wrapperClass: {\n            type: [String, Array, Object]\n        },\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        mobileBurger: {\n            type: Boolean,\n            default: true\n        },\n        spaced: Boolean,\n        shadow: Boolean\n    },\n    data() {\n        return {\n            internalIsActive: this.active,\n            _isNavBar: true // Used internally by NavbarItem\n        }\n    },\n    computed: {\n        isOpened() {\n            return this.internalIsActive\n        },\n        computedClasses() {\n            return [\n                this.type,\n                {\n                    [FIXED_TOP_CLASS]: this.fixedTop,\n                    [FIXED_BOTTOM_CLASS]: this.fixedBottom,\n                    [BODY_CENTERED_CLASS]: this.centered,\n                    'is-spaced': this.spaced,\n                    'has-shadow': this.shadow,\n                    'is-transparent': this.transparent\n                }\n            ]\n        }\n    },\n    watch: {\n        active: {\n            handler(active) {\n                this.internalIsActive = active\n            },\n            immediate: true\n        },\n        fixedTop(isSet) {\n            // toggle body class only on update to handle multiple navbar\n            this.setBodyFixedTopClass(isSet)\n        },\n        bottomTop(isSet) {\n            // toggle body class only on update to handle multiple navbar\n            this.setBodyFixedBottomClass(isSet)\n        }\n    },\n    methods: {\n        toggleActive() {\n            this.internalIsActive = !this.internalIsActive\n            this.emitUpdateParentEvent()\n        },\n        closeMenu() {\n            if (this.closeOnClick && this.internalIsActive) {\n                this.internalIsActive = false\n                this.emitUpdateParentEvent()\n            }\n        },\n        emitUpdateParentEvent() {\n            this.$emit('update:active', this.internalIsActive)\n        },\n        setBodyClass(className) {\n            if (typeof window !== 'undefined') {\n                document.body.classList.add(className)\n            }\n        },\n        removeBodyClass(className) {\n            if (typeof window !== 'undefined') {\n                document.body.classList.remove(className)\n            }\n        },\n        checkIfFixedPropertiesAreColliding() {\n            const areColliding = this.fixedTop && this.fixedBottom\n            if (areColliding) {\n                throw new Error('You should choose if the BNavbar is fixed bottom or fixed top, but not both')\n            }\n        },\n        genNavbar(createElement) {\n            let navBarSlots = [\n                this.genNavbarBrandNode(createElement),\n                this.genNavbarSlotsNode(createElement)\n            ]\n\n            if (!isFilled(this.wrapperClass)) {\n                return this.genNavbarSlots(createElement, navBarSlots)\n            }\n\n            // It wraps the slots into a div with the provided wrapperClass prop\n            const navWrapper = createElement('div', {\n                class: this.wrapperClass\n            }, navBarSlots)\n\n            return this.genNavbarSlots(createElement, [navWrapper])\n        },\n        genNavbarSlots(createElement, slots) {\n            return createElement('nav', {\n                staticClass: 'navbar',\n                class: this.computedClasses,\n                attrs: {\n                    role: 'navigation',\n                    'aria-label': 'main navigation'\n                },\n                directives: [\n                    {\n                        name: 'click-outside',\n                        value: this.closeMenu\n                    }\n                ]\n            }, slots)\n        },\n        genNavbarBrandNode(createElement) {\n            return createElement('div', {\n                class: 'navbar-brand'\n            }, [this.$slots.brand, this.genBurgerNode(createElement)])\n        },\n        genBurgerNode(createElement) {\n            if (this.mobileBurger) {\n                const defaultBurgerNode = createElement('navbar-burger', {\n                    props: {\n                        isOpened: this.isOpened\n                    },\n                    on: {\n                        click: this.toggleActive,\n                        keyup: (event) => {\n                            if (event.keyCode !== 13) return\n                            this.toggleActive()\n                        }\n                    }\n                })\n\n                const hasBurgerSlot = !!this.$scopedSlots.burger\n                return hasBurgerSlot\n                    ? this.$scopedSlots.burger({\n                        isOpened: this.isOpened,\n                        toggleActive: this.toggleActive\n                    })\n                    : defaultBurgerNode\n            }\n        },\n        genNavbarSlotsNode(createElement) {\n            return createElement('div', {\n                staticClass: 'navbar-menu',\n                class: { 'is-active': this.isOpened }\n            }, [this.genMenuPosition(createElement, 'start'), this.genMenuPosition(createElement, 'end')])\n        },\n        genMenuPosition(createElement, positionName) {\n            return createElement('div', {\n                staticClass: `navbar-${positionName}`\n            }, this.$slots[positionName])\n        },\n        setBodyFixedTopClass(isSet) {\n            this.checkIfFixedPropertiesAreColliding()\n            if (isSet) {\n                // TODO Apply only one of the classes once PR is merged in Bulma:\n                // https://github.com/jgthms/bulma/pull/2737\n                this.setBodyClass(BODY_FIXED_TOP_CLASS)\n                this.spaced && this.setBodyClass(BODY_SPACED_FIXED_TOP_CLASS)\n            } else {\n                this.removeBodyClass(BODY_FIXED_TOP_CLASS)\n                this.removeBodyClass(BODY_SPACED_FIXED_TOP_CLASS)\n            }\n        },\n        setBodyFixedBottomClass(isSet) {\n            this.checkIfFixedPropertiesAreColliding()\n            if (isSet) {\n                // TODO Apply only one of the classes once PR is merged in Bulma:\n                // https://github.com/jgthms/bulma/pull/2737\n                this.setBodyClass(BODY_FIXED_BOTTOM_CLASS)\n                this.spaced && this.setBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS)\n            } else {\n                this.removeBodyClass(BODY_FIXED_BOTTOM_CLASS)\n                this.removeBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS)\n            }\n        }\n    },\n    beforeMount() {\n        this.fixedTop && this.setBodyFixedTopClass(true)\n        this.fixedBottom && this.setBodyFixedBottomClass(true)\n    },\n    beforeDestroy() {\n        if (this.fixedTop) {\n            const className = this.spaced\n                ? BODY_SPACED_FIXED_TOP_CLASS : BODY_FIXED_TOP_CLASS\n            this.removeBodyClass(className)\n        } else if (this.fixedBottom) {\n            const className = this.spaced\n                ? BODY_SPACED_FIXED_BOTTOM_CLASS : BODY_FIXED_BOTTOM_CLASS\n            this.removeBodyClass(className)\n        }\n    },\n    render(createElement, fn) {\n        return this.genNavbar(createElement)\n    }\n}\n</script>\n",
      "path": "src/components/navbar/Navbar.vue"
    },
    {
      "type": "registry:component",
      "target": "components/navbar/NavbarBurger.vue",
      "content": "<template>\n    <a\n        role=\"button\"\n        class=\"navbar-burger burger\"\n        :class=\"{ 'is-active': isOpened }\"\n        aria-label=\"menu\"\n        :aria-expanded=\"isOpened\"\n        v-on=\"$listeners\"\n        tabindex=\"0\"\n    >\n        <span aria-hidden=\"true\"/>\n        <span aria-hidden=\"true\"/>\n        <span aria-hidden=\"true\"/>\n    </a>\n</template>\n\n<script>\nexport default {\n    name: 'NavbarBurger',\n    props: {\n        isOpened: {\n            type: Boolean,\n            default: false\n        }\n    }\n}\n</script>\n",
      "path": "src/components/navbar/NavbarBurger.vue"
    },
    {
      "type": "registry:component",
      "target": "components/navbar/NavbarDropdown.vue",
      "content": "<template>\n    <div\n        class=\"navbar-item has-dropdown\"\n        :class=\"{\n            'is-hoverable': isHoverable,\n            'is-active': newActive\n        }\"\n        @mouseenter=\"checkHoverable\"\n        v-click-outside=\"closeMenu\"\n    >\n        <component\n            :is=\"tag\"\n            class=\"navbar-link\"\n            :class=\"{\n                'is-arrowless': arrowless,\n                'is-active': newActive && collapsible\n            }\"\n            v-bind=\"$attrs\"\n            v-on=\"$listeners\"\n            aria-haspopup=\"true\"\n            @click.prevent=\"toggleMenu\"\n            @keyup.enter=\"toggleMenu\"\n            tabindex=\"0\"\n        >\n            <template v-if=\"label\">{{ label }}</template>\n            <slot v-else name=\"label\" />\n        </component>\n        <div\n            class=\"navbar-dropdown\"\n            :class=\"{\n                'is-right': right,\n                'is-boxed': boxed,\n                'is-hidden-touch': collapsible && !newActive\n            }\"\n        >\n            <slot />\n        </div>\n    </div>\n</template>\n\n<script>\nimport clickOutside from '@/directives/clickOutside'\n\nexport default {\n    name: 'BNavbarDropdown',\n    directives: {\n        clickOutside\n    },\n    inheritAttrs: false,\n    props: {\n        label: String,\n        hoverable: Boolean,\n        active: Boolean,\n        right: Boolean,\n        arrowless: Boolean,\n        boxed: Boolean,\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        collapsible: Boolean,\n        tag: {\n            type: String,\n            default: 'a'\n        }\n    },\n    data() {\n        return {\n            newActive: this.active,\n            isHoverable: this.hoverable,\n            _isNavbarDropdown: true // Used internally by NavbarItem\n        }\n    },\n    watch: {\n        active(value) {\n            this.newActive = value\n        },\n\n        newActive(value) {\n            this.$emit('active-change', value)\n        }\n    },\n    methods: {\n        toggleMenu() {\n            this.newActive = !this.newActive\n        },\n        showMenu() {\n            this.newActive = true\n        },\n        /**\n        * See naming convetion of navbaritem\n        */\n        closeMenu() {\n            this.newActive = !this.closeOnClick\n            if (this.hoverable && this.closeOnClick) {\n                this.isHoverable = false\n            }\n        },\n        checkHoverable() {\n            if (this.hoverable) {\n                this.isHoverable = true\n            }\n        }\n    }\n}\n</script>\n",
      "path": "src/components/navbar/NavbarDropdown.vue"
    },
    {
      "type": "registry:component",
      "target": "components/navbar/NavbarItem.vue",
      "content": "<template>\n    <component\n        :is=\"tag\"\n        class=\"navbar-item\"\n        :class=\"{\n            'is-active': active\n        }\"\n        v-bind=\"$attrs\"\n        v-on=\"$listeners\">\n        <slot/>\n    </component>\n</template>\n\n<script>\nconst clickableWhiteList = ['div', 'span', 'input']\n\nexport default {\n    name: 'BNavbarItem',\n    inheritAttrs: false,\n    props: {\n        tag: {\n            type: String,\n            default: 'a'\n        },\n        active: Boolean\n    },\n    methods: {\n        /**\n         * Keypress event that is bound to the document\n         */\n        keyPress({ key }) {\n            if (key === 'Escape' || key === 'Esc') {\n                this.closeMenuRecursive(this, ['NavBar'])\n            }\n        },\n        /**\n         * Close parent if clicked outside.\n         */\n        handleClickEvent(event) {\n            const isOnWhiteList = clickableWhiteList.some((item) => item === event.target.localName)\n            if (!isOnWhiteList) {\n                const parent = this.closeMenuRecursive(this, ['NavbarDropdown', 'NavBar'])\n                if (parent && parent.$data._isNavbarDropdown) this.closeMenuRecursive(parent, ['NavBar'])\n            }\n        },\n        /**\n         * Close parent recursively\n         */\n        closeMenuRecursive(current, targetComponents) {\n            if (!current.$parent) return null\n            const foundItem = targetComponents.reduce((acc, item) => {\n                if (current.$parent.$data[`_is${item}`]) {\n                    current.$parent.closeMenu()\n                    return current.$parent\n                }\n                return acc\n            }, null)\n            return foundItem || this.closeMenuRecursive(current.$parent, targetComponents)\n        }\n    },\n    mounted() {\n        if (typeof window !== 'undefined') {\n            this.$el.addEventListener('click', this.handleClickEvent)\n            document.addEventListener('keyup', this.keyPress)\n        }\n    },\n    beforeDestroy() {\n        if (typeof window !== 'undefined') {\n            this.$el.removeEventListener('click', this.handleClickEvent)\n            document.removeEventListener('keyup', this.keyPress)\n        }\n    }\n}\n</script>\n",
      "path": "src/components/navbar/NavbarItem.vue"
    },
    {
      "type": "registry:lib",
      "target": "utils/plugins.js",
      "content": "\nexport const use = (plugin) => {\n    if (typeof window !== 'undefined' && window.Vue) {\n        window.Vue.use(plugin)\n    }\n}\n\nexport const registerComponent = (Vue, component) => {\n    Vue.component(component.name, component)\n}\n\nexport const registerComponentProgrammatic = (Vue, property, component) => {\n    if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {}\n    Vue.prototype.$buefy[property] = component\n}\n",
      "path": "src/utils/plugins.js"
    }
  ]
}
